[{"content":"可以使用以下命令将远程分支拉到本地：\n 首先，使用 git remote 命令查看已经添加的远程仓库：  git remote 然后，使用 git fetch 命令将远程分支拉取到本地仓库（不会进行合并）：  git fetch origin remote_branch 最后，使用 git checkout 命令将远程分支切换到本地分支：  git checkout local_branch 组合命令  git fetch origin remote_branch:local_branch 其中，remote_branch 为远程分支名称，origin 为远程仓库名称，local_branch 为本地分支名称，可以根据实际情况进行替换。\n","permalink":"https://tangxiaomi.top/posts/git/remote-branch/","summary":"可以使用以下命令将远程分支拉到本地：\n 首先，使用 git remote 命令查看已经添加的远程仓库：  git remote 然后，使用 git fetch 命令将远程分支拉取到本地仓库（不会进行合并）：  git fetch origin remote_branch 最后，使用 git checkout 命令将远程分支切换到本地分支：  git checkout local_branch 组合命令  git fetch origin remote_branch:local_branch 其中，remote_branch 为远程分支名称，origin 为远程仓库名称，local_branch 为本地分支名称，可以根据实际情况进行替换。","title":"git 将远程分支拉到本地"},{"content":"{ // 在保存时自动格式化代码 \u0026#34;editor.formatOnSave\u0026#34;: true, // 在按下“Commit”字符(如\u0026#34;.\u0026#34;或\u0026#34;;\u0026#34;)时接受建议 \u0026#34;editor.acceptSuggestionOnCommitCharacter\u0026#34;: true, // 在按下“Enter”时接受建议 \u0026#34;editor.acceptSuggestionOnEnter\u0026#34;: \u0026#34;on\u0026#34;, // 自动启用辅助功能 \u0026#34;editor.accessibilitySupport\u0026#34;: \u0026#34;auto\u0026#34;, // 启用背景颜色样式，在编辑器中显示错误和警告等 \u0026#34;editor.colorDecorators\u0026#34;: true, // 光标闪烁类型(\u0026#34;blink\u0026#34;、\u0026#34;smooth\u0026#34; 或 \u0026#34;phase\u0026#34;) \u0026#34;editor.cursorBlinking\u0026#34;: \u0026#34;blink\u0026#34;, // 开启平滑光标动画 \u0026#34;editor.cursorSmoothCaretAnimation\u0026#34;: false, // 光标样式(\u0026#34;block\u0026#34;, \u0026#34;line\u0026#34; 或 \u0026#34;underline\u0026#34;) \u0026#34;editor.cursorStyle\u0026#34;: \u0026#34;line\u0026#34;, // 高亮当前行周围的行数(Highlight current line plus n lines) \u0026#34;editor.cursorSurroundingLines\u0026#34;: 3, // 光标宽度，0 表示使用默认值 \u0026#34;editor.cursorWidth\u0026#34;: 0, // 禁用字形图层提示 \u0026#34;editor.disableLayerHinting\u0026#34;: true, // 禁用等宽字体的优化 \u0026#34;editor.disableMonospaceOptimizations\u0026#34;: false, // 启用拖放支持 \u0026#34;editor.dragAndDrop\u0026#34;: true, // 在空文本中复制时复制当前行或上次选区内容 \u0026#34;editor.emptySelectionClipboard\u0026#34;: true, // 额外的编辑器类名 \u0026#34;editor.extraEditorClassName\u0026#34;: \u0026#34;\u0026#34;, // 编辑器字体 \u0026#34;editor.fontFamily\u0026#34;: \u0026#34;\u0026#39;Droid Sans Mono\u0026#39;, \u0026#39;monospace\u0026#39;, monospace, \u0026#39;Droid Sans Fallback\u0026#39;\u0026#34;, // 启用字体连字 \u0026#34;editor.fontLigatures\u0026#34;: false, // 编辑器字体大小 \u0026#34;editor.fontSize\u0026#34;: 14, // 编辑器字体重量 \u0026#34;editor.fontWeight\u0026#34;: \u0026#34;\u0026#34;, // 粘贴时自动格式化代码 \u0026#34;editor.formatOnPaste\u0026#34;: false, // 显示标尺栏 \u0026#34;editor.glyphMargin\u0026#34;: true, // 在悬停编辑器概述标尺时隐藏光标 \u0026#34;editor.hideCursorInOverviewRuler\u0026#34;: false, // 在敲击代码时显示内联建议 \u0026#34;editor.inlineSuggest.enabled\u0026#34;: true, // 启用内部可访问支持 \u0026#34;editor.internalAccessibilitySupport\u0026#34;: \u0026#34;auto\u0026#34;, // 启用大文件的优化 \u0026#34;editor.largeFileOptimizations\u0026#34;: true, // 高亮匹配的括号 \u0026#34;editor.matchBrackets\u0026#34;: true, // 启用小地图 \u0026#34;editor.minimap.enabled\u0026#34;: false, // 显示的小地图的最大列数 \u0026#34;editor.minimap.maxColumn\u0026#34;: 120, // 渲染小地图中的字符 \u0026#34;editor.minimap.renderCharacters\u0026#34;: true, // 小地图与实际大小的比例 \u0026#34;editor.minimap.scale\u0026#34;: 1, // 小地图右侧的滑块何时显示(\u0026#34;mouseover\u0026#34;、\u0026#34;always\u0026#34; 或 \u0026#34;never\u0026#34;) \u0026#34;editor.minimap.showSlider\u0026#34;: \u0026#34;mouseover\u0026#34;, // 小地图在哪个侧边栏显示(\u0026#34;left\u0026#34; 或 \u0026#34;right\u0026#34;) \u0026#34;editor.minimap.side\u0026#34;: \u0026#34;right\u0026#34;, // 启用鼠标滚轮缩放 \u0026#34;editor.mouseWheelZoom\u0026#34;: false, // 多光标时将影响重叠的光标合并到单个光标中 \u0026#34;editor.multiCursorMergeOverlapping\u0026#34;: true, // 启用多光标选择的修改键, 可选值包括 \u0026#34;ctrlCmd\u0026#34;、 \u0026#34;alt\u0026#34;、\u0026#34;shift\u0026#34; 和 \u0026#34;meta\u0026#34; \u0026#34;editor.multiCursorModifier\u0026#34;: \u0026#34;alt\u0026#34;, // 鼠标移到函数名称上时是否显示参数提示 \u0026#34;editor.parameterHints\u0026#34;: true, // 在敲击代码时显示语言支持的快速建议 \u0026#34;editor.quickSuggestions\u0026#34;: true, // 快速建议的延迟时间（毫秒） \u0026#34;editor.quickSuggestionsDelay\u0026#34;: 10, // 是否只读，禁止编辑 \u0026#34;editor.readOnly\u0026#34;: false, // 渲染控制字符(CR/LF/Tab) 的显示方式 \u0026#34;editor.renderControlCharacters\u0026#34;: false, // 渲染最后一个仅包含换行符的行 \u0026#34;editor.renderFinalNewline\u0026#34;: true, // 渲染缩进参考线 \u0026#34;editor.renderIndentGuides\u0026#34;: true, // 当前行高亮的样式(\u0026#34;line\u0026#34;, \u0026#34;gutter\u0026#34; 或者 \u0026#34;none\u0026#34;) \u0026#34;editor.renderLineHighlight\u0026#34;: \u0026#34;line\u0026#34;, // 控制空格和 Tab 的呈现方式 \u0026#34;editor.renderWhitespace\u0026#34;: \u0026#34;none\u0026#34;, // 滚动时突出光标 \u0026#34;editor.revealCursorOnScroll\u0026#34;: true, // 启用默认的 Windows 平台的前向选择样式 \u0026#34;editor.roundedSelection\u0026#34;: true, // 设置标尺的位置 \u0026#34;editor.rulers\u0026#34;: [], // 允许在行的末尾进行额外的滚动，将光标保持在最后一列之后 \u0026#34;editor.scrollBeyondLastColumn\u0026#34;: 5, // 允许在行的末尾进行额外的滚动，将光标保持在最后一行之后 \u0026#34;editor.scrollBeyondLastLine\u0026#34;: true, // 允许在编辑器之间复制和粘贴选择 \u0026#34;editor.selectionClipboard\u0026#34;: true, // 启用匹配选择项 \u0026#34;editor.selectionHighlight\u0026#34;: true, // 显示废弃的语法提示 \u0026#34;editor.showDeprecated\u0026#34;: true, // 前导行代码折叠控制的显示方式(\u0026#34;mouseover\u0026#34;、\u0026#34;always\u0026#34; 或 \u0026#34;none\u0026#34;) \u0026#34;editor.showFoldingControls\u0026#34;: \u0026#34;mouseover\u0026#34;, // 高亮缩进，淡化其他内容 \u0026#34;editor.showIndentGuides\u0026#34;: true, // 是否显示行号 \u0026#34;editor.showLineNumbers\u0026#34;: true, // 当前行之前滚动的行数(仅在scrollbarHover才有用) \u0026#34;editor.showPreviousLine\u0026#34;: true, // 显示未使用的代码 \u0026#34;editor.showUnused\u0026#34;: true, // 启用代码片段建议 \u0026#34;editor.snippetSuggestions\u0026#34;: \u0026#34;top\u0026#34;, // 在触发字符后自动显示建议 \u0026#34;editor.suggestOnTriggerCharacters\u0026#34;: true, // 控制如何预先选择建议 \u0026#34;editor.suggestSelection\u0026#34;: \u0026#34;recentlyUsed\u0026#34;, // 控制如何使用 Tab 键来接受建议 \u0026#34;editor.tabCompletion\u0026#34;: \u0026#34;on\u0026#34;, // 缩进宽度 \u0026#34;editor.tabSize\u0026#34;: 4, // 在保存时将自动删除行末的空白 \u0026#34;editor.trimAutoWhitespace\u0026#34;: true, // 智能选词分隔符 \u0026#34;editor.wordSeparators\u0026#34;: \u0026#34;~!@#$%^\u0026amp;*()-=+[{]}\\\\|;:\u0026#39;\\\u0026#34;,.\u0026lt;\u0026gt;/?\u0026#34;, // 控制自动换行(\u0026#34;off\u0026#34;, \u0026#34;on\u0026#34; 或 \u0026#34;wordWrapColumn\u0026#34;) \u0026#34;editor.wordWrap\u0026#34;: \u0026#34;off\u0026#34;, // 定义哪些字符可能会成为单独一行的断点 \u0026#34;editor.wordWrapBreakAfterCharacters\u0026#34;: \u0026#34;\\t})]?|\u0026amp;,;\u0026#34;, // 定义哪些字符可能会成为单独一行 \u0026#34;editor.wordWrapBreakBeforeCharacters\u0026#34;: \u0026#34;{([+\u0026#34;, // 定义哪些字符可能会成为单独一行的断点之前以及之后(\u0026#34;wordWrapBreakAfterCharacters\u0026#34;和\u0026#34;wordWrapBreakBeforeCharacters\u0026#34;的结合使用) \u0026#34;editor.wordWrapBreakObtrusiveCharacters\u0026#34;: \u0026#34;.\u0026#34;, // 在wordWrap:\u0026#34;wordWrapColumn\u0026#34;模式下控制编辑器的自动换行 \u0026#34;editor.wordWrapColumn\u0026#34;: 80, // 在 minified 文件中启用自动换行 \u0026#34;editor.wordWrapMinified\u0026#34;: true, // 在多行的第二行和之后缩进相对于第一行 \u0026#34;editor.wrappingIndent\u0026#34;: \u0026#34;same\u0026#34;, // 是否在首选项中启用折叠区域代码折叠 \u0026#34;editor.folding\u0026#34;: true, // 在预览(鼠标悬停)中显示文档 \u0026#34;editor.hover.enabled\u0026#34;: true, // 在鼠标悬停时就显示预览信息，而不是等待300ms \u0026#34;editor.hover.delay\u0026#34;: 300, // 键入时在符号或标签加亮 \u0026#34;editor.occurrencesHighlight\u0026#34;: true, // 在重命名符号时更新所有引用 \u0026#34;editor.renameOnType\u0026#34;: false, // 修改字体时放大或缩小编辑器 \u0026#34;editor.mouseWheelZoomDelta\u0026#34;: 2, // 滚动鼠标的灵敏度 \u0026#34;editor.mouseWheelScrollSensitivity\u0026#34;: 1, // 平滑滚动 \u0026#34;editor.mouseWheelSmoothScroll\u0026#34;: false, // 显示诊断消息(错误、警告等) \u0026#34;editor.showDiagnostics\u0026#34;: \u0026#34;warnings\u0026#34;, // 显示代码折叠控件 \u0026#34;editor.showFoldingControlsAlways\u0026#34;: true, // 高亮匹配括号的间距(以像素为单位) \u0026#34;editor.matchBracketsSpace\u0026#34;: 0, // 控制当在一个断点处输入或删除字符时如何保持缩进 \u0026#34;editor.autoIndent\u0026#34;: \u0026#34;advanced\u0026#34;, // 描述按下 Tab 键时应插入的空白 \u0026#34;editor.useTabStops\u0026#34;: true, // 保留换行符类型 \u0026#34;files.insertFinalNewline\u0026#34;: true, // 在使用 tab 时，插入 N 个空格 \u0026#34;editor.tabSize\u0026#34;: 4, // 开启 Emmet 功能 \u0026#34;emmet.triggerExpansionOnTab\u0026#34;: true, // 启用 emmet 的 auto-preview模式 \u0026#34;emmet.showAbbreviationSuggestions\u0026#34;: true, // 在 HTML 中，为开始和结束标记自动插入一个新行 \u0026#34;emmet.html.format.indentation\u0026#34;: \u0026#34; \u0026#34;, // 在标记之间插入空格 \u0026#34;emmet.syntaxProfiles\u0026#34;: { \u0026#34;javascript\u0026#34;: { \u0026#34;attr_quotes\u0026#34;: \u0026#34;single\u0026#34; } } } ","permalink":"https://tangxiaomi.top/posts/vscode/setting/","summary":"{ // 在保存时自动格式化代码 \u0026#34;editor.formatOnSave\u0026#34;: true, // 在按下“Commit”字符(如\u0026#34;.\u0026#34;或\u0026#34;;\u0026#34;)时接受建议 \u0026#34;editor.acceptSuggestionOnCommitCharacter\u0026#34;: true, // 在按下“Enter”时接受建议 \u0026#34;editor.acceptSuggestionOnEnter\u0026#34;: \u0026#34;on\u0026#34;, // 自动启用辅助功能 \u0026#34;editor.accessibilitySupport\u0026#34;: \u0026#34;auto\u0026#34;, // 启用背景颜色样式，在编辑器中显示错误和警告等 \u0026#34;editor.colorDecorators\u0026#34;: true, // 光标闪烁类型(\u0026#34;blink\u0026#34;、\u0026#34;smooth\u0026#34; 或 \u0026#34;phase\u0026#34;) \u0026#34;editor.cursorBlinking\u0026#34;: \u0026#34;blink\u0026#34;, // 开启平滑光标动画 \u0026#34;editor.cursorSmoothCaretAnimation\u0026#34;: false, // 光标样式(\u0026#34;block\u0026#34;, \u0026#34;line\u0026#34; 或 \u0026#34;underline\u0026#34;) \u0026#34;editor.cursorStyle\u0026#34;: \u0026#34;line\u0026#34;, // 高亮当前行周围的行数(Highlight current line plus n lines) \u0026#34;editor.cursorSurroundingLines\u0026#34;: 3, // 光标宽度，0 表示使用默认值 \u0026#34;editor.cursorWidth\u0026#34;: 0, // 禁用字形图层提示 \u0026#34;editor.disableLayerHinting\u0026#34;: true, // 禁用等宽字体的优化 \u0026#34;editor.disableMonospaceOptimizations\u0026#34;: false, // 启用拖放支持 \u0026#34;editor.dragAndDrop\u0026#34;: true, // 在空文本中复制时复制当前行或上次选区内容 \u0026#34;editor.emptySelectionClipboard\u0026#34;: true, // 额外的编辑器类名 \u0026#34;editor.","title":"vscode 所有配置对照表"},{"content":"简介 ESLint是一个开源的 JavaScript 代码检查工具，可以帮助我们发现代码中存在的错误和潜在问题，并给出推荐的修复方案，从而提高代码的质量和可读性。\n本文将要介绍如何在VSCode中配置ESLint，实现自动保存校验功能，让我们的代码更加健康。\n步骤 第一步：安装ESLint插件 如果没有安装ESLint插件的话，我们需要先到VSCode插件商店中安装ESLint插件，安装过程非常简单，只需要在搜索框中输入“ESLint”即可。\n第二步：安装ESLint模块 在项目中安装ESLint模块依赖，可以使用npm或yarn，如下：\nnpm install eslint --save-dev 或\nyarn add eslint --dev 第三步：创建ESLint配置文件 创建一个名为.eslintrc.json的文件，用来存放ESLint配置信息。\n{ \u0026quot;extends\u0026quot;: \u0026quot;eslint:recommended\u0026quot;, \u0026quot;rules\u0026quot;: {} } 这里使用了eslint:recommended作为配置的扩展，这些规则是由ESLint核心团队定义的一组推荐的规则。当然你也可以自定义一些规则，具体可参考官方文档。\n第四步：配置VSCode 我们需要在VSCode的配置文件中，添加以下内容实现自动保存校验。\n{ \u0026quot;editor.codeActionsOnSave\u0026quot;: { \u0026quot;source.fixAll.eslint\u0026quot;: true }, \u0026quot;editor.formatOnSave\u0026quot;: false, \u0026quot;eslint.alwaysShowStatus\u0026quot;: true, \u0026quot;eslint.validate\u0026quot;: [ \u0026quot;javascript\u0026quot;, \u0026quot;javascriptreact\u0026quot;, { \u0026quot;language\u0026quot;: \u0026quot;vue\u0026quot;, \u0026quot;autoFix\u0026quot;: true }, { \u0026quot;language\u0026quot;: \u0026quot;html\u0026quot;, \u0026quot;autoFix\u0026quot;: true } ] } 这里通过\u0026quot;editor.codeActionsOnSave\u0026quot;属性实现自动保存校验，当我们保存文件时，如果存在ESLint报错，VSCode会自动执行修复操作。\n同时将\u0026quot;editor.formatOnSave\u0026quot;设置为false，表示不对存储时代码格式进行调整。\n最后配置\u0026quot;eslint.validate\u0026quot;即可，这里我们对\u0026quot;javascript\u0026quot;和\u0026quot;javascriptreact\u0026quot;进行校验和自动修复，同时对Vue和HTML代码添加支持。\n总结 通过这个简单的配置，我们可以让ESLint与VSCode紧密地结合在一起，实现在保存代码之前、常规编写过程中进行代码检查校验。这将使我们能够更快地发现并修复潜在的问题，从而提高代码的质量和可读性。\n","permalink":"https://tangxiaomi.top/posts/vscode/eslint/","summary":"简介 ESLint是一个开源的 JavaScript 代码检查工具，可以帮助我们发现代码中存在的错误和潜在问题，并给出推荐的修复方案，从而提高代码的质量和可读性。\n本文将要介绍如何在VSCode中配置ESLint，实现自动保存校验功能，让我们的代码更加健康。\n步骤 第一步：安装ESLint插件 如果没有安装ESLint插件的话，我们需要先到VSCode插件商店中安装ESLint插件，安装过程非常简单，只需要在搜索框中输入“ESLint”即可。\n第二步：安装ESLint模块 在项目中安装ESLint模块依赖，可以使用npm或yarn，如下：\nnpm install eslint --save-dev 或\nyarn add eslint --dev 第三步：创建ESLint配置文件 创建一个名为.eslintrc.json的文件，用来存放ESLint配置信息。\n{ \u0026quot;extends\u0026quot;: \u0026quot;eslint:recommended\u0026quot;, \u0026quot;rules\u0026quot;: {} } 这里使用了eslint:recommended作为配置的扩展，这些规则是由ESLint核心团队定义的一组推荐的规则。当然你也可以自定义一些规则，具体可参考官方文档。\n第四步：配置VSCode 我们需要在VSCode的配置文件中，添加以下内容实现自动保存校验。\n{ \u0026quot;editor.codeActionsOnSave\u0026quot;: { \u0026quot;source.fixAll.eslint\u0026quot;: true }, \u0026quot;editor.formatOnSave\u0026quot;: false, \u0026quot;eslint.alwaysShowStatus\u0026quot;: true, \u0026quot;eslint.validate\u0026quot;: [ \u0026quot;javascript\u0026quot;, \u0026quot;javascriptreact\u0026quot;, { \u0026quot;language\u0026quot;: \u0026quot;vue\u0026quot;, \u0026quot;autoFix\u0026quot;: true }, { \u0026quot;language\u0026quot;: \u0026quot;html\u0026quot;, \u0026quot;autoFix\u0026quot;: true } ] } 这里通过\u0026quot;editor.codeActionsOnSave\u0026quot;属性实现自动保存校验，当我们保存文件时，如果存在ESLint报错，VSCode会自动执行修复操作。\n同时将\u0026quot;editor.formatOnSave\u0026quot;设置为false，表示不对存储时代码格式进行调整。\n最后配置\u0026quot;eslint.validate\u0026quot;即可，这里我们对\u0026quot;javascript\u0026quot;和\u0026quot;javascriptreact\u0026quot;进行校验和自动修复，同时对Vue和HTML代码添加支持。\n总结 通过这个简单的配置，我们可以让ESLint与VSCode紧密地结合在一起，实现在保存代码之前、常规编写过程中进行代码检查校验。这将使我们能够更快地发现并修复潜在的问题，从而提高代码的质量和可读性。","title":"用VSCode配置ESLint自动保存校验"},{"content":"🚀 前言 微信小程序是一种全新的应用模式，它可以在微信中直接运行，用户无需下载安装即可使用，具有开发简单、轻量级、低成本等优点，非常适合创业公司、个人开发者等快速开发原型或小型商业应用。\n🔧 准备工作 1. 安装微信开发者工具 微信小程序开发需要使用微信官方提供的开发者工具，点击这里下载适用于您的操作系统的开发者工具。\n2. 注册微信小程序账号 点击这里，注册一个微信小程序账号。\n3. 创建小程序 打开微信开发者工具，点击\u0026quot;新建小程序\u0026quot;按钮，按照提示填写小程序基本信息，即可创建一个最简单的小程序。\n🚀 开发第一个小程序 1. 目录结构 创建小程序后，微信开发者工具会自动生成一些模板文件，目录结构如下：\nmyproject ├── app.js ├── app.json ├── app.wxss └── pages └── index ├── index.js ├── index.json ├── index.wxml └── index.wxss 其中，app.js是小程序的脚本文件，app.json是小程序的配置文件，app.wxss是小程序的全局样式表。\npages目录下是小程序的页面文件，每个页面文件都由4个文件组成：脚本文件（.js）、配置文件（.json）、模板文件（.wxml）和样式表文件（.wxss）。\n2. Hello World 打开index.wxml，在其中输入以下代码：\n\u0026lt;!--index.wxml--\u0026gt; \u0026lt;text\u0026gt;{{message}}\u0026lt;/text\u0026gt; 打开index.js，在其中输入以下代码：\n//index.js Page({ data: { message: \u0026#34;Hello World\u0026#34; } }) 应用这些变更后，点击微信开发者工具的\u0026quot;预览\u0026quot;按钮，可以在微信中查看效果。\n3. 组件介绍 在示例代码中，我们使用了\u0026lt;text\u0026gt;标签，这是一种小程序内置的组件。在小程序中，所有显示内容都是由组件构成的，组件可以嵌套使用，从而构成丰富的页面布局。\n下面简单介绍几个常用组件：\n \u0026lt;view\u0026gt;：与HTML中的\u0026lt;div\u0026gt;类似，用于嵌套其它组件，可以设置样式或事件。 \u0026lt;text\u0026gt;：用于显示文本，可以设置颜色、字体大小等。 \u0026lt;button\u0026gt;：用于创建按钮，可以设置事件。 \u0026lt;image\u0026gt;：用于显示图片，可以设置 src 属性。  4. 数据绑定 在示例代码中，我们使用了{{message}}语法，将message变量的值绑定到\u0026lt;text\u0026gt;组件的内容中。\n数据绑定是小程序中非常常用的功能。除了上述这种插值绑定，还可以在属性中使用绑定语法：\n\u0026lt;!--index.wxml--\u0026gt; \u0026lt;view class=\u0026#34;{{className}}\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; //index.js Page({ data: { className: \u0026#34;red\u0026#34; } }) 这样的代码将给\u0026lt;view\u0026gt;组件的class属性动态赋值，从而实现样式切换等功能。\n5. 事件处理 小程序中的事件处理与普通的Web开发类似，也可以使用事件冒泡、事件委托等技术。\n下面是一个示例代码：\n\u0026lt;!--index.wxml--\u0026gt; \u0026lt;button bindtap=\u0026#34;onClick\u0026#34;\u0026gt;点击我\u0026lt;/button\u0026gt; //index.js Page({ onClick: function(event) { console.log(\u0026#34;按钮被点击了\u0026#34;) } }) 这段代码实现了一个简单的按钮点击事件，点击按钮后将在控制台输出信息。\n6. 网络请求 小程序具有完善的网络功能，可以使用wx.request()API发送HTTP请求，并处理返回的结果。\n下面是一个简单的示例代码：\n//index.js Page({ onLoad: function(options) { wx.request({ url: \u0026#34;https://api.github.com/users/octocat\u0026#34;, success: function(res) { console.log(res.data) }, fail: function() { console.log(\u0026#34;请求失败\u0026#34;) } }) } }) 这段代码实现了一个简单的网络请求，使用GitHub API获取了用户octocat的信息，并在控制台输出了返回结果。\n 如需深入学习相关内容，可以参考微信小程序官方文档：https://developers.weixin.qq.com/miniprogram/dev/index.html 。\n ","permalink":"https://tangxiaomi.top/posts/mini-program/getting-started/","summary":"🚀 前言 微信小程序是一种全新的应用模式，它可以在微信中直接运行，用户无需下载安装即可使用，具有开发简单、轻量级、低成本等优点，非常适合创业公司、个人开发者等快速开发原型或小型商业应用。\n🔧 准备工作 1. 安装微信开发者工具 微信小程序开发需要使用微信官方提供的开发者工具，点击这里下载适用于您的操作系统的开发者工具。\n2. 注册微信小程序账号 点击这里，注册一个微信小程序账号。\n3. 创建小程序 打开微信开发者工具，点击\u0026quot;新建小程序\u0026quot;按钮，按照提示填写小程序基本信息，即可创建一个最简单的小程序。\n🚀 开发第一个小程序 1. 目录结构 创建小程序后，微信开发者工具会自动生成一些模板文件，目录结构如下：\nmyproject ├── app.js ├── app.json ├── app.wxss └── pages └── index ├── index.js ├── index.json ├── index.wxml └── index.wxss 其中，app.js是小程序的脚本文件，app.json是小程序的配置文件，app.wxss是小程序的全局样式表。\npages目录下是小程序的页面文件，每个页面文件都由4个文件组成：脚本文件（.js）、配置文件（.json）、模板文件（.wxml）和样式表文件（.wxss）。\n2. Hello World 打开index.wxml，在其中输入以下代码：\n\u0026lt;!--index.wxml--\u0026gt; \u0026lt;text\u0026gt;{{message}}\u0026lt;/text\u0026gt; 打开index.js，在其中输入以下代码：\n//index.js Page({ data: { message: \u0026#34;Hello World\u0026#34; } }) 应用这些变更后，点击微信开发者工具的\u0026quot;预览\u0026quot;按钮，可以在微信中查看效果。\n3. 组件介绍 在示例代码中，我们使用了\u0026lt;text\u0026gt;标签，这是一种小程序内置的组件。在小程序中，所有显示内容都是由组件构成的，组件可以嵌套使用，从而构成丰富的页面布局。\n下面简单介绍几个常用组件：\n \u0026lt;view\u0026gt;：与HTML中的\u0026lt;div\u0026gt;类似，用于嵌套其它组件，可以设置样式或事件。 \u0026lt;text\u0026gt;：用于显示文本，可以设置颜色、字体大小等。 \u0026lt;button\u0026gt;：用于创建按钮，可以设置事件。 \u0026lt;image\u0026gt;：用于显示图片，可以设置 src 属性。  4. 数据绑定 在示例代码中，我们使用了{{message}}语法，将message变量的值绑定到\u0026lt;text\u0026gt;组件的内容中。","title":"微信小程序开发入门教程"},{"content":"JavaScript的高阶函数是一个非常强大的特性，它允许我们编写更加灵活和可重用的代码。在本文中，我们将探讨高阶函数的概念、它们如何实现以及一些示例。\n什么是高阶函数 高阶函数是指接受一个或多个函数作为参数，并可以返回函数作为结果的函数。这种函数可以用来将其他函数“包装起来”或者实现某种通用的行为。ES6的箭头函数使得编写高阶函数变得更加简单和方便。\n高阶函数的实现 下面是一个使用普通函数实现高阶函数的例子：\nfunction map(arr, fn) { const mappedArr = []; for (let i=0; i\u0026lt;arr.length; i++) { const val = fn(arr[i], i, arr); mappedArr.push(val); } return mappedArr; } 这个函数实现了一个非常常见的高阶函数——map()。它接受一个数组和一个函数作为参数，并返回一个新数组，这个新数组的元素是将原数组的每个元素传递给函数之后得到的新值。\n使用箭头函数，我们可以更加简洁地实现同样的功能：\nconst map = (arr, fn) =\u0026gt; arr.map(fn); 这个例子中，我们用箭头函数实现了一个新的map()函数。它使用了原生的Array.map()方法实现了同样的功能，代码更加简洁和优雅。\n高阶函数的示例 现在我们来看一些常见的高阶函数例子，以及它们如何用于实现通用的行为。\nforEach() forEach()是一个很常见的高阶函数，它用于遍历数组。我们可以使用它将一个函数应用于数组的每个元素：\nconst numbers = [1, 2, 3, 4, 5]; numbers.forEach(num =\u0026gt; console.log(num)); 这将会打印数组中的每个数字。\nfilter() filter()是另一个常见的高阶函数，它用于过滤数组。我们可以使用它筛选出我们想要的元素：\nconst people = [ {name: \u0026#39;John\u0026#39;, age: 25}, {name: \u0026#39;Jane\u0026#39;, age: 30}, {name: \u0026#39;Bob\u0026#39;, age: 20} ]; const adults = people.filter(person =\u0026gt; person.age \u0026gt;= 25); console.log(adults); 这将会输出年龄大于或等于25岁的人的信息。\nreduce() reduce()是一个非常强大的高阶函数，它可以从一个数组中提取出一个值。我们可以使用它来计算数组的平均值、求和等操作：\nconst numbers = [1, 2, 3, 4, 5]; const sum = numbers.reduce((acc, num) =\u0026gt; acc + num, 0); console.log(sum); 这将会输出数组的总和5。\n总结 高阶函数是一个非常有用和强大的概念。它们允许我们编写更加灵活和可重用的代码。在本文中，我们探讨了高阶函数的概念和实现方法，并给出了一些实际例子。当您编写JavaScript代码时，请记得考虑使用高阶函数来提高代码的可维护性和灵活性。\n","permalink":"https://tangxiaomi.top/posts/js/higher-order-function/","summary":"JavaScript的高阶函数是一个非常强大的特性，它允许我们编写更加灵活和可重用的代码。在本文中，我们将探讨高阶函数的概念、它们如何实现以及一些示例。\n什么是高阶函数 高阶函数是指接受一个或多个函数作为参数，并可以返回函数作为结果的函数。这种函数可以用来将其他函数“包装起来”或者实现某种通用的行为。ES6的箭头函数使得编写高阶函数变得更加简单和方便。\n高阶函数的实现 下面是一个使用普通函数实现高阶函数的例子：\nfunction map(arr, fn) { const mappedArr = []; for (let i=0; i\u0026lt;arr.length; i++) { const val = fn(arr[i], i, arr); mappedArr.push(val); } return mappedArr; } 这个函数实现了一个非常常见的高阶函数——map()。它接受一个数组和一个函数作为参数，并返回一个新数组，这个新数组的元素是将原数组的每个元素传递给函数之后得到的新值。\n使用箭头函数，我们可以更加简洁地实现同样的功能：\nconst map = (arr, fn) =\u0026gt; arr.map(fn); 这个例子中，我们用箭头函数实现了一个新的map()函数。它使用了原生的Array.map()方法实现了同样的功能，代码更加简洁和优雅。\n高阶函数的示例 现在我们来看一些常见的高阶函数例子，以及它们如何用于实现通用的行为。\nforEach() forEach()是一个很常见的高阶函数，它用于遍历数组。我们可以使用它将一个函数应用于数组的每个元素：\nconst numbers = [1, 2, 3, 4, 5]; numbers.forEach(num =\u0026gt; console.log(num)); 这将会打印数组中的每个数字。\nfilter() filter()是另一个常见的高阶函数，它用于过滤数组。我们可以使用它筛选出我们想要的元素：\nconst people = [ {name: \u0026#39;John\u0026#39;, age: 25}, {name: \u0026#39;Jane\u0026#39;, age: 30}, {name: \u0026#39;Bob\u0026#39;, age: 20} ]; const adults = people.","title":"js高阶函数"},{"content":"这是一份 Git 命令的快速查找手册，包含了 Git 的常用命令和基本用法。快速找到你需要的命令和用法，让你的 Git 使用更加轻松自如。\n🚀 初始化  git init : 初始化一个 Git 仓库。 git clone \u0026lt;URL\u0026gt; : 克隆一个远程 Git 仓库。  📝 添加与提交  git add \u0026lt;file\u0026gt; : 将文件添加到暂存区。 git add . : 将所有修改添加到暂存区。 git commit -m \u0026quot;\u0026lt;message\u0026gt;\u0026quot; : 提交变更并附上提交信息。 git commit -a : 跳过暂存区，直接提交所有变更。  🌿 分支和合并  git branch : 列出当前仓库的所有分支。 git branch \u0026lt;branch\u0026gt; : 创建一个新分支。 git checkout \u0026lt;branch\u0026gt; : 切换到一个分支。 git checkout -b \u0026lt;branch\u0026gt; : 创建一个新的分支并立即切换到该分支。 git merge \u0026lt;branch\u0026gt; : 合并指定分支到当前分支。 git merge --no-ff \u0026lt;branch\u0026gt; : 强制 Git 创建一个新的合并提交，即使当前分支可以通过快进合并到指定分支。  🔀 推送与拉取  git pull : 从远程仓库拉取代码。 git push : 将本地分支的更改推送到远程仓库。 git push -u \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; : 第一次推送分支时，使用此命令将本地分支推送到远程仓库。 git fetch \u0026lt;remote\u0026gt; : 从远程仓库拉取变更，但不自动合并它们。 git fetch --all : 从远程仓库拉取所有分支的变更，但不自动合并它们。 git push \u0026lt;remote\u0026gt; --delete \u0026lt;branch\u0026gt; : 从远程仓库删除指定分支。  🔎 查看日志  git log : 查看提交日志。 git log --oneline : 查看简洁的提交日志。 git log --graph --oneline : 查看提交日志并显示分支合并图。 git blame \u0026lt;file\u0026gt; : 显示指定文件的每一行是由谁添加的。  ❌ 撤销与修改  git checkout \u0026lt;file\u0026gt; : 用仓库中的文件替换工作目录中的文件，从而撤消最近的修订。 git reset HEAD \u0026lt;file\u0026gt; : 取消已暂存文件。 git reset HEAD~ : 返回上一个commit版本，并将文件修改保留在工作目录。 git reset \u0026lt;commit\u0026gt; : 恢复指定提交的状态，同时将工作区和暂存区的修改移回到工作区。 git reset --hard : 取消所有本地修改，并恢复到最近的提交状态。 git clean -f : 删除未被跟踪的文件。  🎨 其他命令  git status : 显示工作目录下已提交和未提交的修改。 git diff : 显示工作目录和本地仓库之间的差异。 git stash : 将工作目录中的未提交修改保存到一个栈中。 git stash apply : 恢复最新的stash，并将内容应用于工作区。 git stash list : 显示所有的stash记录。 git stash pop : 删除最新的stash，并将其应用于工作区。 git stash drop : 删除最新的stash。 git remote add \u0026lt;name\u0026gt; \u0026lt;url\u0026gt; : 将一个新远程仓库添加到当前 Git 仓库中。 git remote -v : 显示当前仓库的所有远程仓库及其 URL。 git tag : 列出已经存在的标签。 git tag \u0026lt;tagname\u0026gt; : 新建一个标签，默认为HEAD，用于后续推送到远程仓库。 git push origin \u0026lt;tagname\u0026gt; : 将指定标签推送到远程仓库。 git push origin --tags : 将所有标签推送到远程仓库。 git show \u0026lt;commit\u0026gt; : 显示指定提交的信息。  ","permalink":"https://tangxiaomi.top/posts/git/guide/","summary":"这是一份 Git 命令的快速查找手册，包含了 Git 的常用命令和基本用法。快速找到你需要的命令和用法，让你的 Git 使用更加轻松自如。\n🚀 初始化  git init : 初始化一个 Git 仓库。 git clone \u0026lt;URL\u0026gt; : 克隆一个远程 Git 仓库。  📝 添加与提交  git add \u0026lt;file\u0026gt; : 将文件添加到暂存区。 git add . : 将所有修改添加到暂存区。 git commit -m \u0026quot;\u0026lt;message\u0026gt;\u0026quot; : 提交变更并附上提交信息。 git commit -a : 跳过暂存区，直接提交所有变更。  🌿 分支和合并  git branch : 列出当前仓库的所有分支。 git branch \u0026lt;branch\u0026gt; : 创建一个新分支。 git checkout \u0026lt;branch\u0026gt; : 切换到一个分支。 git checkout -b \u0026lt;branch\u0026gt; : 创建一个新的分支并立即切换到该分支。 git merge \u0026lt;branch\u0026gt; : 合并指定分支到当前分支。 git merge --no-ff \u0026lt;branch\u0026gt; : 强制 Git 创建一个新的合并提交，即使当前分支可以通过快进合并到指定分支。  🔀 推送与拉取  git pull : 从远程仓库拉取代码。 git push : 将本地分支的更改推送到远程仓库。 git push -u \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; : 第一次推送分支时，使用此命令将本地分支推送到远程仓库。 git fetch \u0026lt;remote\u0026gt; : 从远程仓库拉取变更，但不自动合并它们。 git fetch --all : 从远程仓库拉取所有分支的变更，但不自动合并它们。 git push \u0026lt;remote\u0026gt; --delete \u0026lt;branch\u0026gt; : 从远程仓库删除指定分支。  🔎 查看日志  git log : 查看提交日志。 git log --oneline : 查看简洁的提交日志。 git log --graph --oneline : 查看提交日志并显示分支合并图。 git blame \u0026lt;file\u0026gt; : 显示指定文件的每一行是由谁添加的。  ❌ 撤销与修改  git checkout \u0026lt;file\u0026gt; : 用仓库中的文件替换工作目录中的文件，从而撤消最近的修订。 git reset HEAD \u0026lt;file\u0026gt; : 取消已暂存文件。 git reset HEAD~ : 返回上一个commit版本，并将文件修改保留在工作目录。 git reset \u0026lt;commit\u0026gt; : 恢复指定提交的状态，同时将工作区和暂存区的修改移回到工作区。 git reset --hard : 取消所有本地修改，并恢复到最近的提交状态。 git clean -f : 删除未被跟踪的文件。  🎨 其他命令  git status : 显示工作目录下已提交和未提交的修改。 git diff : 显示工作目录和本地仓库之间的差异。 git stash : 将工作目录中的未提交修改保存到一个栈中。 git stash apply : 恢复最新的stash，并将内容应用于工作区。 git stash list : 显示所有的stash记录。 git stash pop : 删除最新的stash，并将其应用于工作区。 git stash drop : 删除最新的stash。 git remote add \u0026lt;name\u0026gt; \u0026lt;url\u0026gt; : 将一个新远程仓库添加到当前 Git 仓库中。 git remote -v : 显示当前仓库的所有远程仓库及其 URL。 git tag : 列出已经存在的标签。 git tag \u0026lt;tagname\u0026gt; : 新建一个标签，默认为HEAD，用于后续推送到远程仓库。 git push origin \u0026lt;tagname\u0026gt; : 将指定标签推送到远程仓库。 git push origin --tags : 将所有标签推送到远程仓库。 git show \u0026lt;commit\u0026gt; : 显示指定提交的信息。  ","title":"git 命令手册 📖"},{"content":"Vite 是一个快速、轻量级、易于使用的前端工具。它为开发者提供了一种现代的构建方式，可以快速地构建出高效且易于维护的 Web 应用程序。\n在 Vite 版本 4.2 及以上的版本中，我们可以使用 configureServer 方法来拦截 Vite 开发服务器，并将其替换为 express HTTP 服务器。这样，我们就可以使用更加灵活的 HTTP 服务器组合，并且可以方便地实现登录、鉴权等功能。\n配置 Vite 插件 为了使用自定义的 express 应用程序，我们需要编写一个 Vite 插件\n我们可以通过 myPlugin 函数来创建一个新插件。这个插件暴露了一个 configureServer 方法，我们可以在这个方法中创建并配置一个 express 应用程序。\nimport express from \u0026#39;express\u0026#39; import cors from \u0026#39;cors\u0026#39; import bodyParser from \u0026#39;body-parser\u0026#39; import cookieParser from \u0026#39;cookie-parser\u0026#39; export default function myPlugin () { return { name: \u0026#39;my-plugin\u0026#39;, configureServer (server) { const app = express() app.use(cors({ credentials: true, origin: true })) app.use(bodyParser.urlencoded({ extended: false })) app.use(cookieParser()) server.middlewares.use(app) app.use(\u0026#39;/login\u0026#39;, () =\u0026gt; { // login  }) } } } 在 configureServer 方法中，我们首先创建了一个新的 express 应用程序 app。\n接下来，我们注册了 cors、body-parser 和 cookie-parser 中间件，这样我们就可以在应用程序中使用这些中间件了。\n然后，我们将应用程序添加到 Vite 开发服务器的中间件中，这样就可以使用自定义的 express 应用程序来处理 HTTP 请求了。\n最后，我们向应用程序中添加了一个处理 /login URL 路径的路由处理函数，用于执行登录逻辑。\n配置 Vite 使用 configureServer 来配置 Vite 开发服务器也很简单。我们只需要将插件导入应用程序，然后将其添加到 Vite 配置的 plugins 队列中，就可以完整地拦截 Vite 开发服务器了。\nimport myPlugin from \u0026#39;./myPlugin\u0026#39; export default defineConfig({ // ...  plugins: [ myPlugin() ] }) 结论 通过使用 configureServer 方法，我们可以轻松地拦截 Vite 开发服务器，并使用 express HTTP 服务器来替换它。\n这种方式可以让我们在 Vite 开发服务器中使用更加灵活的 HTTP 服务器组合，并且可以方便地实现登录、鉴权等功能。\n","permalink":"https://tangxiaomi.top/posts/vite/express/","summary":"Vite 是一个快速、轻量级、易于使用的前端工具。它为开发者提供了一种现代的构建方式，可以快速地构建出高效且易于维护的 Web 应用程序。\n在 Vite 版本 4.2 及以上的版本中，我们可以使用 configureServer 方法来拦截 Vite 开发服务器，并将其替换为 express HTTP 服务器。这样，我们就可以使用更加灵活的 HTTP 服务器组合，并且可以方便地实现登录、鉴权等功能。\n配置 Vite 插件 为了使用自定义的 express 应用程序，我们需要编写一个 Vite 插件\n我们可以通过 myPlugin 函数来创建一个新插件。这个插件暴露了一个 configureServer 方法，我们可以在这个方法中创建并配置一个 express 应用程序。\nimport express from \u0026#39;express\u0026#39; import cors from \u0026#39;cors\u0026#39; import bodyParser from \u0026#39;body-parser\u0026#39; import cookieParser from \u0026#39;cookie-parser\u0026#39; export default function myPlugin () { return { name: \u0026#39;my-plugin\u0026#39;, configureServer (server) { const app = express() app.use(cors({ credentials: true, origin: true })) app.","title":"如何在 Vite 中拦截开发服务器并使用 express"}]
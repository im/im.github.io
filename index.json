[{"content":"navigator.registerProtocolHandler 是一个 Web API，用于注册自定义协议处理程序。通过使用这个 API，您可以告诉浏览器如何处理特定的自定义协议，例如打开特定的应用程序或执行特定的操作。这对于创建与操作系统或其他应用程序集成的 Web 应用程序非常有用。\n如何使用 navigator.registerProtocolHandler 🛠️ 使用 navigator.registerProtocolHandler 需要以下步骤：\n  确定自定义协议：首先，您需要确定您要注册的自定义协议。这个协议应该是唯一的，并且与其他现有的协议不冲突。例如，您可以选择 myapp 作为您的自定义协议。\n  创建处理程序：接下来，您需要创建一个处理程序，用于处理您的自定义协议。这可以是一个本地应用程序、一个网页或一个特定的操作。处理程序应该能够接收来自浏览器的自定义协议请求，并做出相应的响应。\n  注册协议处理程序：使用 navigator.registerProtocolHandler 方法来注册您的自定义协议处理程序。该方法接受三个参数：协议名称、处理程序的 URL 和一个可选的标题。以下是一个示例：\nnavigator.registerProtocolHandler(\u0026#39;myapp\u0026#39;, \u0026#39;https://example.com/myapp-handler?url=%s\u0026#39;, \u0026#39;My App\u0026#39;); 在上面的示例中，myapp 是自定义协议的名称，https://example.com/myapp-handler?url=%s 是处理程序的 URL，My App 是可选的标题。\n  测试协议处理程序：注册完成后，您可以测试您的协议处理程序是否正常工作。您可以尝试在浏览器中输入 myapp://example.com（将 example.com 替换为您的实际网址），并查看处理程序是否正确地响应。\n  示例应用场景 💡   桌面应用程序集成：您可以使用 navigator.registerProtocolHandler 将您的 Web 应用程序与桌面应用程序集成。例如，当用户点击您的网页中的特定链接时，您可以打开您的桌面应用程序并传递相应的参数。\n  自定义处理程序：您可以创建一个自定义的处理程序，用于处理特定的自定义协议。例如，您可以创建一个处理程序，用于处理邮件链接，并直接打开用户默认的邮件客户端。\n  支持的浏览器 🌐 目前，navigator.registerProtocolHandler 在大多数现代浏览器中得到支持，包括 Chrome、Firefox 和 Safari 等。但是，不同浏览器对于自定义协议的支持程度可能有所不同，因此在使用时请注意兼容性。\n结论 📝 navigator.registerProtocolHandler 是一个强大的 Web API，可以帮助您注册自定义协议处理程序，实现与操作系统或其他应用程序的集成。通过使用这个 API，您可以为您的 Web 应用程序带来更多的灵活性和功能性。在使用时，请确保考虑兼容性，并进行充分的测试，以确保您的协议处理程序正常工作。\n希望本文对您理解和使用 navigator.registerProtocolHandler 有所帮助！✨\n","permalink":"https://tangxiaomi.top/posts/other/navigator-registerprotocolhandler/","summary":"navigator.registerProtocolHandler 是一个 Web API，用于注册自定义协议处理程序。通过使用这个 API，您可以告诉浏览器如何处理特定的自定义协议，例如打开特定的应用程序或执行特定的操作。这对于创建与操作系统或其他应用程序集成的 Web 应用程序非常有用。\n如何使用 navigator.registerProtocolHandler 🛠️ 使用 navigator.registerProtocolHandler 需要以下步骤：\n  确定自定义协议：首先，您需要确定您要注册的自定义协议。这个协议应该是唯一的，并且与其他现有的协议不冲突。例如，您可以选择 myapp 作为您的自定义协议。\n  创建处理程序：接下来，您需要创建一个处理程序，用于处理您的自定义协议。这可以是一个本地应用程序、一个网页或一个特定的操作。处理程序应该能够接收来自浏览器的自定义协议请求，并做出相应的响应。\n  注册协议处理程序：使用 navigator.registerProtocolHandler 方法来注册您的自定义协议处理程序。该方法接受三个参数：协议名称、处理程序的 URL 和一个可选的标题。以下是一个示例：\nnavigator.registerProtocolHandler(\u0026#39;myapp\u0026#39;, \u0026#39;https://example.com/myapp-handler?url=%s\u0026#39;, \u0026#39;My App\u0026#39;); 在上面的示例中，myapp 是自定义协议的名称，https://example.com/myapp-handler?url=%s 是处理程序的 URL，My App 是可选的标题。\n  测试协议处理程序：注册完成后，您可以测试您的协议处理程序是否正常工作。您可以尝试在浏览器中输入 myapp://example.com（将 example.com 替换为您的实际网址），并查看处理程序是否正确地响应。\n  示例应用场景 💡   桌面应用程序集成：您可以使用 navigator.registerProtocolHandler 将您的 Web 应用程序与桌面应用程序集成。例如，当用户点击您的网页中的特定链接时，您可以打开您的桌面应用程序并传递相应的参数。\n  自定义处理程序：您可以创建一个自定义的处理程序，用于处理特定的自定义协议。例如，您可以创建一个处理程序，用于处理邮件链接，并直接打开用户默认的邮件客户端。\n  支持的浏览器 🌐 目前，navigator.registerProtocolHandler 在大多数现代浏览器中得到支持，包括 Chrome、Firefox 和 Safari 等。但是，不同浏览器对于自定义协议的支持程度可能有所不同，因此在使用时请注意兼容性。\n结论 📝 navigator.","title":"navigator.registerProtocolHandler"},{"content":"在移动应用程序中，URL Scheme是一种用于在应用程序之间进行通信的机制。它允许一个应用程序通过特定的URL来打开另一个应用程序，并在打开后执行一些特定的操作。\nURL Scheme的结构 一个URL Scheme是一个以特定格式构建的URL。它通常由两部分组成：Scheme和Path。\n Scheme：Scheme是URL的开头部分，用于指定要打开的应用程序。它以字母开头，后面跟随着字母、数字和一些特殊字符，例如myapp://。 Path：Path是Scheme之后的部分，用于指定在目标应用程序中要执行的具体操作。它可以是一个命令、参数或其他标识符，例如open?item=123。  URL Scheme的用途 URL Scheme可以用于多种用途，包括但不限于以下几个方面：\n 打开应用程序：通过URL Scheme，可以从一个应用程序打开另一个应用程序。例如，可以通过点击一个URL链接或在其他应用程序中点击一个按钮来打开目标应用程序。 传递参数：URL Scheme可以传递一些参数给目标应用程序，以便应用程序知道要执行的操作或显示的内容。例如，可以通过URL Scheme传递一个商品ID，以便在目标应用程序中显示该商品的详细信息。 执行特定操作：URL Scheme还可以用于执行一些特定的操作，例如发送电子邮件、拨打电话、分享内容等。通过在URL中指定特定的命令，目标应用程序可以根据命令执行相应的操作。  如何使用URL Scheme 要在应用程序中使用URL Scheme，通常需要完成以下几个步骤：\n 注册URL Scheme：目标应用程序需要在其配置文件或代码中注册自己的URL Scheme。这样，其他应用程序才能通过URL打开它。 构建URL：在发送URL请求时，需要构建一个合法的URL，包括Scheme和Path等必要的信息。 处理URL请求：目标应用程序需要处理接收到的URL请求，并根据URL中的信息执行相应的操作。  示例 以下是一个示例URL Scheme的URL：\nmyapp://open?item=123 这个URL使用了名为myapp的Scheme，并传递了一个名为item的参数，值为123。目标应用程序可以解析这个URL，执行打开操作，并显示ID为123的商品详细信息。\n","permalink":"https://tangxiaomi.top/posts/other/url-scheme/","summary":"在移动应用程序中，URL Scheme是一种用于在应用程序之间进行通信的机制。它允许一个应用程序通过特定的URL来打开另一个应用程序，并在打开后执行一些特定的操作。\nURL Scheme的结构 一个URL Scheme是一个以特定格式构建的URL。它通常由两部分组成：Scheme和Path。\n Scheme：Scheme是URL的开头部分，用于指定要打开的应用程序。它以字母开头，后面跟随着字母、数字和一些特殊字符，例如myapp://。 Path：Path是Scheme之后的部分，用于指定在目标应用程序中要执行的具体操作。它可以是一个命令、参数或其他标识符，例如open?item=123。  URL Scheme的用途 URL Scheme可以用于多种用途，包括但不限于以下几个方面：\n 打开应用程序：通过URL Scheme，可以从一个应用程序打开另一个应用程序。例如，可以通过点击一个URL链接或在其他应用程序中点击一个按钮来打开目标应用程序。 传递参数：URL Scheme可以传递一些参数给目标应用程序，以便应用程序知道要执行的操作或显示的内容。例如，可以通过URL Scheme传递一个商品ID，以便在目标应用程序中显示该商品的详细信息。 执行特定操作：URL Scheme还可以用于执行一些特定的操作，例如发送电子邮件、拨打电话、分享内容等。通过在URL中指定特定的命令，目标应用程序可以根据命令执行相应的操作。  如何使用URL Scheme 要在应用程序中使用URL Scheme，通常需要完成以下几个步骤：\n 注册URL Scheme：目标应用程序需要在其配置文件或代码中注册自己的URL Scheme。这样，其他应用程序才能通过URL打开它。 构建URL：在发送URL请求时，需要构建一个合法的URL，包括Scheme和Path等必要的信息。 处理URL请求：目标应用程序需要处理接收到的URL请求，并根据URL中的信息执行相应的操作。  示例 以下是一个示例URL Scheme的URL：\nmyapp://open?item=123 这个URL使用了名为myapp的Scheme，并传递了一个名为item的参数，值为123。目标应用程序可以解析这个URL，执行打开操作，并显示ID为123的商品详细信息。","title":"URL Scheme（URL协议）"},{"content":"添加 git submodule add -b [指定分支] [仓库地址] [路径] example: git submodule add -b icarus https://github.com/im/hexo-theme.git themes/icarus 命令执行完成，会在当前工程根路径下生成一个名为 .gitmodules 的文件，其中记录了子模块的信息。\n.gitmodules [submodule \u0026#34;themes/icarus\u0026#34;] path = themes/icarus url = https://github.com/im/hexo-theme.git branch = icarus 更新 git submodule update 删除 submodule 的删除稍微麻烦点：首先，要在 .gitmodules 文件中删除相应配置信息。然后，执行 git rm –cached 命令将子模块所在的文件从 git 中删除。\n下载的工程带有 submodule git submodule update --init --recursive 查看 sumodule 状态 git submodule foreach git status 不能更新 git submodule update --remote ","permalink":"https://tangxiaomi.top/posts/git/submodule/","summary":"添加 git submodule add -b [指定分支] [仓库地址] [路径] example: git submodule add -b icarus https://github.com/im/hexo-theme.git themes/icarus 命令执行完成，会在当前工程根路径下生成一个名为 .gitmodules 的文件，其中记录了子模块的信息。\n.gitmodules [submodule \u0026#34;themes/icarus\u0026#34;] path = themes/icarus url = https://github.com/im/hexo-theme.git branch = icarus 更新 git submodule update 删除 submodule 的删除稍微麻烦点：首先，要在 .gitmodules 文件中删除相应配置信息。然后，执行 git rm –cached 命令将子模块所在的文件从 git 中删除。\n下载的工程带有 submodule git submodule update --init --recursive 查看 sumodule 状态 git submodule foreach git status 不能更新 git submodule update --remote ","title":"git submodule"},{"content":"创建 SSH Key ssh-keygen -t rsa -C \u0026#34;tangxiaomiemail@gmail.com\u0026#34; cd ~/.ssh cat id_rsa.pub 如果一切顺利的话，可以在用户主目录里找到 .ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人.\n全局配置 git config --global user.name \u0026#34;tangxiaomi\u0026#34; git config --global user.email \u0026#34;tangxiaomiemail@gmail.com\u0026#34; 非全局配置 删除 --global git config user.name \u0026#34;tangxiaomi\u0026#34; git config user.email \u0026#34;tangxiaomiemail@gmail.com\u0026#34; 查看配置 git config --global user.name git config --global user.email 取消全局配置 git config --global --unset user.name git config --global --unset user.email git config --global user.name #(查看)全局配置账户是否已经移除 git config --global user.email #(查看)全局配置邮箱是否已经移除 ","permalink":"https://tangxiaomi.top/posts/git/ssh-key/","summary":"创建 SSH Key ssh-keygen -t rsa -C \u0026#34;tangxiaomiemail@gmail.com\u0026#34; cd ~/.ssh cat id_rsa.pub 如果一切顺利的话，可以在用户主目录里找到 .ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人.\n全局配置 git config --global user.name \u0026#34;tangxiaomi\u0026#34; git config --global user.email \u0026#34;tangxiaomiemail@gmail.com\u0026#34; 非全局配置 删除 --global git config user.name \u0026#34;tangxiaomi\u0026#34; git config user.email \u0026#34;tangxiaomiemail@gmail.com\u0026#34; 查看配置 git config --global user.name git config --global user.email 取消全局配置 git config --global --unset user.name git config --global --unset user.email git config --global user.name #(查看)全局配置账户是否已经移除 git config --global user.","title":"git 添加 ssh key"},{"content":"介绍 📝 Vue 3是一种流行的JavaScript框架，它提供了一种声明式的方式来构建用户界面。在Vue 3中，我们可以使用ref函数来创建响应式数据。然而，当我们尝试对ref解构进行操作时，可能会遇到一些响应式问题。本文将探讨Vue 3中ref解构的使用、为什么会丢失响应式以及如何解决相关的问题。\nref解构的使用 🧩 在Vue 3中，我们可以使用ref函数创建一个响应式的数据对象。下面是一个简单的例子：\nimport { ref } from \u0026#39;vue\u0026#39;; const count = ref(0); console.log(count.value); // 输出：0  count.value++; // 修改数据  console.log(count.value); // 输出：1 在上面的例子中，我们使用ref函数创建了一个名为count的响应式数据对象。通过访问count.value属性，我们可以获取和修改数据的值。\n然而，当我们尝试对ref解构进行操作时，可能会遇到一些问题。\nref解构的响应式问题 🚫 当我们对ref解构进行操作时，Vue 3无法正确地跟踪和更新数据的变化。下面是一个例子：\nimport { ref } from \u0026#39;vue\u0026#39;; const count = ref(0); const { value } = count; console.log(value); // 输出：0  count.value++; // 修改数据  console.log(value); // 输出：0（未更新） 在上面的例子中，我们通过解构将count的值赋给value变量。然而，当我们修改count的值时，value并没有更新。\n这是因为解构操作会将count.value的值复制给value，而不是创建一个引用。因此，value不再是一个响应式的数据对象，它无法与count保持同步。\n为什么会丢失响应式？ 🤔 当我们对ref解构进行操作时，原因是解构操作会将响应式对象的引用丢失。Vue 3的响应式系统是基于Proxy实现的，它会拦截对响应式对象的访问和修改。然而，当我们对解构后的变量进行操作时，Vue 3无法捕获到这些操作，因此无法正确地跟踪和更新数据的变化。\n解决方案 🛠️ 要解决ref解构的响应式问题，我们可以使用Vue 3提供的toRef函数。toRef函数可以将一个响应式对象的属性转换为一个单独的响应式引用。\n下面是一个使用toRef函数的示例：\nimport { ref, toRef } from \u0026#39;vue\u0026#39;; const count = ref(0); const value = toRef(count, \u0026#39;value\u0026#39;); console.log(value.value); // 输出：0  count.value++; // 修改数据  console.log(value.value); // 输出：1（已更新） 在上面的例子中，我们使用toRef函数将count.value转换为一个新的响应式引用value。通过访问value.value属性，我们可以获取和修改数据的值。\n使用toRef函数后，value将与count保持同步，可以正确地跟踪和更新数据的变化。\n","permalink":"https://tangxiaomi.top/posts/vue/vue3-responsive-lose/","summary":"介绍 📝 Vue 3是一种流行的JavaScript框架，它提供了一种声明式的方式来构建用户界面。在Vue 3中，我们可以使用ref函数来创建响应式数据。然而，当我们尝试对ref解构进行操作时，可能会遇到一些响应式问题。本文将探讨Vue 3中ref解构的使用、为什么会丢失响应式以及如何解决相关的问题。\nref解构的使用 🧩 在Vue 3中，我们可以使用ref函数创建一个响应式的数据对象。下面是一个简单的例子：\nimport { ref } from \u0026#39;vue\u0026#39;; const count = ref(0); console.log(count.value); // 输出：0  count.value++; // 修改数据  console.log(count.value); // 输出：1 在上面的例子中，我们使用ref函数创建了一个名为count的响应式数据对象。通过访问count.value属性，我们可以获取和修改数据的值。\n然而，当我们尝试对ref解构进行操作时，可能会遇到一些问题。\nref解构的响应式问题 🚫 当我们对ref解构进行操作时，Vue 3无法正确地跟踪和更新数据的变化。下面是一个例子：\nimport { ref } from \u0026#39;vue\u0026#39;; const count = ref(0); const { value } = count; console.log(value); // 输出：0  count.value++; // 修改数据  console.log(value); // 输出：0（未更新） 在上面的例子中，我们通过解构将count的值赋给value变量。然而，当我们修改count的值时，value并没有更新。\n这是因为解构操作会将count.value的值复制给value，而不是创建一个引用。因此，value不再是一个响应式的数据对象，它无法与count保持同步。\n为什么会丢失响应式？ 🤔 当我们对ref解构进行操作时，原因是解构操作会将响应式对象的引用丢失。Vue 3的响应式系统是基于Proxy实现的，它会拦截对响应式对象的访问和修改。然而，当我们对解构后的变量进行操作时，Vue 3无法捕获到这些操作，因此无法正确地跟踪和更新数据的变化。","title":"Vue3中的ref解构与响应式问题"},{"content":"什么是泛型？ 泛型是一种在编程语言中用于创建可重用代码的工具。它允许我们在定义函数、类或接口时延迟指定具体类型，而是在使用时动态地传入类型参数。\n泛型函数 📝 在TypeScript中，我们可以使用泛型来创建可接受不同类型参数的函数。下面是一个简单的例子：\nfunction identity\u0026lt;T\u0026gt;(arg: T): T { return arg; } let result = identity\u0026lt;string\u0026gt;(\u0026#34;Hello, TypeScript! 🚀\u0026#34;); console.log(result); // 输出：Hello, TypeScript! 🚀 在上面的例子中，我们定义了一个identity函数，它接受一个参数arg并返回该参数。使用\u0026lt;T\u0026gt;语法来指定泛型类型，并在函数体中使用该类型。\n在调用函数时，我们可以明确指定泛型类型，也可以让TypeScript根据传入的参数自动推断出类型。\n常见场景： 泛型函数常用于处理各种类型的输入，并返回相同类型的输出。例如，数组的map和filter方法就是使用泛型函数来实现的。\n泛型类 🏢 除了函数，我们还可以创建泛型类。泛型类允许我们在类的定义中使用泛型类型。下面是一个示例：\nclass Container\u0026lt;T\u0026gt; { private value: T; constructor(value: T) { this.value = value; } getValue(): T { return this.value; } } let container = new Container\u0026lt;number\u0026gt;(42); console.log(container.getValue()); // 输出：42 在上面的例子中，我们定义了一个Container类，它接受一个泛型类型参数T，并在构造函数中接受一个参数value。通过泛型类型，我们可以在类中使用该类型，并在实例化时传入具体类型。\n常见场景： 泛型类常用于创建可重用的数据结构，例如栈、队列等。通过使用泛型类，我们可以在编写通用的数据结构时，不限制特定的数据类型。\n泛型约束 🚧 有时候，我们希望对泛型进行一些限制，以确保只能传入特定类型。这时可以使用泛型约束。下面是一个示例：\ninterface Lengthwise { length: number; } function loggingIdentity\u0026lt;T extends Lengthwise\u0026gt;(arg: T): T { console.log(\u0026#34;Length of arg: \u0026#34; + arg.length); return arg; } let result = loggingIdentity(\u0026#34;Hello 👋\u0026#34;); console.log(result); // 输出：Hello 👋 在上面的例子中，我们定义了一个Lengthwise接口，它包含一个length属性。然后我们定义了一个loggingIdentity函数，它接受一个泛型参数T，并使用extends关键字对泛型进行约束，要求T必须实现Lengthwise接口。这样我们就可以在函数体中访问arg的length属性。\n常见场景： 泛型约束常用于对泛型类型进行更精确的类型限制，以确保传入的参数具有特定的属性或方法。\n泛型与工具类型的结合 🛠️ TypeScript提供了一些内置的工具类型（Utility Types），可以与泛型一起使用，以进一步增强泛型的能力。\n常见工具类型：\n Partial\u0026lt;T\u0026gt;：将类型T的所有属性设为可选。 Readonly\u0026lt;T\u0026gt;：将类型T的所有属性设为只读。 Pick\u0026lt;T, K\u0026gt;：从类型T中选择指定的属性K。 Omit\u0026lt;T, K\u0026gt;：从类型T中排除指定的属性K。 Record\u0026lt;K, T\u0026gt;：创建一个具有指定类型T的属性K的对象。 Exclude\u0026lt;T, U\u0026gt;：从类型T中排除可以赋值给类型U的类型。 Extract\u0026lt;T, U\u0026gt;：从类型T中提取可以赋值给类型U的类型。 NonNullable\u0026lt;T\u0026gt;：从类型T中排除null和undefined。  这些工具类型可以与泛型一起使用，以便更灵活地处理类型。\n常见场景： 泛型与工具类型的结合常用于处理复杂的类型转换、属性选择和排除等操作。\n","permalink":"https://tangxiaomi.top/posts/typescript/generic/","summary":"什么是泛型？ 泛型是一种在编程语言中用于创建可重用代码的工具。它允许我们在定义函数、类或接口时延迟指定具体类型，而是在使用时动态地传入类型参数。\n泛型函数 📝 在TypeScript中，我们可以使用泛型来创建可接受不同类型参数的函数。下面是一个简单的例子：\nfunction identity\u0026lt;T\u0026gt;(arg: T): T { return arg; } let result = identity\u0026lt;string\u0026gt;(\u0026#34;Hello, TypeScript! 🚀\u0026#34;); console.log(result); // 输出：Hello, TypeScript! 🚀 在上面的例子中，我们定义了一个identity函数，它接受一个参数arg并返回该参数。使用\u0026lt;T\u0026gt;语法来指定泛型类型，并在函数体中使用该类型。\n在调用函数时，我们可以明确指定泛型类型，也可以让TypeScript根据传入的参数自动推断出类型。\n常见场景： 泛型函数常用于处理各种类型的输入，并返回相同类型的输出。例如，数组的map和filter方法就是使用泛型函数来实现的。\n泛型类 🏢 除了函数，我们还可以创建泛型类。泛型类允许我们在类的定义中使用泛型类型。下面是一个示例：\nclass Container\u0026lt;T\u0026gt; { private value: T; constructor(value: T) { this.value = value; } getValue(): T { return this.value; } } let container = new Container\u0026lt;number\u0026gt;(42); console.log(container.getValue()); // 输出：42 在上面的例子中，我们定义了一个Container类，它接受一个泛型类型参数T，并在构造函数中接受一个参数value。通过泛型类型，我们可以在类中使用该类型，并在实例化时传入具体类型。\n常见场景： 泛型类常用于创建可重用的数据结构，例如栈、队列等。通过使用泛型类，我们可以在编写通用的数据结构时，不限制特定的数据类型。\n泛型约束 🚧 有时候，我们希望对泛型进行一些限制，以确保只能传入特定类型。这时可以使用泛型约束。下面是一个示例：\ninterface Lengthwise { length: number; } function loggingIdentity\u0026lt;T extends Lengthwise\u0026gt;(arg: T): T { console.","title":"TypeScript泛型"},{"content":"HSTS (HTTP Strict Transport Security) 是一种安全策略，用于强制浏览器使用 HTTPS 进行安全连接，防止恶意攻击者使用中间人攻击 (Man-in-the-middle攻击) 窃取用户数据。\n🛡️ HSTS 的工作原理 HSTS 通过在 HTTPS 响应头中添加 Strict-Transport-Security 参数来实现。当用户第一次访问一个网站时，服务器返回的响应头中包含了 Strict-Transport-Security 参数，浏览器会记住该网站的 HSTS 头，之后再次访问该网站时，浏览器就会自动强制使用 HTTPS 进行连接，而不再允许使用 HTTP 协议进行访问。\n🔑 HSTS 的作用 使用 HSTS 可以提供以下的安全保障：\n 防止中间人攻击：通过强制使用 HTTPS，HSTS 可以防止攻击者在用户和服务器之间插入恶意的中间人攻击，在传输过程中窃取用户的敏感信息。 安全可靠：HSTS 可以确保通过 HTTPS 连接的安全性和效率，从而更好地保护用户的隐私和安全。 提高搜索引擎排名：使用 HTTPS 进行加密的网站可以获得更高的搜索引擎排名，并提高用户的信任度和转化率。 提高网站性能：使用 HTTPS 加密通信可以降低网络拥塞和提高网站的性能。  ⚙️ 如何设置 HSTS 要在网站中启用 HSTS，您需要在 HTTPS 响应头中添加一个 HSTS headers。您可以在 Web 服务器或应用程序中实现此功能，以下是一些具体步骤：\nApache 服务器 在 Apache 中，您可以通过编辑您的网站的 .htaccess 文件或 Apache 配置文件来添加 HSTS headers。编辑您的 .htaccess 文件，添加以下内容：\nHeader set Strict-Transport-Security \u0026#34;max-age=63072000; includeSubDomains; preload\u0026#34; 或者您可以编辑上面配置文件中的 VirtualHost 来全局设置 HSTS headers ，在 VirtualHost 中添加以下配置：\n\u0026lt;VirtualHost *:80\u0026gt; ServerName www.example.com Redirect permanent / https://www.example.com/ Header set Strict-Transport-Security \u0026#34;max-age=63072000; includeSubDomains; preload\u0026#34; \u0026lt;/VirtualHost\u0026gt; 这将把所有请求重定向到 HTTPS 并将 HSTS headers 添加到响应头中。\nNginx 服务器 在 Nginx 中，编辑 Nginx 配置文件中与您的网站相关的配置。使用 add_header 命令添加 HSTS headers：\nserver { listen 80; server_name www.example.com; return 301 https://$server_name$request_uri; } server { listen 443 ssl http2; server_name www.example.com; add_header Strict-Transport-Security \u0026#34;max-age=63072000; includeSubDomains; preload;\u0026#34;; # other ssl settings } IIS 服务器 在 IIS 中，您可以通过编辑您的网站的 web.config 文件来添加 HSTS headers。编辑 web.config 文件，添加以下内容：\n\u0026lt;system.webServer\u0026gt; \u0026lt;httpProtocol\u0026gt; \u0026lt;customHeaders\u0026gt; \u0026lt;add name=\u0026#34;Strict-Transport-Security\u0026#34; value=\u0026#34;max-age=63072000; includeSubDomains; preload\u0026#34; /\u0026gt; \u0026lt;/customHeaders\u0026gt; \u0026lt;/httpProtocol\u0026gt; \u0026lt;/system.webServer\u0026gt; 添加 HSTS headers 之后，访问您的网站时，浏览器将会自动强制使用 HTTPS 进行连接，并且有效期 max-age 将在访问期间被记住，直到过期或 HSTS headers 被删除。\n在实现 HSTS 的时候，最好先使用小的 max-age 值进行测试，以确保一切正常工作，之后再设定长期的值。另外，请注意不要在生产环境之前添加 HSTS 的预加载指令 preload。该指令会将网站加入到浏览器的 HSTS 预加载列表中，必须遵守极其严格的要求和审核才能添加，预加载一旦结束就无法回退。\n🚨 HSTS 的注意事项  HSTS 只能保证浏览器和网站之间的通信是安全的，但无法防止其他形式的攻击。 如果网站使用了 HSTS，在浏览器上访问该网站时，会自动强制使用 HTTPS，请确保网站已正确配置 SSL 证书，否则用户无法访问该网站。 HSTS 不适用于不支持 HTTPS 加密通信的浏览器或旧版浏览器。  💡 总结 HSTS 是一种用于强制浏览器使用 HTTPS 进行安全连接的安全策略，它可以有效地保护用户的隐私和安全，并提高网站的搜索引擎排名和性能。使用 HSTS 需要注意一些细节问题，但只要正确地实现和配置，可以轻松地提供更可靠和安全的服务。\n","permalink":"https://tangxiaomi.top/posts/http/hsts/","summary":"HSTS (HTTP Strict Transport Security) 是一种安全策略，用于强制浏览器使用 HTTPS 进行安全连接，防止恶意攻击者使用中间人攻击 (Man-in-the-middle攻击) 窃取用户数据。\n🛡️ HSTS 的工作原理 HSTS 通过在 HTTPS 响应头中添加 Strict-Transport-Security 参数来实现。当用户第一次访问一个网站时，服务器返回的响应头中包含了 Strict-Transport-Security 参数，浏览器会记住该网站的 HSTS 头，之后再次访问该网站时，浏览器就会自动强制使用 HTTPS 进行连接，而不再允许使用 HTTP 协议进行访问。\n🔑 HSTS 的作用 使用 HSTS 可以提供以下的安全保障：\n 防止中间人攻击：通过强制使用 HTTPS，HSTS 可以防止攻击者在用户和服务器之间插入恶意的中间人攻击，在传输过程中窃取用户的敏感信息。 安全可靠：HSTS 可以确保通过 HTTPS 连接的安全性和效率，从而更好地保护用户的隐私和安全。 提高搜索引擎排名：使用 HTTPS 进行加密的网站可以获得更高的搜索引擎排名，并提高用户的信任度和转化率。 提高网站性能：使用 HTTPS 加密通信可以降低网络拥塞和提高网站的性能。  ⚙️ 如何设置 HSTS 要在网站中启用 HSTS，您需要在 HTTPS 响应头中添加一个 HSTS headers。您可以在 Web 服务器或应用程序中实现此功能，以下是一些具体步骤：\nApache 服务器 在 Apache 中，您可以通过编辑您的网站的 .htaccess 文件或 Apache 配置文件来添加 HSTS headers。编辑您的 .","title":"HSTS 强制 https"},{"content":"https://picsum.photos/\n输入图片大小 Picsum默认的图片大小为1080*720。如果你要生成其他尺寸的图片，只需在网址后面添加图片尺寸即可。比如：\n https://picsum.photos/200/300 https://picsum.photos/300/300 https://picsum.photos/500/500  添加图片样式  https://picsum.photos/200/300/?grayscale：生成灰度图片。  https://picsum.photos/200/300/?blur=2：使图片模糊，数字值越高表示图片越模糊。 https://picsum.photos/200/300/?random：生成随机的背景色。 https://picsum.photos/200/300/?blur=2\u0026amp;grayscale：图片模糊且灰度化。 https://picsum.photos/200/300/?gravity=center：将图片放置在中心位置。 https://picsum.photos/id/237/200/300.jpg：生成具有特定id的图片，比如237。 https://picsum.photos/200/300?cache-control：让浏览器通过Cache-Control头缓存响应。  ","permalink":"https://tangxiaomi.top/posts/other/picsum/","summary":"https://picsum.photos/\n输入图片大小 Picsum默认的图片大小为1080*720。如果你要生成其他尺寸的图片，只需在网址后面添加图片尺寸即可。比如：\n https://picsum.photos/200/300 https://picsum.photos/300/300 https://picsum.photos/500/500  添加图片样式  https://picsum.photos/200/300/?grayscale：生成灰度图片。  https://picsum.photos/200/300/?blur=2：使图片模糊，数字值越高表示图片越模糊。 https://picsum.photos/200/300/?random：生成随机的背景色。 https://picsum.photos/200/300/?blur=2\u0026amp;grayscale：图片模糊且灰度化。 https://picsum.photos/200/300/?gravity=center：将图片放置在中心位置。 https://picsum.photos/id/237/200/300.jpg：生成具有特定id的图片，比如237。 https://picsum.photos/200/300?cache-control：让浏览器通过Cache-Control头缓存响应。  ","title":"Picsum 图片链接"},{"content":"随机图片链接 如果你需要一张随机的图片来让内容更加生动、有趣，只需要在 Unsplash 的基础图片链接后面加上“/random/”即可。例如以下链接将返回一个宽度为 640 像素、高度为 480 像素的随机图片：\nhttps://source.unsplash.com/random/640x480 如果需要过滤主题，只需在链接末尾加上标签即可，例如以下链接将会返回一个范围包括 mountain 和 landscape 的随机图片：\nhttps://source.unsplash.com/random/640x480?landscape,mountain 固定图片链接 如果你需要一张特定的图片，只需使用 Unsplash 图片的 ID，拼接图片链接即可。例如以下链接将会返回 ID 为 \u0026ldquo;hgytITrCiec\u0026rdquo; 的 Unsplash 图片，并且将图片宽度设置为 640 像素，高度设置为 480 像素：\nhttps://source.unsplash.com/hgytITrCiec/640x480 在 Markdown 中使用 Unsplash 图片链接 在 Markdown 编辑器中，你可以使用以下语法插入 Unsplash 图片链接：\n![图片描述](图片链接) 例如，在你的文章中插入一张宽度为 640 像素、高度为 480 像素的随机图片，可以使用以下代码：\n![随机图片](https://source.unsplash.com/random/640x480) 如果你想要插入一张特定的图片，可以使用 ID 和固定图片链接：\n![特定图片](https://source.unsplash.com/hgytITrCiec/640x480) 以上就是如何使用 Unsplash 图片链接的简单介绍。希望这篇文章对你有帮助！\n","permalink":"https://tangxiaomi.top/posts/other/unsplash/","summary":"随机图片链接 如果你需要一张随机的图片来让内容更加生动、有趣，只需要在 Unsplash 的基础图片链接后面加上“/random/”即可。例如以下链接将返回一个宽度为 640 像素、高度为 480 像素的随机图片：\nhttps://source.unsplash.com/random/640x480 如果需要过滤主题，只需在链接末尾加上标签即可，例如以下链接将会返回一个范围包括 mountain 和 landscape 的随机图片：\nhttps://source.unsplash.com/random/640x480?landscape,mountain 固定图片链接 如果你需要一张特定的图片，只需使用 Unsplash 图片的 ID，拼接图片链接即可。例如以下链接将会返回 ID 为 \u0026ldquo;hgytITrCiec\u0026rdquo; 的 Unsplash 图片，并且将图片宽度设置为 640 像素，高度设置为 480 像素：\nhttps://source.unsplash.com/hgytITrCiec/640x480 在 Markdown 中使用 Unsplash 图片链接 在 Markdown 编辑器中，你可以使用以下语法插入 Unsplash 图片链接：\n![图片描述](图片链接) 例如，在你的文章中插入一张宽度为 640 像素、高度为 480 像素的随机图片，可以使用以下代码：\n![随机图片](https://source.unsplash.com/random/640x480) 如果你想要插入一张特定的图片，可以使用 ID 和固定图片链接：\n![特定图片](https://source.unsplash.com/hgytITrCiec/640x480) 以上就是如何使用 Unsplash 图片链接的简单介绍。希望这篇文章对你有帮助！","title":"Unsplash 图片链接"},{"content":" 安装 Husky  使用 npm 进行安装：\nnpm install husky --save-dev 配置 Git 钩子  在 package.json 文件中添加 \u0026ldquo;husky\u0026rdquo; 配置：\n\u0026#34;husky\u0026#34;: { \u0026#34;hooks\u0026#34;: { \u0026#34;pre-commit\u0026#34;: \u0026#34;npm run lint\u0026#34;, // 在执行 git commit 命令时，会执行 npm run lint 命令  \u0026#34;pre-push\u0026#34;: \u0026#34;npm run test\u0026#34; // 在执行 git push 命令时，会执行 npm run test 命令  } } 配置 pre-commit 钩子  在 package.json 文件中添加 \u0026ldquo;scripts\u0026rdquo; 属性：\n\u0026#34;scripts\u0026#34;: { \u0026#34;lint\u0026#34;: \u0026#34;eslint .\u0026#34; } 这里的 \u0026ldquo;lint\u0026rdquo; 命令使用 ESlint 对整个项目进行代码风格检查。\n配置 pre-push 钩子  在 package.json 文件中添加另一个 \u0026ldquo;scripts\u0026rdquo; 属性：\n\u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;jest\u0026#34; } 这里的 \u0026ldquo;test\u0026rdquo; 命令使用 Jest 对整个项目进行测试。\n完成  现在，当您在项目中运行 git commit 或 git push 命令时，Husky 将自动执行 lint 和 test 命令。如果命令返回任何错误，Husky 将阻止您的提交或推送。\n您可以使用 Husky 的其他功能来执行其他任务，例如在 commit 或 push 之前自动发布代码，或在代码风格测试失败时发送电子邮件等。\n更多详细的配置信息请查看 Husky 的官方文档: https://github.com/typicode/husky\n","permalink":"https://tangxiaomi.top/posts/git/husky/","summary":"安装 Husky  使用 npm 进行安装：\nnpm install husky --save-dev 配置 Git 钩子  在 package.json 文件中添加 \u0026ldquo;husky\u0026rdquo; 配置：\n\u0026#34;husky\u0026#34;: { \u0026#34;hooks\u0026#34;: { \u0026#34;pre-commit\u0026#34;: \u0026#34;npm run lint\u0026#34;, // 在执行 git commit 命令时，会执行 npm run lint 命令  \u0026#34;pre-push\u0026#34;: \u0026#34;npm run test\u0026#34; // 在执行 git push 命令时，会执行 npm run test 命令  } } 配置 pre-commit 钩子  在 package.json 文件中添加 \u0026ldquo;scripts\u0026rdquo; 属性：\n\u0026#34;scripts\u0026#34;: { \u0026#34;lint\u0026#34;: \u0026#34;eslint .\u0026#34; } 这里的 \u0026ldquo;lint\u0026rdquo; 命令使用 ESlint 对整个项目进行代码风格检查。","title":"husky"},{"content":"可以使用以下命令将远程分支拉到本地：\n 首先，使用 git remote 命令查看已经添加的远程仓库：  git remote 然后，使用 git fetch 命令将远程分支拉取到本地仓库（不会进行合并）：  git fetch origin remote_branch 最后，使用 git checkout 命令将远程分支切换到本地分支：  git checkout local_branch 组合命令  git fetch origin remote_branch:local_branch 其中，remote_branch 为远程分支名称，origin 为远程仓库名称，local_branch 为本地分支名称，可以根据实际情况进行替换。\n","permalink":"https://tangxiaomi.top/posts/git/remote-branch/","summary":"可以使用以下命令将远程分支拉到本地：\n 首先，使用 git remote 命令查看已经添加的远程仓库：  git remote 然后，使用 git fetch 命令将远程分支拉取到本地仓库（不会进行合并）：  git fetch origin remote_branch 最后，使用 git checkout 命令将远程分支切换到本地分支：  git checkout local_branch 组合命令  git fetch origin remote_branch:local_branch 其中，remote_branch 为远程分支名称，origin 为远程仓库名称，local_branch 为本地分支名称，可以根据实际情况进行替换。","title":"git 将远程分支拉到本地"},{"content":"{ // 在保存时自动格式化代码  \u0026#34;editor.formatOnSave\u0026#34;: true, // 在按下“Commit”字符(如\u0026#34;.\u0026#34;或\u0026#34;;\u0026#34;)时接受建议  \u0026#34;editor.acceptSuggestionOnCommitCharacter\u0026#34;: true, // 在按下“Enter”时接受建议  \u0026#34;editor.acceptSuggestionOnEnter\u0026#34;: \u0026#34;on\u0026#34;, // 自动启用辅助功能  \u0026#34;editor.accessibilitySupport\u0026#34;: \u0026#34;auto\u0026#34;, // 启用背景颜色样式，在编辑器中显示错误和警告等  \u0026#34;editor.colorDecorators\u0026#34;: true, // 光标闪烁类型(\u0026#34;blink\u0026#34;、\u0026#34;smooth\u0026#34; 或 \u0026#34;phase\u0026#34;)  \u0026#34;editor.cursorBlinking\u0026#34;: \u0026#34;blink\u0026#34;, // 开启平滑光标动画  \u0026#34;editor.cursorSmoothCaretAnimation\u0026#34;: false, // 光标样式(\u0026#34;block\u0026#34;, \u0026#34;line\u0026#34; 或 \u0026#34;underline\u0026#34;)  \u0026#34;editor.cursorStyle\u0026#34;: \u0026#34;line\u0026#34;, // 高亮当前行周围的行数(Highlight current line plus n lines)  \u0026#34;editor.cursorSurroundingLines\u0026#34;: 3, // 光标宽度，0 表示使用默认值  \u0026#34;editor.cursorWidth\u0026#34;: 0, // 禁用字形图层提示  \u0026#34;editor.disableLayerHinting\u0026#34;: true, // 禁用等宽字体的优化  \u0026#34;editor.disableMonospaceOptimizations\u0026#34;: false, // 启用拖放支持  \u0026#34;editor.dragAndDrop\u0026#34;: true, // 在空文本中复制时复制当前行或上次选区内容  \u0026#34;editor.emptySelectionClipboard\u0026#34;: true, // 额外的编辑器类名  \u0026#34;editor.extraEditorClassName\u0026#34;: \u0026#34;\u0026#34;, // 编辑器字体  \u0026#34;editor.fontFamily\u0026#34;: \u0026#34;\u0026#39;Droid Sans Mono\u0026#39;, \u0026#39;monospace\u0026#39;, monospace, \u0026#39;Droid Sans Fallback\u0026#39;\u0026#34;, // 启用字体连字  \u0026#34;editor.fontLigatures\u0026#34;: false, // 编辑器字体大小  \u0026#34;editor.fontSize\u0026#34;: 14, // 编辑器字体重量  \u0026#34;editor.fontWeight\u0026#34;: \u0026#34;\u0026#34;, // 粘贴时自动格式化代码  \u0026#34;editor.formatOnPaste\u0026#34;: false, // 显示标尺栏  \u0026#34;editor.glyphMargin\u0026#34;: true, // 在悬停编辑器概述标尺时隐藏光标  \u0026#34;editor.hideCursorInOverviewRuler\u0026#34;: false, // 在敲击代码时显示内联建议  \u0026#34;editor.inlineSuggest.enabled\u0026#34;: true, // 启用内部可访问支持  \u0026#34;editor.internalAccessibilitySupport\u0026#34;: \u0026#34;auto\u0026#34;, // 启用大文件的优化  \u0026#34;editor.largeFileOptimizations\u0026#34;: true, // 高亮匹配的括号  \u0026#34;editor.matchBrackets\u0026#34;: true, // 启用小地图  \u0026#34;editor.minimap.enabled\u0026#34;: false, // 显示的小地图的最大列数  \u0026#34;editor.minimap.maxColumn\u0026#34;: 120, // 渲染小地图中的字符  \u0026#34;editor.minimap.renderCharacters\u0026#34;: true, // 小地图与实际大小的比例  \u0026#34;editor.minimap.scale\u0026#34;: 1, // 小地图右侧的滑块何时显示(\u0026#34;mouseover\u0026#34;、\u0026#34;always\u0026#34; 或 \u0026#34;never\u0026#34;)  \u0026#34;editor.minimap.showSlider\u0026#34;: \u0026#34;mouseover\u0026#34;, // 小地图在哪个侧边栏显示(\u0026#34;left\u0026#34; 或 \u0026#34;right\u0026#34;)  \u0026#34;editor.minimap.side\u0026#34;: \u0026#34;right\u0026#34;, // 启用鼠标滚轮缩放  \u0026#34;editor.mouseWheelZoom\u0026#34;: false, // 多光标时将影响重叠的光标合并到单个光标中  \u0026#34;editor.multiCursorMergeOverlapping\u0026#34;: true, // 启用多光标选择的修改键, 可选值包括 \u0026#34;ctrlCmd\u0026#34;、 \u0026#34;alt\u0026#34;、\u0026#34;shift\u0026#34; 和 \u0026#34;meta\u0026#34;  \u0026#34;editor.multiCursorModifier\u0026#34;: \u0026#34;alt\u0026#34;, // 鼠标移到函数名称上时是否显示参数提示  \u0026#34;editor.parameterHints\u0026#34;: true, // 在敲击代码时显示语言支持的快速建议  \u0026#34;editor.quickSuggestions\u0026#34;: true, // 快速建议的延迟时间（毫秒）  \u0026#34;editor.quickSuggestionsDelay\u0026#34;: 10, // 是否只读，禁止编辑  \u0026#34;editor.readOnly\u0026#34;: false, // 渲染控制字符(CR/LF/Tab) 的显示方式  \u0026#34;editor.renderControlCharacters\u0026#34;: false, // 渲染最后一个仅包含换行符的行  \u0026#34;editor.renderFinalNewline\u0026#34;: true, // 渲染缩进参考线  \u0026#34;editor.renderIndentGuides\u0026#34;: true, // 当前行高亮的样式(\u0026#34;line\u0026#34;, \u0026#34;gutter\u0026#34; 或者 \u0026#34;none\u0026#34;)  \u0026#34;editor.renderLineHighlight\u0026#34;: \u0026#34;line\u0026#34;, // 控制空格和 Tab 的呈现方式  \u0026#34;editor.renderWhitespace\u0026#34;: \u0026#34;none\u0026#34;, // 滚动时突出光标  \u0026#34;editor.revealCursorOnScroll\u0026#34;: true, // 启用默认的 Windows 平台的前向选择样式  \u0026#34;editor.roundedSelection\u0026#34;: true, // 设置标尺的位置  \u0026#34;editor.rulers\u0026#34;: [], // 允许在行的末尾进行额外的滚动，将光标保持在最后一列之后  \u0026#34;editor.scrollBeyondLastColumn\u0026#34;: 5, // 允许在行的末尾进行额外的滚动，将光标保持在最后一行之后  \u0026#34;editor.scrollBeyondLastLine\u0026#34;: true, // 允许在编辑器之间复制和粘贴选择  \u0026#34;editor.selectionClipboard\u0026#34;: true, // 启用匹配选择项  \u0026#34;editor.selectionHighlight\u0026#34;: true, // 显示废弃的语法提示  \u0026#34;editor.showDeprecated\u0026#34;: true, // 前导行代码折叠控制的显示方式(\u0026#34;mouseover\u0026#34;、\u0026#34;always\u0026#34; 或 \u0026#34;none\u0026#34;)  \u0026#34;editor.showFoldingControls\u0026#34;: \u0026#34;mouseover\u0026#34;, // 高亮缩进，淡化其他内容  \u0026#34;editor.showIndentGuides\u0026#34;: true, // 是否显示行号  \u0026#34;editor.showLineNumbers\u0026#34;: true, // 当前行之前滚动的行数(仅在scrollbarHover才有用)  \u0026#34;editor.showPreviousLine\u0026#34;: true, // 显示未使用的代码  \u0026#34;editor.showUnused\u0026#34;: true, // 启用代码片段建议  \u0026#34;editor.snippetSuggestions\u0026#34;: \u0026#34;top\u0026#34;, // 在触发字符后自动显示建议  \u0026#34;editor.suggestOnTriggerCharacters\u0026#34;: true, // 控制如何预先选择建议  \u0026#34;editor.suggestSelection\u0026#34;: \u0026#34;recentlyUsed\u0026#34;, // 控制如何使用 Tab 键来接受建议  \u0026#34;editor.tabCompletion\u0026#34;: \u0026#34;on\u0026#34;, // 缩进宽度  \u0026#34;editor.tabSize\u0026#34;: 4, // 在保存时将自动删除行末的空白  \u0026#34;editor.trimAutoWhitespace\u0026#34;: true, // 智能选词分隔符  \u0026#34;editor.wordSeparators\u0026#34;: \u0026#34;~!@#$%^\u0026amp;*()-=+[{]}\\\\|;:\u0026#39;\\\u0026#34;,.\u0026lt;\u0026gt;/?\u0026#34;, // 控制自动换行(\u0026#34;off\u0026#34;, \u0026#34;on\u0026#34; 或 \u0026#34;wordWrapColumn\u0026#34;)  \u0026#34;editor.wordWrap\u0026#34;: \u0026#34;off\u0026#34;, // 定义哪些字符可能会成为单独一行的断点  \u0026#34;editor.wordWrapBreakAfterCharacters\u0026#34;: \u0026#34;\\t})]?|\u0026amp;,;\u0026#34;, // 定义哪些字符可能会成为单独一行  \u0026#34;editor.wordWrapBreakBeforeCharacters\u0026#34;: \u0026#34;{([+\u0026#34;, // 定义哪些字符可能会成为单独一行的断点之前以及之后(\u0026#34;wordWrapBreakAfterCharacters\u0026#34;和\u0026#34;wordWrapBreakBeforeCharacters\u0026#34;的结合使用)  \u0026#34;editor.wordWrapBreakObtrusiveCharacters\u0026#34;: \u0026#34;.\u0026#34;, // 在wordWrap:\u0026#34;wordWrapColumn\u0026#34;模式下控制编辑器的自动换行  \u0026#34;editor.wordWrapColumn\u0026#34;: 80, // 在 minified 文件中启用自动换行  \u0026#34;editor.wordWrapMinified\u0026#34;: true, // 在多行的第二行和之后缩进相对于第一行  \u0026#34;editor.wrappingIndent\u0026#34;: \u0026#34;same\u0026#34;, // 是否在首选项中启用折叠区域代码折叠  \u0026#34;editor.folding\u0026#34;: true, // 在预览(鼠标悬停)中显示文档  \u0026#34;editor.hover.enabled\u0026#34;: true, // 在鼠标悬停时就显示预览信息，而不是等待300ms  \u0026#34;editor.hover.delay\u0026#34;: 300, // 键入时在符号或标签加亮  \u0026#34;editor.occurrencesHighlight\u0026#34;: true, // 在重命名符号时更新所有引用  \u0026#34;editor.renameOnType\u0026#34;: false, // 修改字体时放大或缩小编辑器  \u0026#34;editor.mouseWheelZoomDelta\u0026#34;: 2, // 滚动鼠标的灵敏度  \u0026#34;editor.mouseWheelScrollSensitivity\u0026#34;: 1, // 平滑滚动  \u0026#34;editor.mouseWheelSmoothScroll\u0026#34;: false, // 显示诊断消息(错误、警告等)  \u0026#34;editor.showDiagnostics\u0026#34;: \u0026#34;warnings\u0026#34;, // 显示代码折叠控件  \u0026#34;editor.showFoldingControlsAlways\u0026#34;: true, // 高亮匹配括号的间距(以像素为单位)  \u0026#34;editor.matchBracketsSpace\u0026#34;: 0, // 控制当在一个断点处输入或删除字符时如何保持缩进  \u0026#34;editor.autoIndent\u0026#34;: \u0026#34;advanced\u0026#34;, // 描述按下 Tab 键时应插入的空白  \u0026#34;editor.useTabStops\u0026#34;: true, // 保留换行符类型  \u0026#34;files.insertFinalNewline\u0026#34;: true, // 在使用 tab 时，插入 N 个空格  \u0026#34;editor.tabSize\u0026#34;: 4, // 开启 Emmet 功能  \u0026#34;emmet.triggerExpansionOnTab\u0026#34;: true, // 启用 emmet 的 auto-preview模式  \u0026#34;emmet.showAbbreviationSuggestions\u0026#34;: true, // 在 HTML 中，为开始和结束标记自动插入一个新行  \u0026#34;emmet.html.format.indentation\u0026#34;: \u0026#34; \u0026#34;, // 在标记之间插入空格  \u0026#34;emmet.syntaxProfiles\u0026#34;: { \u0026#34;javascript\u0026#34;: { \u0026#34;attr_quotes\u0026#34;: \u0026#34;single\u0026#34; } } } ","permalink":"https://tangxiaomi.top/posts/vscode/setting/","summary":"{ // 在保存时自动格式化代码  \u0026#34;editor.formatOnSave\u0026#34;: true, // 在按下“Commit”字符(如\u0026#34;.\u0026#34;或\u0026#34;;\u0026#34;)时接受建议  \u0026#34;editor.acceptSuggestionOnCommitCharacter\u0026#34;: true, // 在按下“Enter”时接受建议  \u0026#34;editor.acceptSuggestionOnEnter\u0026#34;: \u0026#34;on\u0026#34;, // 自动启用辅助功能  \u0026#34;editor.accessibilitySupport\u0026#34;: \u0026#34;auto\u0026#34;, // 启用背景颜色样式，在编辑器中显示错误和警告等  \u0026#34;editor.colorDecorators\u0026#34;: true, // 光标闪烁类型(\u0026#34;blink\u0026#34;、\u0026#34;smooth\u0026#34; 或 \u0026#34;phase\u0026#34;)  \u0026#34;editor.cursorBlinking\u0026#34;: \u0026#34;blink\u0026#34;, // 开启平滑光标动画  \u0026#34;editor.cursorSmoothCaretAnimation\u0026#34;: false, // 光标样式(\u0026#34;block\u0026#34;, \u0026#34;line\u0026#34; 或 \u0026#34;underline\u0026#34;)  \u0026#34;editor.cursorStyle\u0026#34;: \u0026#34;line\u0026#34;, // 高亮当前行周围的行数(Highlight current line plus n lines)  \u0026#34;editor.cursorSurroundingLines\u0026#34;: 3, // 光标宽度，0 表示使用默认值  \u0026#34;editor.cursorWidth\u0026#34;: 0, // 禁用字形图层提示  \u0026#34;editor.disableLayerHinting\u0026#34;: true, // 禁用等宽字体的优化  \u0026#34;editor.","title":"vscode 所有配置对照表"},{"content":"简介 ESLint是一个开源的 JavaScript 代码检查工具，可以帮助我们发现代码中存在的错误和潜在问题，并给出推荐的修复方案，从而提高代码的质量和可读性。\n本文将要介绍如何在VSCode中配置ESLint，实现自动保存校验功能，让我们的代码更加健康。\n步骤 第一步：安装ESLint插件 如果没有安装ESLint插件的话，我们需要先到VSCode插件商店中安装ESLint插件，安装过程非常简单，只需要在搜索框中输入“ESLint”即可。\n第二步：安装ESLint模块 在项目中安装ESLint模块依赖，可以使用npm或yarn，如下：\nnpm install eslint --save-dev 或\nyarn add eslint --dev 第三步：创建ESLint配置文件 创建一个名为.eslintrc.json的文件，用来存放ESLint配置信息。\n{ \u0026#34;extends\u0026#34;: \u0026#34;eslint:recommended\u0026#34;, \u0026#34;rules\u0026#34;: {} } 这里使用了eslint:recommended作为配置的扩展，这些规则是由ESLint核心团队定义的一组推荐的规则。当然你也可以自定义一些规则，具体可参考官方文档。\n第四步：配置VSCode 我们需要在VSCode的配置文件中，添加以下内容实现自动保存校验。\n{ \u0026#34;editor.codeActionsOnSave\u0026#34;: { \u0026#34;source.fixAll.eslint\u0026#34;: true }, \u0026#34;editor.formatOnSave\u0026#34;: false, \u0026#34;eslint.alwaysShowStatus\u0026#34;: true, \u0026#34;eslint.validate\u0026#34;: [ \u0026#34;javascript\u0026#34;, \u0026#34;javascriptreact\u0026#34;, { \u0026#34;language\u0026#34;: \u0026#34;vue\u0026#34;, \u0026#34;autoFix\u0026#34;: true }, { \u0026#34;language\u0026#34;: \u0026#34;html\u0026#34;, \u0026#34;autoFix\u0026#34;: true } ] } 这里通过\u0026quot;editor.codeActionsOnSave\u0026quot;属性实现自动保存校验，当我们保存文件时，如果存在ESLint报错，VSCode会自动执行修复操作。\n同时将\u0026quot;editor.formatOnSave\u0026quot;设置为false，表示不对存储时代码格式进行调整。\n最后配置\u0026quot;eslint.validate\u0026quot;即可，这里我们对\u0026quot;javascript\u0026quot;和\u0026quot;javascriptreact\u0026quot;进行校验和自动修复，同时对Vue和HTML代码添加支持。\n总结 通过这个简单的配置，我们可以让ESLint与VSCode紧密地结合在一起，实现在保存代码之前、常规编写过程中进行代码检查校验。这将使我们能够更快地发现并修复潜在的问题，从而提高代码的质量和可读性。\n","permalink":"https://tangxiaomi.top/posts/vscode/eslint/","summary":"简介 ESLint是一个开源的 JavaScript 代码检查工具，可以帮助我们发现代码中存在的错误和潜在问题，并给出推荐的修复方案，从而提高代码的质量和可读性。\n本文将要介绍如何在VSCode中配置ESLint，实现自动保存校验功能，让我们的代码更加健康。\n步骤 第一步：安装ESLint插件 如果没有安装ESLint插件的话，我们需要先到VSCode插件商店中安装ESLint插件，安装过程非常简单，只需要在搜索框中输入“ESLint”即可。\n第二步：安装ESLint模块 在项目中安装ESLint模块依赖，可以使用npm或yarn，如下：\nnpm install eslint --save-dev 或\nyarn add eslint --dev 第三步：创建ESLint配置文件 创建一个名为.eslintrc.json的文件，用来存放ESLint配置信息。\n{ \u0026#34;extends\u0026#34;: \u0026#34;eslint:recommended\u0026#34;, \u0026#34;rules\u0026#34;: {} } 这里使用了eslint:recommended作为配置的扩展，这些规则是由ESLint核心团队定义的一组推荐的规则。当然你也可以自定义一些规则，具体可参考官方文档。\n第四步：配置VSCode 我们需要在VSCode的配置文件中，添加以下内容实现自动保存校验。\n{ \u0026#34;editor.codeActionsOnSave\u0026#34;: { \u0026#34;source.fixAll.eslint\u0026#34;: true }, \u0026#34;editor.formatOnSave\u0026#34;: false, \u0026#34;eslint.alwaysShowStatus\u0026#34;: true, \u0026#34;eslint.validate\u0026#34;: [ \u0026#34;javascript\u0026#34;, \u0026#34;javascriptreact\u0026#34;, { \u0026#34;language\u0026#34;: \u0026#34;vue\u0026#34;, \u0026#34;autoFix\u0026#34;: true }, { \u0026#34;language\u0026#34;: \u0026#34;html\u0026#34;, \u0026#34;autoFix\u0026#34;: true } ] } 这里通过\u0026quot;editor.codeActionsOnSave\u0026quot;属性实现自动保存校验，当我们保存文件时，如果存在ESLint报错，VSCode会自动执行修复操作。\n同时将\u0026quot;editor.formatOnSave\u0026quot;设置为false，表示不对存储时代码格式进行调整。\n最后配置\u0026quot;eslint.validate\u0026quot;即可，这里我们对\u0026quot;javascript\u0026quot;和\u0026quot;javascriptreact\u0026quot;进行校验和自动修复，同时对Vue和HTML代码添加支持。\n总结 通过这个简单的配置，我们可以让ESLint与VSCode紧密地结合在一起，实现在保存代码之前、常规编写过程中进行代码检查校验。这将使我们能够更快地发现并修复潜在的问题，从而提高代码的质量和可读性。","title":"用VSCode配置ESLint自动保存校验"},{"content":"🚀 前言 微信小程序是一种全新的应用模式，它可以在微信中直接运行，用户无需下载安装即可使用，具有开发简单、轻量级、低成本等优点，非常适合创业公司、个人开发者等快速开发原型或小型商业应用。\n🔧 准备工作 1. 安装微信开发者工具 微信小程序开发需要使用微信官方提供的开发者工具，点击这里下载适用于您的操作系统的开发者工具。\n2. 注册微信小程序账号 点击这里，注册一个微信小程序账号。\n3. 创建小程序 打开微信开发者工具，点击\u0026quot;新建小程序\u0026quot;按钮，按照提示填写小程序基本信息，即可创建一个最简单的小程序。\n🚀 开发第一个小程序 1. 目录结构 创建小程序后，微信开发者工具会自动生成一些模板文件，目录结构如下：\nmyproject ├── app.js ├── app.json ├── app.wxss └── pages └── index ├── index.js ├── index.json ├── index.wxml └── index.wxss 其中，app.js是小程序的脚本文件，app.json是小程序的配置文件，app.wxss是小程序的全局样式表。\npages目录下是小程序的页面文件，每个页面文件都由4个文件组成：脚本文件（.js）、配置文件（.json）、模板文件（.wxml）和样式表文件（.wxss）。\n2. Hello World 打开index.wxml，在其中输入以下代码：\n\u0026lt;!--index.wxml--\u0026gt; \u0026lt;text\u0026gt;{{message}}\u0026lt;/text\u0026gt; 打开index.js，在其中输入以下代码：\n//index.js Page({ data: { message: \u0026#34;Hello World\u0026#34; } }) 应用这些变更后，点击微信开发者工具的\u0026quot;预览\u0026quot;按钮，可以在微信中查看效果。\n3. 组件介绍 在示例代码中，我们使用了\u0026lt;text\u0026gt;标签，这是一种小程序内置的组件。在小程序中，所有显示内容都是由组件构成的，组件可以嵌套使用，从而构成丰富的页面布局。\n下面简单介绍几个常用组件：\n \u0026lt;view\u0026gt;：与HTML中的\u0026lt;div\u0026gt;类似，用于嵌套其它组件，可以设置样式或事件。 \u0026lt;text\u0026gt;：用于显示文本，可以设置颜色、字体大小等。 \u0026lt;button\u0026gt;：用于创建按钮，可以设置事件。 \u0026lt;image\u0026gt;：用于显示图片，可以设置 src 属性。  4. 数据绑定 在示例代码中，我们使用了{{message}}语法，将message变量的值绑定到\u0026lt;text\u0026gt;组件的内容中。\n数据绑定是小程序中非常常用的功能。除了上述这种插值绑定，还可以在属性中使用绑定语法：\n\u0026lt;!--index.wxml--\u0026gt; \u0026lt;view class=\u0026#34;{{className}}\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; //index.js Page({ data: { className: \u0026#34;red\u0026#34; } }) 这样的代码将给\u0026lt;view\u0026gt;组件的class属性动态赋值，从而实现样式切换等功能。\n5. 事件处理 小程序中的事件处理与普通的Web开发类似，也可以使用事件冒泡、事件委托等技术。\n下面是一个示例代码：\n\u0026lt;!--index.wxml--\u0026gt; \u0026lt;button bindtap=\u0026#34;onClick\u0026#34;\u0026gt;点击我\u0026lt;/button\u0026gt; //index.js Page({ onClick: function(event) { console.log(\u0026#34;按钮被点击了\u0026#34;) } }) 这段代码实现了一个简单的按钮点击事件，点击按钮后将在控制台输出信息。\n6. 网络请求 小程序具有完善的网络功能，可以使用wx.request()API发送HTTP请求，并处理返回的结果。\n下面是一个简单的示例代码：\n//index.js Page({ onLoad: function(options) { wx.request({ url: \u0026#34;https://api.github.com/users/octocat\u0026#34;, success: function(res) { console.log(res.data) }, fail: function() { console.log(\u0026#34;请求失败\u0026#34;) } }) } }) 这段代码实现了一个简单的网络请求，使用GitHub API获取了用户octocat的信息，并在控制台输出了返回结果。\n 如需深入学习相关内容，可以参考微信小程序官方文档：https://developers.weixin.qq.com/miniprogram/dev/index.html 。\n ","permalink":"https://tangxiaomi.top/posts/mini-program/getting-started/","summary":"🚀 前言 微信小程序是一种全新的应用模式，它可以在微信中直接运行，用户无需下载安装即可使用，具有开发简单、轻量级、低成本等优点，非常适合创业公司、个人开发者等快速开发原型或小型商业应用。\n🔧 准备工作 1. 安装微信开发者工具 微信小程序开发需要使用微信官方提供的开发者工具，点击这里下载适用于您的操作系统的开发者工具。\n2. 注册微信小程序账号 点击这里，注册一个微信小程序账号。\n3. 创建小程序 打开微信开发者工具，点击\u0026quot;新建小程序\u0026quot;按钮，按照提示填写小程序基本信息，即可创建一个最简单的小程序。\n🚀 开发第一个小程序 1. 目录结构 创建小程序后，微信开发者工具会自动生成一些模板文件，目录结构如下：\nmyproject ├── app.js ├── app.json ├── app.wxss └── pages └── index ├── index.js ├── index.json ├── index.wxml └── index.wxss 其中，app.js是小程序的脚本文件，app.json是小程序的配置文件，app.wxss是小程序的全局样式表。\npages目录下是小程序的页面文件，每个页面文件都由4个文件组成：脚本文件（.js）、配置文件（.json）、模板文件（.wxml）和样式表文件（.wxss）。\n2. Hello World 打开index.wxml，在其中输入以下代码：\n\u0026lt;!--index.wxml--\u0026gt; \u0026lt;text\u0026gt;{{message}}\u0026lt;/text\u0026gt; 打开index.js，在其中输入以下代码：\n//index.js Page({ data: { message: \u0026#34;Hello World\u0026#34; } }) 应用这些变更后，点击微信开发者工具的\u0026quot;预览\u0026quot;按钮，可以在微信中查看效果。\n3. 组件介绍 在示例代码中，我们使用了\u0026lt;text\u0026gt;标签，这是一种小程序内置的组件。在小程序中，所有显示内容都是由组件构成的，组件可以嵌套使用，从而构成丰富的页面布局。\n下面简单介绍几个常用组件：\n \u0026lt;view\u0026gt;：与HTML中的\u0026lt;div\u0026gt;类似，用于嵌套其它组件，可以设置样式或事件。 \u0026lt;text\u0026gt;：用于显示文本，可以设置颜色、字体大小等。 \u0026lt;button\u0026gt;：用于创建按钮，可以设置事件。 \u0026lt;image\u0026gt;：用于显示图片，可以设置 src 属性。  4. 数据绑定 在示例代码中，我们使用了{{message}}语法，将message变量的值绑定到\u0026lt;text\u0026gt;组件的内容中。","title":"微信小程序开发入门教程"},{"content":"JavaScript的高阶函数是一个非常强大的特性，它允许我们编写更加灵活和可重用的代码。在本文中，我们将探讨高阶函数的概念、它们如何实现以及一些示例。\n什么是高阶函数 高阶函数是指接受一个或多个函数作为参数，并可以返回函数作为结果的函数。这种函数可以用来将其他函数“包装起来”或者实现某种通用的行为。ES6的箭头函数使得编写高阶函数变得更加简单和方便。\n高阶函数的实现 下面是一个使用普通函数实现高阶函数的例子：\nfunction map(arr, fn) { const mappedArr = []; for (let i=0; i\u0026lt;arr.length; i++) { const val = fn(arr[i], i, arr); mappedArr.push(val); } return mappedArr; } 这个函数实现了一个非常常见的高阶函数——map()。它接受一个数组和一个函数作为参数，并返回一个新数组，这个新数组的元素是将原数组的每个元素传递给函数之后得到的新值。\n使用箭头函数，我们可以更加简洁地实现同样的功能：\nconst map = (arr, fn) =\u0026gt; arr.map(fn); 这个例子中，我们用箭头函数实现了一个新的map()函数。它使用了原生的Array.map()方法实现了同样的功能，代码更加简洁和优雅。\n高阶函数的示例 现在我们来看一些常见的高阶函数例子，以及它们如何用于实现通用的行为。\nforEach() forEach()是一个很常见的高阶函数，它用于遍历数组。我们可以使用它将一个函数应用于数组的每个元素：\nconst numbers = [1, 2, 3, 4, 5]; numbers.forEach(num =\u0026gt; console.log(num)); 这将会打印数组中的每个数字。\nfilter() filter()是另一个常见的高阶函数，它用于过滤数组。我们可以使用它筛选出我们想要的元素：\nconst people = [ {name: \u0026#39;John\u0026#39;, age: 25}, {name: \u0026#39;Jane\u0026#39;, age: 30}, {name: \u0026#39;Bob\u0026#39;, age: 20} ]; const adults = people.filter(person =\u0026gt; person.age \u0026gt;= 25); console.log(adults); 这将会输出年龄大于或等于25岁的人的信息。\nreduce() reduce()是一个非常强大的高阶函数，它可以从一个数组中提取出一个值。我们可以使用它来计算数组的平均值、求和等操作：\nconst numbers = [1, 2, 3, 4, 5]; const sum = numbers.reduce((acc, num) =\u0026gt; acc + num, 0); console.log(sum); 这将会输出数组的总和5。\n总结 高阶函数是一个非常有用和强大的概念。它们允许我们编写更加灵活和可重用的代码。在本文中，我们探讨了高阶函数的概念和实现方法，并给出了一些实际例子。当您编写JavaScript代码时，请记得考虑使用高阶函数来提高代码的可维护性和灵活性。\n","permalink":"https://tangxiaomi.top/posts/js/higher-order-function/","summary":"JavaScript的高阶函数是一个非常强大的特性，它允许我们编写更加灵活和可重用的代码。在本文中，我们将探讨高阶函数的概念、它们如何实现以及一些示例。\n什么是高阶函数 高阶函数是指接受一个或多个函数作为参数，并可以返回函数作为结果的函数。这种函数可以用来将其他函数“包装起来”或者实现某种通用的行为。ES6的箭头函数使得编写高阶函数变得更加简单和方便。\n高阶函数的实现 下面是一个使用普通函数实现高阶函数的例子：\nfunction map(arr, fn) { const mappedArr = []; for (let i=0; i\u0026lt;arr.length; i++) { const val = fn(arr[i], i, arr); mappedArr.push(val); } return mappedArr; } 这个函数实现了一个非常常见的高阶函数——map()。它接受一个数组和一个函数作为参数，并返回一个新数组，这个新数组的元素是将原数组的每个元素传递给函数之后得到的新值。\n使用箭头函数，我们可以更加简洁地实现同样的功能：\nconst map = (arr, fn) =\u0026gt; arr.map(fn); 这个例子中，我们用箭头函数实现了一个新的map()函数。它使用了原生的Array.map()方法实现了同样的功能，代码更加简洁和优雅。\n高阶函数的示例 现在我们来看一些常见的高阶函数例子，以及它们如何用于实现通用的行为。\nforEach() forEach()是一个很常见的高阶函数，它用于遍历数组。我们可以使用它将一个函数应用于数组的每个元素：\nconst numbers = [1, 2, 3, 4, 5]; numbers.forEach(num =\u0026gt; console.log(num)); 这将会打印数组中的每个数字。\nfilter() filter()是另一个常见的高阶函数，它用于过滤数组。我们可以使用它筛选出我们想要的元素：\nconst people = [ {name: \u0026#39;John\u0026#39;, age: 25}, {name: \u0026#39;Jane\u0026#39;, age: 30}, {name: \u0026#39;Bob\u0026#39;, age: 20} ]; const adults = people.","title":"js高阶函数"},{"content":"这是一份 Git 命令的快速查找手册，包含了 Git 的常用命令和基本用法。快速找到你需要的命令和用法，让你的 Git 使用更加轻松自如。\n🚀 初始化  git init : 初始化一个 Git 仓库。 git clone \u0026lt;URL\u0026gt; : 克隆一个远程 Git 仓库。  📝 添加与提交  git add \u0026lt;file\u0026gt; : 将文件添加到暂存区。 git add . : 将所有修改添加到暂存区。 git commit -m \u0026quot;\u0026lt;message\u0026gt;\u0026quot; : 提交变更并附上提交信息。 git commit -a : 跳过暂存区，直接提交所有变更。  🌿 分支和合并  git branch : 列出当前仓库的所有分支。 git branch \u0026lt;branch\u0026gt; : 创建一个新分支。 git checkout \u0026lt;branch\u0026gt; : 切换到一个分支。 git checkout -b \u0026lt;branch\u0026gt; : 创建一个新的分支并立即切换到该分支。 git merge \u0026lt;branch\u0026gt; : 合并指定分支到当前分支。 git merge --no-ff \u0026lt;branch\u0026gt; : 强制 Git 创建一个新的合并提交，即使当前分支可以通过快进合并到指定分支。  🔀 推送与拉取  git pull : 从远程仓库拉取代码。 git push : 将本地分支的更改推送到远程仓库。 git push -u \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; : 第一次推送分支时，使用此命令将本地分支推送到远程仓库。 git fetch \u0026lt;remote\u0026gt; : 从远程仓库拉取变更，但不自动合并它们。 git fetch --all : 从远程仓库拉取所有分支的变更，但不自动合并它们。 git push \u0026lt;remote\u0026gt; --delete \u0026lt;branch\u0026gt; : 从远程仓库删除指定分支。  🔎 查看日志  git log : 查看提交日志。 git log --oneline : 查看简洁的提交日志。 git log --graph --oneline : 查看提交日志并显示分支合并图。 git blame \u0026lt;file\u0026gt; : 显示指定文件的每一行是由谁添加的。  ❌ 撤销与修改  git checkout \u0026lt;file\u0026gt; : 用仓库中的文件替换工作目录中的文件，从而撤消最近的修订。 git reset HEAD \u0026lt;file\u0026gt; : 取消已暂存文件。 git reset HEAD~ : 返回上一个commit版本，并将文件修改保留在工作目录。 git reset \u0026lt;commit\u0026gt; : 恢复指定提交的状态，同时将工作区和暂存区的修改移回到工作区。 git reset --hard : 取消所有本地修改，并恢复到最近的提交状态。 git clean -f : 删除未被跟踪的文件。  🎨 其他命令  git status : 显示工作目录下已提交和未提交的修改。 git diff : 显示工作目录和本地仓库之间的差异。 git stash : 将工作目录中的未提交修改保存到一个栈中。 git stash apply : 恢复最新的stash，并将内容应用于工作区。 git stash list : 显示所有的stash记录。 git stash pop : 删除最新的stash，并将其应用于工作区。 git stash drop : 删除最新的stash。 git remote add \u0026lt;name\u0026gt; \u0026lt;url\u0026gt; : 将一个新远程仓库添加到当前 Git 仓库中。 git remote -v : 显示当前仓库的所有远程仓库及其 URL。 git tag : 列出已经存在的标签。 git tag \u0026lt;tagname\u0026gt; : 新建一个标签，默认为HEAD，用于后续推送到远程仓库。 git push origin \u0026lt;tagname\u0026gt; : 将指定标签推送到远程仓库。 git push origin --tags : 将所有标签推送到远程仓库。 git show \u0026lt;commit\u0026gt; : 显示指定提交的信息。  ","permalink":"https://tangxiaomi.top/posts/git/guide/","summary":"这是一份 Git 命令的快速查找手册，包含了 Git 的常用命令和基本用法。快速找到你需要的命令和用法，让你的 Git 使用更加轻松自如。\n🚀 初始化  git init : 初始化一个 Git 仓库。 git clone \u0026lt;URL\u0026gt; : 克隆一个远程 Git 仓库。  📝 添加与提交  git add \u0026lt;file\u0026gt; : 将文件添加到暂存区。 git add . : 将所有修改添加到暂存区。 git commit -m \u0026quot;\u0026lt;message\u0026gt;\u0026quot; : 提交变更并附上提交信息。 git commit -a : 跳过暂存区，直接提交所有变更。  🌿 分支和合并  git branch : 列出当前仓库的所有分支。 git branch \u0026lt;branch\u0026gt; : 创建一个新分支。 git checkout \u0026lt;branch\u0026gt; : 切换到一个分支。 git checkout -b \u0026lt;branch\u0026gt; : 创建一个新的分支并立即切换到该分支。 git merge \u0026lt;branch\u0026gt; : 合并指定分支到当前分支。 git merge --no-ff \u0026lt;branch\u0026gt; : 强制 Git 创建一个新的合并提交，即使当前分支可以通过快进合并到指定分支。  🔀 推送与拉取  git pull : 从远程仓库拉取代码。 git push : 将本地分支的更改推送到远程仓库。 git push -u \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; : 第一次推送分支时，使用此命令将本地分支推送到远程仓库。 git fetch \u0026lt;remote\u0026gt; : 从远程仓库拉取变更，但不自动合并它们。 git fetch --all : 从远程仓库拉取所有分支的变更，但不自动合并它们。 git push \u0026lt;remote\u0026gt; --delete \u0026lt;branch\u0026gt; : 从远程仓库删除指定分支。  🔎 查看日志  git log : 查看提交日志。 git log --oneline : 查看简洁的提交日志。 git log --graph --oneline : 查看提交日志并显示分支合并图。 git blame \u0026lt;file\u0026gt; : 显示指定文件的每一行是由谁添加的。  ❌ 撤销与修改  git checkout \u0026lt;file\u0026gt; : 用仓库中的文件替换工作目录中的文件，从而撤消最近的修订。 git reset HEAD \u0026lt;file\u0026gt; : 取消已暂存文件。 git reset HEAD~ : 返回上一个commit版本，并将文件修改保留在工作目录。 git reset \u0026lt;commit\u0026gt; : 恢复指定提交的状态，同时将工作区和暂存区的修改移回到工作区。 git reset --hard : 取消所有本地修改，并恢复到最近的提交状态。 git clean -f : 删除未被跟踪的文件。  🎨 其他命令  git status : 显示工作目录下已提交和未提交的修改。 git diff : 显示工作目录和本地仓库之间的差异。 git stash : 将工作目录中的未提交修改保存到一个栈中。 git stash apply : 恢复最新的stash，并将内容应用于工作区。 git stash list : 显示所有的stash记录。 git stash pop : 删除最新的stash，并将其应用于工作区。 git stash drop : 删除最新的stash。 git remote add \u0026lt;name\u0026gt; \u0026lt;url\u0026gt; : 将一个新远程仓库添加到当前 Git 仓库中。 git remote -v : 显示当前仓库的所有远程仓库及其 URL。 git tag : 列出已经存在的标签。 git tag \u0026lt;tagname\u0026gt; : 新建一个标签，默认为HEAD，用于后续推送到远程仓库。 git push origin \u0026lt;tagname\u0026gt; : 将指定标签推送到远程仓库。 git push origin --tags : 将所有标签推送到远程仓库。 git show \u0026lt;commit\u0026gt; : 显示指定提交的信息。  ","title":"git 命令手册 📖"},{"content":"Vite 是一个快速、轻量级、易于使用的前端工具。它为开发者提供了一种现代的构建方式，可以快速地构建出高效且易于维护的 Web 应用程序。\n在 Vite 版本 4.2 及以上的版本中，我们可以使用 configureServer 方法来拦截 Vite 开发服务器，并将其替换为 express HTTP 服务器。这样，我们就可以使用更加灵活的 HTTP 服务器组合，并且可以方便地实现登录、鉴权等功能。\n配置 Vite 插件 为了使用自定义的 express 应用程序，我们需要编写一个 Vite 插件\n我们可以通过 myPlugin 函数来创建一个新插件。这个插件暴露了一个 configureServer 方法，我们可以在这个方法中创建并配置一个 express 应用程序。\nimport express from \u0026#39;express\u0026#39; import cors from \u0026#39;cors\u0026#39; import bodyParser from \u0026#39;body-parser\u0026#39; import cookieParser from \u0026#39;cookie-parser\u0026#39; export default function myPlugin () { return { name: \u0026#39;my-plugin\u0026#39;, configureServer (server) { const app = express() app.use(cors({ credentials: true, origin: true })) app.use(bodyParser.urlencoded({ extended: false })) app.use(cookieParser()) server.middlewares.use(app) app.use(\u0026#39;/login\u0026#39;, () =\u0026gt; { // login  }) } } } 在 configureServer 方法中，我们首先创建了一个新的 express 应用程序 app。\n接下来，我们注册了 cors、body-parser 和 cookie-parser 中间件，这样我们就可以在应用程序中使用这些中间件了。\n然后，我们将应用程序添加到 Vite 开发服务器的中间件中，这样就可以使用自定义的 express 应用程序来处理 HTTP 请求了。\n最后，我们向应用程序中添加了一个处理 /login URL 路径的路由处理函数，用于执行登录逻辑。\n配置 Vite 使用 configureServer 来配置 Vite 开发服务器也很简单。我们只需要将插件导入应用程序，然后将其添加到 Vite 配置的 plugins 队列中，就可以完整地拦截 Vite 开发服务器了。\nimport myPlugin from \u0026#39;./myPlugin\u0026#39; export default defineConfig({ // ...  plugins: [ myPlugin() ] }) 结论 通过使用 configureServer 方法，我们可以轻松地拦截 Vite 开发服务器，并使用 express HTTP 服务器来替换它。\n这种方式可以让我们在 Vite 开发服务器中使用更加灵活的 HTTP 服务器组合，并且可以方便地实现登录、鉴权等功能。\n","permalink":"https://tangxiaomi.top/posts/vite/express/","summary":"Vite 是一个快速、轻量级、易于使用的前端工具。它为开发者提供了一种现代的构建方式，可以快速地构建出高效且易于维护的 Web 应用程序。\n在 Vite 版本 4.2 及以上的版本中，我们可以使用 configureServer 方法来拦截 Vite 开发服务器，并将其替换为 express HTTP 服务器。这样，我们就可以使用更加灵活的 HTTP 服务器组合，并且可以方便地实现登录、鉴权等功能。\n配置 Vite 插件 为了使用自定义的 express 应用程序，我们需要编写一个 Vite 插件\n我们可以通过 myPlugin 函数来创建一个新插件。这个插件暴露了一个 configureServer 方法，我们可以在这个方法中创建并配置一个 express 应用程序。\nimport express from \u0026#39;express\u0026#39; import cors from \u0026#39;cors\u0026#39; import bodyParser from \u0026#39;body-parser\u0026#39; import cookieParser from \u0026#39;cookie-parser\u0026#39; export default function myPlugin () { return { name: \u0026#39;my-plugin\u0026#39;, configureServer (server) { const app = express() app.use(cors({ credentials: true, origin: true })) app.","title":"如何在 Vite 中拦截开发服务器并使用 express"}]
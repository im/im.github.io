<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>糖小米 · 博客</title>
  
  <subtitle>厚积薄发</subtitle>
  <link href="https://tangxiaomi.top/atom.xml" rel="self"/>
  
  <link href="https://tangxiaomi.top/"/>
  <updated>2021-06-24T01:47:53.076Z</updated>
  <id>https://tangxiaomi.top/</id>
  
  <author>
    <name>糖小米</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title> 详解valueOf() 与toString()是做什么的以及其在各种情况下的应用</title>
    <link href="https://tangxiaomi.top/2021/06/17/javascript/1543294b3a/"/>
    <id>https://tangxiaomi.top/2021/06/17/javascript/1543294b3a/</id>
    <published>2021-06-17T07:24:35.000Z</published>
    <updated>2021-06-24T01:47:53.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>各种引用对象都继承或最终继承于 Object ，使用着Object的原型，所以它们不管何时都有 toString() 和 valueOf() 方法，只不过有些类型的原型重写了这两个方法，比如 Function 实例的原型就重写了 toString() 方法，按照原型链的规则，如果方法和属性在原型链的各原型中有重名，则优先使用最近的方法和属性。</p><hr><p>先看看常用的引用类型重写了这两个方法的情况</p><ul><li>Function 重写了 toString()</li><li>Date 重写了 toString() 也重写了 valueOf()</li><li>Array 重写了 toString()</li></ul><a id="more"></a><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>对于不同的引用对象，使用的toString()也不一定相同<br>我们来看看其对三个最常见的引用对象的处理。</p><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>很简单，就是function本身的样子</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-built_in">console</span>.log(fn == <span class="hljs-string">&#x27;function () &#123;&#125;&#x27;</span>) <span class="hljs-comment">//true</span><span class="hljs-comment">//上一篇讲到如果用双等号的一边是引用类型</span><span class="hljs-comment">//（除了Date直接用toString（）转换）则先将元素进行valueOf()转换，再把它用toString()转换后进行比较</span><span class="hljs-comment">//https://blog.csdn.net/weixin_42476799/article/details/89296873</span></code></pre><pre><code class="hljs js"><span class="hljs-keyword">let</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>) &#125;<span class="hljs-built_in">console</span>.log(fn == <span class="hljs-string">&#x27;function() &#123; console.log(1) &#125;&#x27;</span>)<span class="hljs-comment">//true</span></code></pre><p>这时候问题来了</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)&#125;<span class="hljs-comment">//这边末尾大括号前缺了个空格</span><span class="hljs-built_in">console</span>.log(fn == <span class="hljs-string">&#x27;function() &#123; console.log(1) &#125;&#x27;</span>)<span class="hljs-comment">//它是true呢还是false呢</span></code></pre><p>结果是false<br>也就是说function进行了toString()转换后与我们书写的function完全一样，多个空格少个空格都不行</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">//没有空格</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)&#125;<span class="hljs-built_in">console</span>.log(fn == <span class="hljs-string">&#x27;function() &#123;\nconsole.log(1)\n&#125;&#x27;</span>)<span class="hljs-comment">//它是true呢还是false呢</span></code></pre><p>false,这又是为什么呢，因为toString()时会把注释也给加进去。。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">//没有空格</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)&#125;<span class="hljs-built_in">console</span>.log(fn == <span class="hljs-string">&#x27;function() &#123;//没有空格\nconsole.log(1)\n&#125;&#x27;</span>)<span class="hljs-comment">//true</span></code></pre><p>所以现在可以得出结论了function对象的toString()到底做了些什么呢，把我们写function内容完完全全复制成为了字符串。<br>如果你觉得写一些\n什么的麻烦，可以试试es6的``,也就是模板字符串。比如：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">//没有空格</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)&#125;<span class="hljs-built_in">console</span>.log(fn == <span class="hljs-string">`function() &#123;//没有空格</span><span class="hljs-string">console.log(1)</span><span class="hljs-string">&#125;`</span>)<span class="hljs-comment">//true</span></code></pre><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>我们先来看一下 Array 是怎样的</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]<span class="hljs-built_in">console</span>.log(arr == <span class="hljs-string">&#x27;1,2,3,4,5,2,1,5,2,1,5&#x27;</span>)<span class="hljs-comment">//true</span></code></pre><p>它就简单多了我们再来看看它会不会出现function那种要与原函数写得完全一样</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>, <span class="hljs-number">1</span>,<span class="hljs-number">5</span>]<span class="hljs-built_in">console</span>.log(arr == <span class="hljs-string">&#x27;1,2,3,4,5,2,1,5,2,1,5&#x27;</span>)<span class="hljs-comment">//true</span></code></pre><p>所以就可以得出结论了arr.toString()就是将每个元素用逗号隔开类似于arr.join(’,’)</p><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><pre><code class="hljs js"><span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;1998-02-23&#x27;</span>)<span class="hljs-built_in">console</span>.log(date == <span class="hljs-string">&#x27;Mon Feb 23 1998 08:00:00 GMT+0800 (中国标准时间)&#x27;</span>)<span class="hljs-comment">//true</span></code></pre><p>它也比较直接，只要你传的值是它能解析的日期格式，toString()后给你的是和上边格式一样的字符串</p><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj1 = &#123;&#125;,obj2 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;name&#x27;</span>&#125;<span class="hljs-built_in">console</span>.log(obj2 == <span class="hljs-string">&#x27;[object Object]&#x27;</span>)<span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(obj1 == <span class="hljs-string">&#x27;[object Object]&#x27;</span>)<span class="hljs-comment">//true</span></code></pre><p>Object不管写成啥样，都会变成’[object Object]’这个字符串</p><h2 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h2><h3 id="Function-1"><a href="#Function-1" class="headerlink" title="Function"></a>Function</h3><pre><code class="hljs js"><span class="hljs-keyword">let</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-built_in">console</span>.log(fn.valueOf() === fn)<span class="hljs-comment">//true</span></code></pre><p>也就是说fn.valueOf()返回的是fn本身。是不是很无聊。</p><h3 id="Array-1"><a href="#Array-1" class="headerlink" title="Array"></a>Array</h3><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>, <span class="hljs-number">1</span>,<span class="hljs-number">5</span>]<span class="hljs-built_in">console</span>.log(arr.valueOf() === arr)<span class="hljs-comment">//Array也是返回自身</span></code></pre><h3 id="Object-1"><a href="#Object-1" class="headerlink" title="Object"></a>Object</h3><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;<span class="hljs-built_in">console</span>.log(obj.valueOf() === obj)<span class="hljs-comment">//Object也是返回自身</span></code></pre><h3 id="Date-1"><a href="#Date-1" class="headerlink" title="Date"></a>Date</h3><p>难道date也是返回自身吗</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;1998-02-23&#x27;</span>)<span class="hljs-built_in">console</span>.log(date.valueOf() === date)<span class="hljs-comment">//false</span></code></pre><p>前文提到，三个常用的引用对象中只有Date重写了valueOf()方法，那肯定有它的独到之处，我们来看看它是什么</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;1998-02-23&#x27;</span>)<span class="hljs-built_in">console</span>.log(date.valueOf() === <span class="hljs-number">888192000000</span> )<span class="hljs-comment">//true</span></code></pre><p>原来它是返回从 1970 年 1 月 1 日午夜开始计的毫秒数。</p><p>我们现在知道了这四个引用对象用上toString和valueOf后会变成啥样，但我们还不知道它们各自在什么时候使用<br>那我们来看看</p><p>从上一篇中我们发现，双等号一边如果是引用类型的话首先会使用valueOf(),再使用toString()</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = []arr.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;arrtoString&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>&#125;arr.valueOf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;arrvalueOf&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span> &#125;<span class="hljs-built_in">console</span>.log(arr)<span class="hljs-comment">//直接返回arr本身，不进行转换</span>alert(arr)<span class="hljs-comment">//只用toString</span><span class="hljs-built_in">Number</span>(arr)<span class="hljs-comment">//先用valueOf再用toString</span><span class="hljs-built_in">String</span>(arr)<span class="hljs-comment">//只用toString</span><span class="hljs-built_in">console</span>.log(+arr)<span class="hljs-comment">//先用valueOf再用toString</span></code></pre><pre><code class="hljs js"><span class="hljs-keyword">let</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;fn.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fntoString&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>&#125;fn.valueOf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fnvalueOf&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>&#125;<span class="hljs-built_in">console</span>.log(fn)<span class="hljs-comment">//先用toString再用valueOf</span>alert(fn)<span class="hljs-comment">//用toString</span><span class="hljs-built_in">Number</span>(fn)<span class="hljs-comment">//先用valueOf再用toString</span><span class="hljs-built_in">String</span>(fn)<span class="hljs-comment">//只用toString</span><span class="hljs-built_in">console</span>.log(+fn)<span class="hljs-comment">//先用valueOf再用toString</span></code></pre><pre><code class="hljs js"><span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()date.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;datetoString&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>&#125;date.valueOf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;datevalueOf&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>&#125;<span class="hljs-built_in">console</span>.log(date)<span class="hljs-comment">//执行两次toString(),不太明白</span>alert(date)<span class="hljs-comment">//用一次toString</span><span class="hljs-built_in">Number</span>(date)<span class="hljs-comment">//先用valueOf再用toString</span><span class="hljs-built_in">String</span>(date)<span class="hljs-comment">//只用toString</span><span class="hljs-built_in">console</span>.log(+date)<span class="hljs-comment">//先用valueOf再用toString</span></code></pre><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;obj.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;objtoString&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>&#125;obj.valueOf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;objvalueOf&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>&#125;<span class="hljs-built_in">console</span>.log(obj)<span class="hljs-comment">//直接展现，不用任何转换</span>alert(obj)<span class="hljs-comment">//用一次toString</span><span class="hljs-built_in">Number</span>(obj)<span class="hljs-comment">//先用valueOf再用toString</span><span class="hljs-built_in">String</span>(obj)<span class="hljs-comment">//只用toString</span><span class="hljs-built_in">console</span>.log(+obj)<span class="hljs-comment">//先用valueOf再用toString</span></code></pre><p>所以可以得出结论了，</p><ul><li>console.log()直接打印的话中除了object直接打印、date执行两次toString,其余都toString再用valueOf,</li><li>alert(),String()中都只使用了toString()，</li><li>如果需要进行运算，都是先进行valueOf再toString</li><li>总而言之，与数字、运算有关的用valueOf优先,其他都是toString优先</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;各种引用对象都继承或最终继承于 Object ，使用着Object的原型，所以它们不管何时都有 toString() 和 valueOf() 方法，只不过有些类型的原型重写了这两个方法，比如 Function 实例的原型就重写了 toString() 方法，按照原型链的规则，如果方法和属性在原型链的各原型中有重名，则优先使用最近的方法和属性。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;先看看常用的引用类型重写了这两个方法的情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function 重写了 toString()&lt;/li&gt;
&lt;li&gt;Date 重写了 toString() 也重写了 valueOf()&lt;/li&gt;
&lt;li&gt;Array 重写了 toString()&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="javascript" scheme="https://tangxiaomi.top/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://tangxiaomi.top/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title> Mac怎么刷新DNS缓存</title>
    <link href="https://tangxiaomi.top/2021/06/08/macos/579cc29de2/"/>
    <id>https://tangxiaomi.top/2021/06/08/macos/579cc29de2/</id>
    <published>2021-06-08T09:04:03.000Z</published>
    <updated>2021-06-24T01:47:53.076Z</updated>
    
    <content type="html"><![CDATA[<p>请使用以下“终端”命令来还原 DNS 缓存设置：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo killall -HUP mDNSResponder</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;请使用以下“终端”命令来还原 DNS 缓存设置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs ebnf&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;sudo killall -HUP mDNSResponder&lt;/span&gt;&lt;/code&gt;&lt;/pre</summary>
      
    
    
    
    <category term="macos" scheme="https://tangxiaomi.top/categories/macos/"/>
    
    
    <category term="macos" scheme="https://tangxiaomi.top/tags/macos/"/>
    
  </entry>
  
  <entry>
    <title> 从 Event Loop 角度解读 Vue NextTick 源码</title>
    <link href="https://tangxiaomi.top/2021/06/08/vue/cdb7936afb/"/>
    <id>https://tangxiaomi.top/2021/06/08/vue/cdb7936afb/</id>
    <published>2021-06-08T09:04:03.000Z</published>
    <updated>2021-06-24T01:47:53.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解读背景"><a href="#解读背景" class="headerlink" title="解读背景"></a>解读背景</h2><ol><li>在学习 <strong>vue</strong> 源码，<strong>nextTick</strong> 方法借助了浏览器的 <strong>event loop</strong> 事件循环做到了异步更新。</li><li>在公司面试的时候，笔试题最喜欢出关于 <strong>JavaScript</strong> 运行机制，<strong>Promise/A+</strong> 等关于 <strong>event loop</strong> 线程的题目。</li><li>学会 <strong>nextTick</strong> 原理帮助定位 <strong>BUG</strong> , 使用 <strong>Vue</strong> 会更加灵活。</li></ol><h2 id="什么是-event-loop"><a href="#什么是-event-loop" class="headerlink" title="什么是 event loop"></a>什么是 event loop</h2><p><img src="/images/640.gif"></p><ol><li>先执行同步阻塞任务，同步任务会等待上一个执行完毕以后执行下一个，当同步任务执行完毕，再执行异步任务，遇到异步任务会将异步任务的回调函数注册在异步任务队列里。注意，如果主线程上没有同步任务会直接调用异步任务的微任务。</li><li>执行宏任务，遇到微任务将都添加到微任务队列里。</li><li>开始执行微任务队列，当宏任务执行完后执行微任务队列，直到微任务队列全部执行完，微任务队列为空。</li><li>执行宏任务，如果在执行宏任务期间有微任务，将微任务添加到微任务队列里，执行完宏任务之后执行微任务，直到微任务队列全部执行完。</li><li>继续执行宏任务队列。</li></ol><p><strong>重复2, 3, 4，5……直到宏微任务为空。</strong></p><h2 id="nextTick-的实现原理"><a href="#nextTick-的实现原理" class="headerlink" title="$nextTick 的实现原理"></a>$nextTick 的实现原理</h2><p>从字面意思理解，<strong>next</strong> 下一个，<strong>tick</strong> 滴答（钟表）来源于定时器的周期性中断（输出脉冲），一次中断表示一个 <strong>tick</strong>，也被称做一个“时钟滴答”），<strong>nextTick</strong> 顾名思义就是下一个时钟滴答。看源码，在 <strong>Vue 2.x</strong> 版本中，<strong>nextTick</strong> 在 <strong>src\core\util</strong> 中的一个单独的文件 <strong>next-tick.js</strong> ，可见 <strong>nextTick</strong> 的重要性，虽然短短 <strong>200</strong> 多行，尤大却单独创建一个文件去维护。<br>接下来我们来看整个文件。</p><ol><li>声明了三个全局变量，<strong>callbacks: [] ，pending: Boolean，timerFunc: undefined</strong>。</li><li>声明了一个函数 <strong>flushCallbacks</strong>。</li><li>一堆 **if，else if **判断。</li><li>抛出了一个函数 <strong>nextTick</strong>。</li></ol><h2 id="nextTick-函数"><a href="#nextTick-函数" class="headerlink" title="nextTick 函数"></a>nextTick 函数</h2><p><img src="/images/640.png"></p><ol><li>声明一个局部变量 <strong>_resolve</strong> 。</li><li>把所有回调函数压进 <strong>callbacks</strong> 中，以栈的形式的存储所有 <strong>callback</strong>。</li><li>当 <strong>pending</strong> 为 <strong>false</strong> 时，执行 <strong>timerFunc</strong> 函数。</li><li>当没有 <strong>callback</strong> 的时候，返回一个 <strong>Promise</strong> 的调用方式，可以用 <strong>.then</strong> 接收。</li></ol><h2 id="timerFunc-函数"><a href="#timerFunc-函数" class="headerlink" title="timerFunc 函数"></a>timerFunc 函数</h2><p>我们开始说了，timerFunc 为全局变量，现在调用 timerFunc ，timerFunc 是什么时候被赋值为一个函数，并且函数里执行代码又是什么？</p><p><img src="/images/640%202.png"></p><p>我们看到，这段判断代码总共有四个分支，四个分支里对 timerFunc 有不同的赋值，我们先来看第一个分支。</p><h3 id="Promise-分支"><a href="#Promise-分支" class="headerlink" title="Promise 分支"></a>Promise 分支</h3><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Promise</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class="hljs-built_in">Promise</span>)) &#123;  <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve()  timerFunc = <span class="hljs-function">() =&gt;</span> &#123;    p.then(flushCallbacks)    <span class="hljs-comment">// In problematic UIWebViews, Promise.then doesn&#x27;t completely break, but</span>    <span class="hljs-comment">// it can get stuck in a weird state where callbacks are pushed into the</span>    <span class="hljs-comment">// microtask queue but the queue isn&#x27;t being flushed, until the browser</span>    <span class="hljs-comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span>    <span class="hljs-comment">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span>    <span class="hljs-keyword">if</span> (isIOS) <span class="hljs-built_in">setTimeout</span>(noop)  &#125;  isUsingMicroTask = <span class="hljs-literal">true</span>&#125;</code></pre><ol><li>判断环境是否支持 Promise 并且 <strong>Promise</strong> 是否为原生。</li><li>使用 <strong>Promise</strong> 异步调用 <strong>flushCallbacks</strong> 函数。</li><li>当执行环境是 <strong>iPhone</strong> 等，使用 <strong>setTimeout</strong> 异步调用 <strong>noop</strong> ，<strong>iOS</strong> <strong>中在一些异常的webview</strong> 中，<strong>promise</strong> 结束后任务队列并没有刷新所以强制执行 <strong>setTimeout</strong> 刷新任务队列。</li></ol><h3 id="MutationObserver-分支"><a href="#MutationObserver-分支" class="headerlink" title="MutationObserver 分支"></a>MutationObserver 分支</h3><pre><code class="hljs js"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isIE &amp;&amp; <span class="hljs-keyword">typeof</span> MutationObserver !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; (  isNative(MutationObserver) ||  <span class="hljs-comment">// PhantomJS and iOS 7.x</span>  MutationObserver.toString() === <span class="hljs-string">&#x27;[object MutationObserverConstructor]&#x27;</span>)) &#123;  <span class="hljs-comment">// Use MutationObserver where native Promise is not available,</span>  <span class="hljs-comment">// e.g. PhantomJS, iOS7, Android 4.4</span>  <span class="hljs-comment">// (#6466 MutationObserver is unreliable in IE11)</span>  <span class="hljs-keyword">let</span> counter = <span class="hljs-number">1</span>  <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> MutationObserver(flushCallbacks)  <span class="hljs-keyword">const</span> textNode = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-built_in">String</span>(counter))  observer.observe(textNode, &#123;    <span class="hljs-attr">characterData</span>: <span class="hljs-literal">true</span>  &#125;)  timerFunc = <span class="hljs-function">() =&gt;</span> &#123;    counter = (counter + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>    textNode.data = <span class="hljs-built_in">String</span>(counter)  &#125;  isUsingMicroTask = <span class="hljs-literal">true</span>&#125;</code></pre><ol><li>对非IE浏览器和是否可以使用 <strong>HTML5</strong> 新特性 <strong>MutationObserver</strong> 进行判断。</li><li>实例一个 <strong>MutationObserver</strong> 对象，这个对象主要是对浏览器 <strong>DOM</strong> 变化进行监听，当实例化 <strong>MutationObserver</strong> 对象并且执行对象 <strong>observe</strong>，设置 <strong>DOM</strong> 节点发生改变时自动触发回调。</li><li>把 <strong>timerFunc</strong> 赋值为一个改变 <strong>DOM</strong> 节点的方法，当 <strong>DOM</strong> 节点发生改变，触发 <strong>flushCallbacks</strong> 。（这里其实就是想用利用 <strong>MutationObserver</strong> 的特性进行异步操作）</li></ol><h3 id="setImmediate-分支"><a href="#setImmediate-分支" class="headerlink" title="setImmediate 分支"></a>setImmediate 分支</h3><pre><code class="hljs js"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> setImmediate !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;  <span class="hljs-comment">// Fallback to setImmediate.</span>  <span class="hljs-comment">// Technically it leverages the (macro) task queue,</span>  <span class="hljs-comment">// but it is still a better choice than setTimeout.</span>  timerFunc = <span class="hljs-function">() =&gt;</span> &#123;    setImmediate(flushCallbacks)  &#125;&#125;</code></pre><ol><li>判断 <strong>setImmediate</strong> 是否存在，<strong>setImmediate</strong> 是高版本 <strong>IE</strong> （IE10+） 和 <strong>edge</strong> 才支持的。</li><li>如果存在，传入 <strong>flushCallbacks</strong> 执行 <strong>setImmediate</strong> 。</li></ol><h3 id="setTimeout-分支"><a href="#setTimeout-分支" class="headerlink" title="setTimeout 分支"></a>setTimeout 分支</h3><pre><code class="hljs coffeescript"><span class="hljs-keyword">else</span> &#123;  <span class="hljs-regexp">//</span> Fallback to <span class="hljs-built_in">setTimeout</span>.<span class="hljs-function">  <span class="hljs-title">timerFunc</span> = <span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(flushCallbacks, <span class="hljs-number">0</span>)  &#125;&#125;</code></pre><ol><li>当以上所有分支异步 <strong>api</strong> 都不支持的时候，使用 <strong>macro</strong> <strong>task</strong> （宏任务）的 <strong>setTimeout</strong> 执行 <strong>flushCallbacks</strong> 。</li></ol><h3 id="执行降级"><a href="#执行降级" class="headerlink" title="执行降级"></a>执行降级</h3><p>我们可以发现，给 timerFunc 赋值是一个降级的过程。为什么呢，因为 Vue 在执行的过程中，执行环境不同，所以要适配环境。</p><p><img src="/images/640%203.png"></p><p>这张图便于我们更清晰的了解到降级的过程。</p><h2 id="flushCallbacks-函数"><a href="#flushCallbacks-函数" class="headerlink" title="flushCallbacks 函数"></a>flushCallbacks 函数</h2><pre><code class="hljs nix">function flushCallbacks () &#123;  <span class="hljs-attr">pending</span> = <span class="hljs-literal">false</span>  const <span class="hljs-attr">copies</span> = callbacks.slice(<span class="hljs-number">0</span>)  callbacks.<span class="hljs-attr">length</span> = <span class="hljs-number">0</span>  for (<span class="hljs-keyword">let</span> <span class="hljs-attr">i</span> = <span class="hljs-number">0</span>; i &lt; copies.length; i++) &#123;    copies[i]()  &#125;&#125;</code></pre><p>循环遍历，按照 <strong>队列</strong> 数据结构 <strong>“先进先出”</strong> 的原则，逐一执行所有 <strong>callback</strong> 。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里就全部讲完了，<strong>nextTick</strong> 的原理就是利用 <strong>Event</strong> <strong>loop</strong> 事件线程去异步重新渲染，分支判断首要选择 <strong>Promise</strong> 的原因是当同步JS代码执行完毕，执行栈清空会首先查看 <strong>micro</strong> <strong>task</strong> （微任务）队列是否为空，不为空首先执行微任务。在我们 <strong>DOM</strong> 依赖数据发生变化的时候，会异步重新渲染 <strong>DOM</strong> ，但是比如像 <strong>echarts</strong> ，<strong>canvas</strong>……这些 <strong>Vue</strong> 无法在初始状态下收集依赖的 <strong>DOM</strong> ，我们就需要手动执行 <strong>nextTick</strong> 方法使其重新渲染。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;解读背景&quot;&gt;&lt;a href=&quot;#解读背景&quot; class=&quot;headerlink&quot; title=&quot;解读背景&quot;&gt;&lt;/a&gt;解读背景&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在学习 &lt;strong&gt;vue&lt;/strong&gt; 源码，&lt;strong&gt;nextTick&lt;/strong&gt; 方法</summary>
      
    
    
    
    <category term="vue" scheme="https://tangxiaomi.top/categories/vue/"/>
    
    
    <category term="vue" scheme="https://tangxiaomi.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title> 如何实现浏览器内多个标签页之间的通信？</title>
    <link href="https://tangxiaomi.top/2021/06/07/interview/0bab1e5161/"/>
    <id>https://tangxiaomi.top/2021/06/07/interview/0bab1e5161/</id>
    <published>2021-06-07T02:47:41.000Z</published>
    <updated>2021-06-24T01:47:53.072Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本题主要考察数据存储的知识，数据存储有本地和服务器存储两种方式。这里主要讲解用本地存储方式解决。即调用 localStorage、Cookie等本地存储方式。  </p></blockquote><h2 id="第一种-调用localStorage"><a href="#第一种-调用localStorage" class="headerlink" title="第一种 调用localStorage"></a>第一种 调用localStorage</h2><p>在一个标签页里面使用 localStorage.setItem(key,value)添加（修改、删除）内容；<br>在另一个标签页里面监听 storage 事件。<br>即可得到 localstorge 存储的值，实现不同标签页之间的通信。</p><p>标签页1：</p><pre><code class="hljs js">&lt;input id=<span class="hljs-string">&quot;name&quot;</span>&gt;  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span>  </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">  </span></span><span class="javascript"><span class="xml">    $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    </span></span><span class="javascript"><span class="xml">        $(<span class="hljs-string">&quot;#btn&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    </span></span><span class="javascript"><span class="xml">            <span class="hljs-keyword">var</span> name=$(<span class="hljs-string">&quot;#name&quot;</span>).val();    </span></span><span class="javascript"><span class="xml">            <span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&quot;name&quot;</span>, name);   </span></span><span class="javascript"><span class="xml">        &#125;);    </span></span><span class="javascript"><span class="xml">    &#125;);    </span></span><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  </span></code></pre><p>标签页2：</p><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;      $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;           <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;storage&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>&#123;                <span class="hljs-built_in">console</span>.log(event.key + <span class="hljs-string">&quot;=&quot;</span> + event.newValue);            &#125;);         &#125;);  &lt;/script&gt;</code></pre><h2 id="第二种-调用cookie-setInterval"><a href="#第二种-调用cookie-setInterval" class="headerlink" title="第二种 调用cookie+setInterval()"></a>第二种 调用cookie+setInterval()</h2><p>将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息。</p><p>页面1：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">  </span><span class="javascript">    $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    </span><span class="javascript">        $(<span class="hljs-string">&quot;#btn&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    </span><span class="javascript">            <span class="hljs-keyword">var</span> name=$(<span class="hljs-string">&quot;#name&quot;</span>).val();    </span><span class="javascript">            <span class="hljs-built_in">document</span>.cookie=<span class="hljs-string">&quot;name=&quot;</span>+name;    </span><span class="javascript">        &#125;);    </span><span class="javascript">    &#125;);    </span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>页面2：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">  </span><span class="javascript">    $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;   </span><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCookie</span>(<span class="hljs-params">key</span>) </span>&#123;    </span><span class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&quot;&#123;\&quot;&quot;</span> + <span class="hljs-built_in">document</span>.cookie.replace(<span class="hljs-regexp">/;\s+/gim</span>,<span class="hljs-string">&quot;\&quot;,\&quot;&quot;</span>).replace(<span class="hljs-regexp">/=/gim</span>, <span class="hljs-string">&quot;\&quot;:\&quot;&quot;</span>) + <span class="hljs-string">&quot;\&quot;&#125;&quot;</span>)[key];    </span><span class="javascript">        &#125;     </span><span class="javascript">        <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    </span><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;name=&quot;</span> + getCookie(<span class="hljs-string">&quot;name&quot;</span>));    </span><span class="javascript">        &#125;, <span class="hljs-number">10000</span>);    </span><span class="javascript">    &#125;);  </span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本题主要考察数据存储的知识，数据存储有本地和服务器存储两种方式。这里主要讲解用本地存储方式解决。即调用 localStorage、Cookie等本地存储方式。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第一种-调用localStora</summary>
      
    
    
    
    <category term="Interview" scheme="https://tangxiaomi.top/categories/Interview/"/>
    
    
    <category term="Interview" scheme="https://tangxiaomi.top/tags/Interview/"/>
    
    <category term="javascript" scheme="https://tangxiaomi.top/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title> HTML5的文件离线储存怎么使用，工作原理是什么？</title>
    <link href="https://tangxiaomi.top/2021/06/07/interview/de0df6d619/"/>
    <id>https://tangxiaomi.top/2021/06/07/interview/de0df6d619/</id>
    <published>2021-06-07T02:31:02.000Z</published>
    <updated>2021-06-24T01:47:53.076Z</updated>
    
    <content type="html"><![CDATA[<p>HTML5离线存储存储功能非常强大，它的作用是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，自动更新缓存数据。</p><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>HTML5的离线存储是基于一个新建的.appcache文件的，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p><h2 id="怎么用："><a href="#怎么用：" class="headerlink" title="怎么用："></a>怎么用：</h2><p>首先，在html页面头部加入一个manifest的属性:</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">manifest</span> = <span class="hljs-string">&quot;cache.manifest&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>然后书写cache.manifest文件：</p><pre><code class="hljs avrasm">CACHE MANIFEST<span class="hljs-meta">#v0.11</span><span class="hljs-symbol">CACHE:</span>js/app.jscss/style.css<span class="hljs-symbol">NETWORK:</span>resourse/logo.png<span class="hljs-symbol">FALLBACK:</span>/ /offline.html</code></pre><p>manifest （即 .appcache 文件）文件是简单的文本文件，可分为三个部分：</p><h2 id="CACHE-："><a href="#CACHE-：" class="headerlink" title="CACHE ："></a>CACHE ：</h2><p>在此标题下列出的文件将在首次下载后进行缓存。（由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来）</p><h2 id="NETWORK-："><a href="#NETWORK-：" class="headerlink" title="NETWORK ："></a>NETWORK ：</h2><p>在此标题下列出的文件需要与服务器的连接，且不会被缓存，离线时无法使用。 <br>可以使用 “*” 来指示所有其他资源/文件都需要因特网连接：</p><pre><code class="hljs avrasm"><span class="hljs-symbol">NETWORK:</span> *</code></pre><p>如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。</p><h2 id="FALLBACK："><a href="#FALLBACK：" class="headerlink" title="FALLBACK："></a>FALLBACK：</h2><p>在此标题下列出的文件规定当页面无法访问时的回退页面。比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html。</p><h2 id="浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？"><a href="#浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？" class="headerlink" title="浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？"></a>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</h2><p>在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。<br>离线的情况下，浏览器就直接使用离线存储的资源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;HTML5离线存储存储功能非常强大，它的作用是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，自动更新缓存数据。&lt;/p&gt;
&lt;h2 id=&quot;原理：&quot;&gt;&lt;a href=&quot;#原理：&quot; class=&quot;headerlink&quot; title=&quot;原理：&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="interview" scheme="https://tangxiaomi.top/categories/interview/"/>
    
    
    <category term="interview" scheme="https://tangxiaomi.top/tags/interview/"/>
    
    <category term="html" scheme="https://tangxiaomi.top/tags/html/"/>
    
  </entry>
  
  <entry>
    <title> sessionStorage 、localStorage 和 cookie 之间的区别</title>
    <link href="https://tangxiaomi.top/2021/06/07/interview/a6f7da3b77/"/>
    <id>https://tangxiaomi.top/2021/06/07/interview/a6f7da3b77/</id>
    <published>2021-06-07T02:23:33.000Z</published>
    <updated>2021-06-24T01:47:53.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2><p>都是保存在浏览器端，且同源的。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。</li><li>存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li><li>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。</li><li>作用域不同，sessionStorage<strong>不在</strong>不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。</li><li>Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。</li><li>Web Storage 的 api 接口使用更方便。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;共同点&quot;&gt;&lt;a href=&quot;#共同点&quot; class=&quot;headerlink&quot; title=&quot;共同点&quot;&gt;&lt;/a&gt;共同点&lt;/h2&gt;&lt;p&gt;都是保存在浏览器端，且同源的。&lt;/p&gt;
&lt;h2 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="Interview" scheme="https://tangxiaomi.top/categories/Interview/"/>
    
    
    <category term="Interview" scheme="https://tangxiaomi.top/tags/Interview/"/>
    
    <category term="javascript" scheme="https://tangxiaomi.top/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title> src 与 href 的区别</title>
    <link href="https://tangxiaomi.top/2021/06/07/interview/f426fb17e9/"/>
    <id>https://tangxiaomi.top/2021/06/07/interview/f426fb17e9/</id>
    <published>2021-06-07T02:13:24.000Z</published>
    <updated>2021-06-24T01:47:53.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="src"><a href="#src" class="headerlink" title="src"></a>src</h2><ul><li>src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。</li><li>src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素</li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span> =<span class="hljs-string">&quot;js.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>  当浏览器解析到该元素时，<strong>会暂停其他资源的下载和处理</strong>，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。<strong>这也是为什么将js脚本放在底部而不是头部</strong> </p><h2 id="href"><a href="#href" class="headerlink" title="href"></a>href</h2><ul><li>href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加</li></ul><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;common.css&quot;</span> <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>/&gt;</code></pre><ul><li> 那么浏览器会识别该文档为css文件，就会并行下载资源并且<strong>不会</strong>停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;src&quot;&gt;&lt;a href=&quot;#src&quot; class=&quot;headerlink&quot; title=&quot;src&quot;&gt;&lt;/a&gt;src&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。&lt;/li&gt;
&lt;li&gt;src是source的缩写，指</summary>
      
    
    
    
    <category term="interview" scheme="https://tangxiaomi.top/categories/interview/"/>
    
    
    <category term="interview" scheme="https://tangxiaomi.top/tags/interview/"/>
    
    <category term="html" scheme="https://tangxiaomi.top/tags/html/"/>
    
  </entry>
  
  <entry>
    <title> vue3.0 是如何变快的？</title>
    <link href="https://tangxiaomi.top/2021/06/06/vue3/ac6163e9d3/"/>
    <id>https://tangxiaomi.top/2021/06/06/vue3/ac6163e9d3/</id>
    <published>2021-06-06T07:53:03.000Z</published>
    <updated>2021-06-24T01:47:53.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="diff算法优化"><a href="#diff算法优化" class="headerlink" title="diff算法优化"></a>diff算法优化</h2><blockquote><p>Vue2中的虚拟 <code>dom</code> 是进行全量的对比<br>Vue3新增了静态标记<code>(PatchFlag)</code><br>在与上次虚拟节点进行对比时候,只对比带有 <code>patch flash</code> 的节点<br>并且可以通过 <code>flag</code> 的信息得知当前节点要对比的具体内容  </p></blockquote><a id="more"></a><p><img src="/images/20210120113952295.png"></p><p><a href="https://template-explorer.vuejs.org/#%3Cdiv%20id%3D%22app%22%3E%7B%7B%20msg%20%7D%7D%3C%2Fdiv%3E">vue2.0 代码转换</a><br><a href="https://vue-next-template-explorer.netlify.app/#%7B%22src%22%3A%22%3Cdiv%3EHello%20World!%3C%2Fdiv%3E%22%2C%22options%22%3A%7B%22mode%22%3A%22module%22%2C%22filename%22%3A%22Foo.vue%22%2C%22prefixIdentifiers%22%3Afalse%2C%22hoistStatic%22%3Afalse%2C%22cacheHandlers%22%3Afalse%2C%22scopeId%22%3Anull%2C%22inline%22%3Afalse%2C%22ssrCssVars%22%3A%22%7B%20color%20%7D%22%2C%22compatConfig%22%3A%7B%22MODE%22%3A3%7D%2C%22whitespace%22%3A%22condense%22%2C%22bindingMetadata%22%3A%7B%22TestComponent%22%3A%22setup-const%22%2C%22setupRef%22%3A%22setup-ref%22%2C%22setupConst%22%3A%22setup-const%22%2C%22setupLet%22%3A%22setup-let%22%2C%22setupMaybeRef%22%3A%22setup-maybe-ref%22%2C%22setupProp%22%3A%22props%22%2C%22vMySetupDir%22%3A%22setup-const%22%7D%7D%7D">vue3.0代码转换</a></p><h3 id="vue2-0转换"><a href="#vue2-0转换" class="headerlink" title="vue2.0转换"></a>vue2.0转换</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-function"><span class="hljs-title">with</span>(<span class="hljs-params"><span class="hljs-built_in">this</span></span>)</span> &#123;    <span class="hljs-keyword">return</span> _c(<span class="hljs-string">&#x27;div&#x27;</span>, [_c(<span class="hljs-string">&#x27;p&#x27;</span>, [_v(<span class="hljs-string">&quot;我是段落&quot;</span>)]), _c(<span class="hljs-string">&#x27;p&#x27;</span>, [_v(<span class="hljs-string">&quot;我是段落&quot;</span>)]), _c(<span class="hljs-string">&#x27;p&#x27;</span>, [      _v(<span class="hljs-string">&quot;我是段落&quot;</span>)    ]), _c(<span class="hljs-string">&#x27;span&#x27;</span>, [_v(_s(msg))])])  &#125;&#125;</code></pre><h3 id="vue3-0转换"><a href="#vue3-0转换" class="headerlink" title="vue3.0转换"></a>vue3.0转换</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createVNode <span class="hljs-keyword">as</span> _createVNode, toDisplayString <span class="hljs-keyword">as</span> _toDisplayString, openBlock <span class="hljs-keyword">as</span> _openBlock, createBlock <span class="hljs-keyword">as</span> _createBlock &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;  <span class="hljs-keyword">return</span> (_openBlock(), _createBlock(<span class="hljs-string">&quot;div&quot;</span>, <span class="hljs-literal">null</span>, [    _createVNode(<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;我是段落&quot;</span>),    _createVNode(<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;我是段落&quot;</span>),    _createVNode(<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;我是段落&quot;</span>),    _createVNode(<span class="hljs-string">&quot;span&quot;</span>, <span class="hljs-literal">null</span>, _toDisplayString(_ctx.msg), <span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span>)  ]))&#125;<span class="hljs-comment">// Check the console for the AST</span></code></pre><h2 id="hoistStatus静态提升"><a href="#hoistStatus静态提升" class="headerlink" title="hoistStatus静态提升"></a>hoistStatus静态提升</h2><blockquote><p>Vue2中无论元素是否参与更新,每次都会重新创建,然后渲染<br>Vue3对于不参加更新的元素,会做静态提升,只会被创建一次,在渲染时直接<strong>复用</strong>第一次创建的,以达到性能提升,速度变快…  </p></blockquote><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createVNode <span class="hljs-keyword">as</span> _createVNode, toDisplayString <span class="hljs-keyword">as</span> _toDisplayString, openBlock <span class="hljs-keyword">as</span> _openBlock, createBlock <span class="hljs-keyword">as</span> _createBlock &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span><span class="hljs-keyword">const</span> _hoisted_1 = <span class="hljs-comment">/*#__PURE__*/</span>_createVNode(<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;我是段落&quot;</span>, -<span class="hljs-number">1</span> <span class="hljs-comment">/* HOISTED */</span>)<span class="hljs-keyword">const</span> _hoisted_2 = <span class="hljs-comment">/*#__PURE__*/</span>_createVNode(<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;我是段落&quot;</span>, -<span class="hljs-number">1</span> <span class="hljs-comment">/* HOISTED */</span>)<span class="hljs-keyword">const</span> _hoisted_3 = <span class="hljs-comment">/*#__PURE__*/</span>_createVNode(<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;我是段落&quot;</span>, -<span class="hljs-number">1</span> <span class="hljs-comment">/* HOISTED */</span>)<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;  <span class="hljs-keyword">return</span> (_openBlock(), _createBlock(<span class="hljs-string">&quot;div&quot;</span>, <span class="hljs-literal">null</span>, [    _hoisted_1,    _hoisted_2,    _hoisted_3,    _createVNode(<span class="hljs-string">&quot;span&quot;</span>, <span class="hljs-literal">null</span>, _toDisplayString(_ctx.msg), <span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span>)  ]))&#125;<span class="hljs-comment">// Check the console for the AST</span></code></pre><h2 id="cacheHandlers事件侦听器缓存"><a href="#cacheHandlers事件侦听器缓存" class="headerlink" title="cacheHandlers事件侦听器缓存"></a>cacheHandlers事件侦听器缓存</h2><blockquote><p>默认情况onClick会被视为动态绑定,所以每次都会去追踪它的变化<br>但是因为是统一和函数,所以没有追踪变化,直接缓存起来复用即可  </p></blockquote><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;myFn&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>未开启事件监听缓缓存</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-function"><span class="hljs-title">with</span>(<span class="hljs-params"><span class="hljs-built_in">this</span></span>)</span> &#123;    <span class="hljs-keyword">return</span> _c(<span class="hljs-string">&#x27;div&#x27;</span>, [_c(<span class="hljs-string">&#x27;button&#x27;</span>, &#123;      <span class="hljs-attr">on</span>: &#123;        <span class="hljs-string">&quot;onclick&quot;</span>: myFn      &#125;    &#125;, [_v(<span class="hljs-string">&quot;按钮&quot;</span>)])])  &#125;&#125;</code></pre><p>开启事件监听缓存</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createVNode <span class="hljs-keyword">as</span> _createVNode, openBlock <span class="hljs-keyword">as</span> _openBlock, createBlock <span class="hljs-keyword">as</span> _createBlock &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;  <span class="hljs-keyword">return</span> (_openBlock(), _createBlock(<span class="hljs-string">&quot;div&quot;</span>, <span class="hljs-literal">null</span>, [    _createVNode(<span class="hljs-string">&quot;button&quot;</span>, &#123;      <span class="hljs-attr">onOnclick</span>: _cache[<span class="hljs-number">1</span>] || (_cache[<span class="hljs-number">1</span>] = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> (_ctx.myFn &amp;&amp; _ctx.myFn(...args)))    &#125;, <span class="hljs-string">&quot;按钮&quot;</span>, <span class="hljs-number">32</span> <span class="hljs-comment">/* HYDRATE_EVENTS */</span>)  ]))&#125;<span class="hljs-comment">// Check the console for the AST</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;diff算法优化&quot;&gt;&lt;a href=&quot;#diff算法优化&quot; class=&quot;headerlink&quot; title=&quot;diff算法优化&quot;&gt;&lt;/a&gt;diff算法优化&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Vue2中的虚拟 &lt;code&gt;dom&lt;/code&gt; 是进行全量的对比&lt;br&gt;Vue3新增了静态标记&lt;code&gt;(PatchFlag)&lt;/code&gt;&lt;br&gt;在与上次虚拟节点进行对比时候,只对比带有 &lt;code&gt;patch flash&lt;/code&gt; 的节点&lt;br&gt;并且可以通过 &lt;code&gt;flag&lt;/code&gt; 的信息得知当前节点要对比的具体内容  &lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="vue3" scheme="https://tangxiaomi.top/categories/vue3/"/>
    
    
    <category term="vue3" scheme="https://tangxiaomi.top/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title> vue3.0 六大亮点</title>
    <link href="https://tangxiaomi.top/2021/06/06/vue3/11682f46f1/"/>
    <id>https://tangxiaomi.top/2021/06/06/vue3/11682f46f1/</id>
    <published>2021-06-06T07:36:37.000Z</published>
    <updated>2021-06-24T01:47:53.076Z</updated>
    
    <content type="html"><![CDATA[<ol><li>performance: 性能比vue2.x块1.2~2倍;</li><li>Tree shaking support: 按需编译，体积比vue2.x更小;</li><li>Composition API: 组合API（类似React Hooks）;</li><li>Better TypeScript support: 更好的 ts 支持;</li><li>Custom Render API: 暴露了自定义渲染的API ;</li><li>Fragment, Teleport(Protal): 更先进的组件 ;</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;performance: 性能比vue2.x块1.2~2倍;&lt;/li&gt;
&lt;li&gt;Tree shaking support: 按需编译，体积比vue2.x更小;&lt;/li&gt;
&lt;li&gt;Composition API: 组合API（类似React Hooks）;&lt;/li</summary>
      
    
    
    
    <category term="vue3" scheme="https://tangxiaomi.top/categories/vue3/"/>
    
    
    <category term="vue3" scheme="https://tangxiaomi.top/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title> 修改 hosts</title>
    <link href="https://tangxiaomi.top/2021/06/05/macos/c6ecda4c57/"/>
    <id>https://tangxiaomi.top/2021/06/05/macos/c6ecda4c57/</id>
    <published>2021-06-05T06:51:22.000Z</published>
    <updated>2021-06-24T01:47:53.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h2><ul><li>打开目录：C:/Windows/System32/drivers/etc/</li><li>找到hosts文件，使用管理员模式打开记事本</li><li>将hosts文件拖到管理员模式下的记事本中，然后在文件尾部添加以下文本：<pre><code class="hljs accesslog"><span class="hljs-number">151.101.0.133</span> raw.githubusercontent.com</code></pre></li><li>保存文件（可能还要重启一下计算机？），就解决了。</li></ul><h2 id="Mac-OS-系统"><a href="#Mac-OS-系统" class="headerlink" title="Mac OS 系统"></a>Mac OS 系统</h2><ul><li>打开终端（Terminal），默认位置在 启动台 –&gt; 其它 –&gt; 终端</li><li>在终端中，输入以下命令，使用vim修改hosts文件（会要求输入计算机密码）：<pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/etc/</span>hosts</code></pre></li><li>确保输入法为英文模式，按一下键盘上的 i 键</li><li>使用方向键，将光标移动至文本尾部，然后再文件尾部添加以下文本：<pre><code class="hljs accesslog"><span class="hljs-number">151.101.0.133</span> raw.githubusercontent.com</code></pre></li><li>按一下esc，然后输入 :wq! ,然后回车</li><li>关闭终端，问题解决。</li></ul><h2 id="Linux-系统"><a href="#Linux-系统" class="headerlink" title="Linux 系统"></a>Linux 系统</h2><ul><li>和Mac下操作基本一致。。。。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Windows系统&quot;&gt;&lt;a href=&quot;#Windows系统&quot; class=&quot;headerlink&quot; title=&quot;Windows系统&quot;&gt;&lt;/a&gt;Windows系统&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;打开目录：C:/Windows/System32/drivers/etc</summary>
      
    
    
    
    <category term="macos" scheme="https://tangxiaomi.top/categories/macos/"/>
    
    
    <category term="macos" scheme="https://tangxiaomi.top/tags/macos/"/>
    
  </entry>
  
  <entry>
    <title> Homebrew介绍和使用</title>
    <link href="https://tangxiaomi.top/2021/06/05/macos/709209221b/"/>
    <id>https://tangxiaomi.top/2021/06/05/macos/709209221b/</id>
    <published>2021-06-05T06:43:52.000Z</published>
    <updated>2021-06-24T01:47:53.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Homebrew是什么"><a href="#一、Homebrew是什么" class="headerlink" title="一、Homebrew是什么"></a>一、Homebrew是什么</h2><p>Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。<br>援引 <a href="https://links.jianshu.com/go?to=http://brew.sh/">官方</a> 的一句话：又提示缺少套件啦？别担心，Homebrew 随时守候。Homebrew —— OS X 不可或缺的套件管理器。</p><a id="more"></a><h2 id="二、Homebrew安装"><a href="#二、Homebrew安装" class="headerlink" title="二、Homebrew安装"></a>二、Homebrew安装</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code class="hljs bash">/usr/bin/ruby -e <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></code></pre><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> `brew --prefix`$ rm -rf Cellar$ brew prune$ rm `git ls-files`$ rm -r Library/Homebrew Library/Aliases Library/Formula Library/Contributions$ rm -rf .git$ rm -rf ~/Library/Caches/Homebrew</code></pre><h2 id="三、Homebrew基本使用"><a href="#三、Homebrew基本使用" class="headerlink" title="三、Homebrew基本使用"></a>三、Homebrew基本使用</h2><ul><li><p>安装任意包<br>$ brew install <packageName></p></li><li><p>示例：安装node<br>$ brew install node</p></li><li><p>卸载任意包<br>$ brew uninstall <packageName></p></li><li><p>示例：卸载git<br>$ brew uninstall git</p></li><li><p>查询可用包<br>$ brew search <packageName></p></li><li><p>查看已安装包列表<br>$ brew list</p></li><li><p>查看任意包信息<br>$ brew info <packageName></p></li><li><p>更新Homebrew<br>$ brew update</p></li><li><p>查看Homebrew版本<br>$ brew -v</p></li><li><p>Homebrew帮助信息<br>$ brew -h</p></li></ul><h2 id="四、注意"><a href="#四、注意" class="headerlink" title="四、注意"></a>四、注意</h2><p>在Mac OS X 10.11系统以后，/usr/local/等系统目录下的文件读写是需要系统root权限的，以往的Homebrew安装如果没有指定安装路径，会默认安装在这些需要系统root用户读写权限的目录下，导致有些指令需要添加sudo前缀来执行，比如升级Homebrew需要：</p><pre><code class="hljs bash">$ sudo brew update</code></pre><p>如果你不想每次都使用sudo指令，你有两种方法可以选择:</p><ol><li><p>对/usr/local 目录下的文件读写进行root用户授权</p><pre><code class="hljs bash">$ sudo chown -R <span class="hljs-variable">$USER</span> /usr/<span class="hljs-built_in">local</span></code></pre></li><li><p>示例：</p><pre><code class="hljs bash">$ sudo chown -R gaojun /usr/<span class="hljs-built_in">local</span></code></pre></li><li><p>（推荐）安装Homebrew时对安装路径进行指定，直接安装在不需要系统root用户授权就可以自由读写的目录下</p><pre><code class="hljs bash">&lt;install path&gt; -e <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></code></pre></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、Homebrew是什么&quot;&gt;&lt;a href=&quot;#一、Homebrew是什么&quot; class=&quot;headerlink&quot; title=&quot;一、Homebrew是什么&quot;&gt;&lt;/a&gt;一、Homebrew是什么&lt;/h2&gt;&lt;p&gt;Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。&lt;br&gt;援引 &lt;a href=&quot;https://links.jianshu.com/go?to=http://brew.sh/&quot;&gt;官方&lt;/a&gt; 的一句话：又提示缺少套件啦？别担心，Homebrew 随时守候。Homebrew —— OS X 不可或缺的套件管理器。&lt;/p&gt;</summary>
    
    
    
    <category term="macos" scheme="https://tangxiaomi.top/categories/macos/"/>
    
    
    <category term="macos" scheme="https://tangxiaomi.top/tags/macos/"/>
    
  </entry>
  
  <entry>
    <title> Node.js的版本升级</title>
    <link href="https://tangxiaomi.top/2021/06/04/javascript/b893a6f276/"/>
    <id>https://tangxiaomi.top/2021/06/04/javascript/b893a6f276/</id>
    <published>2021-06-04T03:47:17.000Z</published>
    <updated>2021-06-24T01:47:53.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查看本地node版本"><a href="#查看本地node版本" class="headerlink" title="查看本地node版本"></a>查看本地node版本</h2><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span></code></pre><h2 id="安装n模块"><a href="#安装n模块" class="headerlink" title="安装n模块"></a>安装n模块</h2><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> -g n（mac需要在命令的前面加上sudo）</code></pre><h2 id="升级到指定的版本-最新版本，升级之前，可以执行n-ls（查看可以升级的版本）"><a href="#升级到指定的版本-最新版本，升级之前，可以执行n-ls（查看可以升级的版本）" class="headerlink" title="升级到指定的版本/最新版本，升级之前，可以执行n ls（查看可以升级的版本）"></a>升级到指定的版本/最新版本，升级之前，可以执行n ls（查看可以升级的版本）</h2><pre><code class="hljs excel"><span class="hljs-built_in">n</span> <span class="hljs-number">8.10</span>.<span class="hljs-number">1</span>（版本号）或者你可以安装最新的稳定版本<span class="hljs-built_in">n</span> stable</code></pre><h2 id="4-安装完成以后，检查一下是否升级成功"><a href="#4-安装完成以后，检查一下是否升级成功" class="headerlink" title="4.安装完成以后，检查一下是否升级成功"></a>4.安装完成以后，检查一下是否升级成功</h2><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;查看本地node版本&quot;&gt;&lt;a href=&quot;#查看本地node版本&quot; class=&quot;headerlink&quot; title=&quot;查看本地node版本&quot;&gt;&lt;/a&gt;查看本地node版本&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;hljs crmsh&quot;&gt;&lt;span class</summary>
      
    
    
    
    <category term="javascript" scheme="https://tangxiaomi.top/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://tangxiaomi.top/tags/javascript/"/>
    
    <category term="nodejs" scheme="https://tangxiaomi.top/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title> Linux软连接和硬链接</title>
    <link href="https://tangxiaomi.top/2021/06/04/linux/fa6eb7f527/"/>
    <id>https://tangxiaomi.top/2021/06/04/linux/fa6eb7f527/</id>
    <published>2021-06-04T03:39:40.000Z</published>
    <updated>2021-06-24T01:47:53.076Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/itech/archive/2009/04/10/1433052.html">Linux软连接和硬链接</a></p><h2 id="Linux链接概念"><a href="#Linux链接概念" class="headerlink" title="Linux链接概念"></a>Linux链接概念</h2><p>Linux链接分两种，一种被称为硬链接<code>（Hard Link）</code>，另一种被称为符号链接<code>（Symbolic Link）</code>。默认情况下，ln命令产生硬链接。</p><h3 id="【硬连接】"><a href="#【硬连接】" class="headerlink" title="【硬连接】"></a>【硬连接】</h3><p>硬连接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p><h3 id="【软连接】"><a href="#【软连接】" class="headerlink" title="【软连接】"></a>【软连接】</h3><p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</p><a id="more"></a><h2 id="通过实验加深理解"><a href="#通过实验加深理解" class="headerlink" title="通过实验加深理解"></a>通过实验加深理解</h2><pre><code class="hljs bash">[oracle@Linux]$ touch f1          <span class="hljs-comment"># 创建一个测试文件f1</span>[oracle@Linux]$ ln f1 f2          <span class="hljs-comment"># 创建f1的一个硬连接文件f2</span>[oracle@Linux]$ ln -s f1 f3       <span class="hljs-comment"># 创建f1的一个符号连接文件f3</span>[oracle@Linux]$ ls -li            <span class="hljs-comment"># -i参数显示文件的inode节点信息</span>total 09797648 -rw-r--r--  2 oracle oinstall 0 Apr 21 08:11 f19797648 -rw-r--r--  2 oracle oinstall 0 Apr 21 08:11 f29797649 lrwxrwxrwx  1 oracle oinstall 2 Apr 21 08:11 f3 -&gt; f1从上面的结果中可以看出，硬连接文件f2与原文件f1的inode节点相同，均为9797648，然而符号连接文件的inode节点不同。[oracle@Linux]$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;I am f1 file&quot;</span> &gt;&gt;f1[oracle@Linux]$ cat f1I am f1 file[oracle@Linux]$ cat f2I am f1 file[oracle@Linux]$ cat f3I am f1 file[oracle@Linux]$ rm -f f1[oracle@Linux]$ cat f2I am f1 file[oracle@Linux]$ cat f3cat: f3: No such file or directory</code></pre><p>通过上面的测试可以看出：当删除原始文件f1后，硬连接f2不受影响，但是符号连接f1文件无效</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>依此您可以做一些相关的测试，可以得到以下全部结论：</p><ol><li>删除符号连接f3,对f1,f2无影响；</li><li>删除硬连接f2，对f1,f3也无影响；</li><li>删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效；</li><li>同时删除原文件f1,硬连接f2，整个文件会真正的被删除。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/itech/archive/2009/04/10/1433052.html&quot;&gt;Linux软连接和硬链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Linux链接概念&quot;&gt;&lt;a href=&quot;#Linux链接概念&quot; class=&quot;headerlink&quot; title=&quot;Linux链接概念&quot;&gt;&lt;/a&gt;Linux链接概念&lt;/h2&gt;&lt;p&gt;Linux链接分两种，一种被称为硬链接&lt;code&gt;（Hard Link）&lt;/code&gt;，另一种被称为符号链接&lt;code&gt;（Symbolic Link）&lt;/code&gt;。默认情况下，ln命令产生硬链接。&lt;/p&gt;
&lt;h3 id=&quot;【硬连接】&quot;&gt;&lt;a href=&quot;#【硬连接】&quot; class=&quot;headerlink&quot; title=&quot;【硬连接】&quot;&gt;&lt;/a&gt;【硬连接】&lt;/h3&gt;&lt;p&gt;硬连接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。&lt;/p&gt;
&lt;h3 id=&quot;【软连接】&quot;&gt;&lt;a href=&quot;#【软连接】&quot; class=&quot;headerlink&quot; title=&quot;【软连接】&quot;&gt;&lt;/a&gt;【软连接】&lt;/h3&gt;&lt;p&gt;另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://tangxiaomi.top/categories/linux/"/>
    
    
    <category term="linux" scheme="https://tangxiaomi.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title> iframe 报错 Refused to display &#39;URL&#39; in a frame because it set &#39;X-Frame-Options&#39; to &#39;DENY&#39;</title>
    <link href="https://tangxiaomi.top/2021/06/03/question/d6d18596d2/"/>
    <id>https://tangxiaomi.top/2021/06/03/question/d6d18596d2/</id>
    <published>2021-06-03T00:00:00.000Z</published>
    <updated>2021-06-24T01:47:53.076Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options</a></p><p>X-Frame-Options 有三个值:</p><ul><li><p>DENY<br>表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。</p></li><li><p>SAMEORIGIN<br>表示该页面可以在相同域名页面的 frame 中展示。</p></li><li><p>ALLOW-FROM uri<br>表示该页面可以在指定来源的 frame 中展示。</p></li></ul><p>换一句话说，如果设置为 DENY，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载。另一方面，如果设置为 SAMEORIGIN，那么页面就可以在同域名页面的 frame 中嵌套。</p><h2 id="express-配置"><a href="#express-配置" class="headerlink" title="express 配置"></a>express 配置</h2><pre><code class="hljs js"><span class="hljs-keyword">const</span> helmet = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;helmet&#x27;</span>);<span class="hljs-keyword">const</span> app = express();app.use(helmet.frameguard(&#123; <span class="hljs-attr">action</span>: <span class="hljs-string">&#x27;SAMEORIGIN&#x27;</span> &#125;))</code></pre><p>或者使用：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> frameguard = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;frameguard&#x27;</span>)app.use(frameguard(&#123; <span class="hljs-attr">action</span>: <span class="hljs-string">&#x27;SAMEORIGIN&#x27;</span> &#125;))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Opt</summary>
      
    
    
    
    <category term="question" scheme="https://tangxiaomi.top/categories/question/"/>
    
    
    <category term="question" scheme="https://tangxiaomi.top/tags/question/"/>
    
  </entry>
  
  <entry>
    <title> 泛型</title>
    <link href="https://tangxiaomi.top/2021/06/03/typescript/c4dbac2ca2/"/>
    <id>https://tangxiaomi.top/2021/06/03/typescript/c4dbac2ca2/</id>
    <published>2021-06-03T00:00:00.000Z</published>
    <updated>2021-06-24T01:47:53.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p><p>在像C#和Java这样的语言中，可以使用<code>泛型</code>来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p><a id="more"></a><h2 id="泛型之Hello-World"><a href="#泛型之Hello-World" class="headerlink" title="泛型之Hello World"></a>泛型之Hello World</h2><p>下面来创建第一个使用泛型的例子：identity函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是<code>echo</code>命令。</p><p>不用泛型的话，这个函数可能是下面这样：</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identity</span>(<span class="hljs-params">arg: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;    <span class="hljs-keyword">return</span> arg;&#125;</code></pre><p>或者，我们使用<code>any</code>类型来定义函数：</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identity</span>(<span class="hljs-params">arg: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">any</span> </span>&#123;    <span class="hljs-keyword">return</span> arg;&#125;</code></pre><p>使用<code>any</code>类型会导致这个函数可以接收任何类型的<code>arg</code>参数，这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。 如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。</p><p>因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。 这里，我们使用了_类型变量_，它是一种特殊的变量，只用于表示类型而不是值。</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identity</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;    <span class="hljs-keyword">return</span> arg;&#125;</code></pre><p>我们给identity添加了类型变量<code>T</code>。 <code>T</code>帮助我们捕获用户传入的类型（比如：<code>number</code>），之后我们就可以使用这个类型。 之后我们再次使用了<code>T</code>当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。</p><p>我们把这个版本的<code>identity</code>函数叫做泛型，因为它可以适用于多个类型。 不同于使用<code>any</code>，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。</p><p>我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：</p><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> output = identity&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;myString&quot;</span>);  <span class="hljs-comment">// type of output will be &#x27;string&#x27;</span></code></pre><p>这里我们明确的指定了<code>T</code>是<code>string</code>类型，并做为一个参数传给函数，使用了<code>&lt;&gt;</code>括起来而不是<code>()</code>。</p><p>第二种方法更普遍。利用了<em>类型推论</em> – 即编译器会根据传入的参数自动地帮助我们确定T的类型：</p><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> output = identity(<span class="hljs-string">&quot;myString&quot;</span>);  <span class="hljs-comment">// type of output will be &#x27;string&#x27;</span></code></pre><p>注意我们没必要使用尖括号（<code>&lt;&gt;</code>）来明确地传入类型；编译器可以查看<code>myString</code>的值，然后把<code>T</code>设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，在一些复杂的情况下，这是可能出现的。</p><h2 id="使用泛型变量"><a href="#使用泛型变量" class="headerlink" title="使用泛型变量"></a>使用泛型变量</h2><p>使用泛型创建像<code>identity</code>这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。</p><p>看下之前<code>identity</code>例子：</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identity</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;    <span class="hljs-keyword">return</span> arg;&#125;</code></pre><p>如果我们想同时打印出<code>arg</code>的长度。 我们很可能会这样做：</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loggingIdentity</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;    <span class="hljs-built_in">console</span>.log(arg.length);  <span class="hljs-comment">// Error: T doesn&#x27;t have .length</span>    <span class="hljs-keyword">return</span> arg;&#125;</code></pre><p>如果这么做，编译器会报错说我们使用了<code>arg</code>的<code>.length</code>属性，但是没有地方指明<code>arg</code>具有这个属性。 记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有<code>.length</code>属性的。</p><p>现在假设我们想操作<code>T</code>类型的数组而不直接是<code>T</code>。由于我们操作的是数组，所以<code>.length</code>属性是应该存在的。 我们可以像创建其它数组一样创建这个数组：</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loggingIdentity</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: T[]</span>): <span class="hljs-title">T</span>[] </span>&#123;    <span class="hljs-built_in">console</span>.log(arg.length);  <span class="hljs-comment">// Array has a .length, so no more error</span>    <span class="hljs-keyword">return</span> arg;&#125;</code></pre><p>你可以这样理解<code>loggingIdentity</code>的类型：泛型函数<code>loggingIdentity</code>，接收类型参数<code>T</code>和参数<code>arg</code>，它是个元素类型是<code>T</code>的数组，并返回元素类型是<code>T</code>的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时<code>T</code>的的类型为<code>number</code>。 这可以让我们把泛型变量T当做类型的一部分使用，而不是整个类型，增加了灵活性。</p><p>我们也可以这样实现上面的例子：</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loggingIdentity</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: <span class="hljs-built_in">Array</span>&lt;T&gt;</span>): <span class="hljs-title">Array</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-built_in">console</span>.log(arg.length);  <span class="hljs-comment">// Array has a .length, so no more error</span>    <span class="hljs-keyword">return</span> arg;&#125;</code></pre><p>使用过其它语言的话，你可能对这种语法已经很熟悉了。 在下一节，会介绍如何创建自定义泛型像<code>Array&lt;T&gt;</code>一样。</p><h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h2><p>上一节，我们创建了identity通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。</p><p>泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identity</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;    <span class="hljs-keyword">return</span> arg;&#125;<span class="hljs-keyword">let</span> myIdentity: &lt;T&gt;<span class="hljs-function">(<span class="hljs-params">arg: T</span>) =&gt;</span> T = identity;</code></pre><p>我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identity</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;    <span class="hljs-keyword">return</span> arg;&#125;<span class="hljs-keyword">let</span> myIdentity: &lt;U&gt;<span class="hljs-function">(<span class="hljs-params">arg: U</span>) =&gt;</span> U = identity;</code></pre><p>我们还可以使用带有调用签名的对象字面量来定义泛型函数：</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identity</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;    <span class="hljs-keyword">return</span> arg;&#125;<span class="hljs-keyword">let</span> myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity;</code></pre><p>这引导我们去写第一个泛型接口了。 我们把上面例子里的对象字面量拿出来做为一个接口：</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> GenericIdentityFn &#123;    &lt;T&gt;(arg: T): T;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identity</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;    <span class="hljs-keyword">return</span> arg;&#125;<span class="hljs-keyword">let</span> myIdentity: GenericIdentityFn = identity;</code></pre><p>一个相似的例子，我们可能想把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如：<code>Dictionary&lt;string&gt;而不只是Dictionary</code>）。 这样接口里的其它成员也能知道这个参数的类型了。</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> GenericIdentityFn&lt;T&gt; &#123;    (arg: T): T;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identity</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;    <span class="hljs-keyword">return</span> arg;&#125;<span class="hljs-keyword">let</span> myIdentity: GenericIdentityFn&lt;<span class="hljs-built_in">number</span>&gt; = identity;</code></pre><p>注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用<code>GenericIdentityFn</code>的时候，还得传入一个类型参数来指定泛型类型（这里是：<code>number</code>），锁定了之后代码里使用的类型。 对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。</p><p>除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。</p><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类看上去与泛型接口差不多。 泛型类使用（<code>&lt;&gt;</code>）括起泛型类型，跟在类名后面。</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericNumber</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-attr">zeroValue</span>: T;    add: <span class="hljs-function">(<span class="hljs-params">x: T, y: T</span>) =&gt;</span> T;&#125;<span class="hljs-keyword">let</span> myGenericNumber = <span class="hljs-keyword">new</span> GenericNumber&lt;<span class="hljs-built_in">number</span>&gt;();myGenericNumber.zeroValue = <span class="hljs-number">0</span>;myGenericNumber.add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>&#123; <span class="hljs-keyword">return</span> x + y; &#125;;</code></pre><p><code>GenericNumber</code>类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用<code>number</code>类型。 也可以使用字符串或其它更复杂的类型。</p><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> stringNumeric = <span class="hljs-keyword">new</span> GenericNumber&lt;<span class="hljs-built_in">string</span>&gt;();stringNumeric.zeroValue = <span class="hljs-string">&quot;&quot;</span>;stringNumeric.add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>&#123; <span class="hljs-keyword">return</span> x + y; &#125;;<span class="hljs-built_in">console</span>.log(stringNumeric.add(stringNumeric.zeroValue, <span class="hljs-string">&quot;test&quot;</span>));</code></pre><p>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</p><p>我们在<a href="classes.md">类</a>那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。</p><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>你应该会记得之前的一个例子，我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。 在<code>loggingIdentity</code>例子中，我们想访问<code>arg</code>的<code>length</code>属性，但是编译器并不能证明每种类型都有<code>length</code>属性，所以就报错了。</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loggingIdentity</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;    <span class="hljs-built_in">console</span>.log(arg.length);  <span class="hljs-comment">// Error: T doesn&#x27;t have .length</span>    <span class="hljs-keyword">return</span> arg;&#125;</code></pre><p>相比于操作any所有类型，我们想要限制函数去处理任意带有<code>.length</code>属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。 为此，我们需要列出对于T的约束要求。</p><p>为此，我们定义一个接口来描述约束条件。 创建一个包含<code>.length</code>属性的接口，使用这个接口和<code>extends</code>关键字来实现约束：</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Lengthwise &#123;    <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loggingIdentity</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">Lengthwise</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;    <span class="hljs-built_in">console</span>.log(arg.length);  <span class="hljs-comment">// Now we know it has a .length property, so no more error</span>    <span class="hljs-keyword">return</span> arg;&#125;</code></pre><p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p><pre><code class="hljs typescript">loggingIdentity(<span class="hljs-number">3</span>);  <span class="hljs-comment">// Error, number doesn&#x27;t have a .length property</span></code></pre><p>我们需要传入符合约束类型的值，必须包含必须的属性：</p><pre><code class="hljs typescript">loggingIdentity(&#123;<span class="hljs-attr">length</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>&#125;);</code></pre><h3 id="在泛型约束中使用类型参数"><a href="#在泛型约束中使用类型参数" class="headerlink" title="在泛型约束中使用类型参数"></a>在泛型约束中使用类型参数</h3><p>你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象<code>obj</code>上，因此我们需要在这两个类型之间使用约束。</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getProperty</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">obj: T, key: K</span>) </span>&#123;    <span class="hljs-keyword">return</span> obj[key];&#125;<span class="hljs-keyword">let</span> x = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">d</span>: <span class="hljs-number">4</span> &#125;;getProperty(x, <span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">// okay</span>getProperty(x, <span class="hljs-string">&quot;m&quot;</span>); <span class="hljs-comment">// error: Argument of type &#x27;m&#x27; isn&#x27;t assignable to &#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27; | &#x27;d&#x27;.</span></code></pre><h3 id="在泛型里使用类类型"><a href="#在泛型里使用类类型" class="headerlink" title="在泛型里使用类类型"></a>在泛型里使用类类型</h3><p>在TypeScript使用泛型创建工厂函数时，需要引用构造函数的类类型。比如，</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">c: &#123;<span class="hljs-keyword">new</span>(): T; &#125;</span>): <span class="hljs-title">T</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> c();&#125;</code></pre><p>一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系。</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeeKeeper</span> </span>&#123;    <span class="hljs-attr">hasMask</span>: <span class="hljs-built_in">boolean</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZooKeeper</span> </span>&#123;    <span class="hljs-attr">nametag</span>: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;    <span class="hljs-attr">numLegs</span>: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;    <span class="hljs-attr">keeper</span>: BeeKeeper;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lion</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;    <span class="hljs-attr">keeper</span>: ZooKeeper;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createInstance</span>&lt;<span class="hljs-title">A</span> <span class="hljs-title">extends</span> <span class="hljs-title">Animal</span>&gt;(<span class="hljs-params">c: <span class="hljs-keyword">new</span> () =&gt; A</span>): <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> c();&#125;createInstance(Lion).keeper.nametag;  <span class="hljs-comment">// typechecks!</span>createInstance(Bee).keeper.hasMask;   <span class="hljs-comment">// typechecks!</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。&lt;/p&gt;
&lt;p&gt;在像C#和Java这样的语言中，可以使用&lt;code&gt;泛型&lt;/code&gt;来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。&lt;/p&gt;</summary>
    
    
    
    <category term="typescript" scheme="https://tangxiaomi.top/categories/typescript/"/>
    
    
    <category term="typescript" scheme="https://tangxiaomi.top/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title> 接口</title>
    <link href="https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/"/>
    <id>https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/</id>
    <published>2021-06-03T00:00:00.000Z</published>
    <updated>2021-06-24T01:47:53.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>TypeScript 的核心原则之一是对值所具有的_结构_进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p><a id="more"></a><h2 id="接口初探"><a href="#接口初探" class="headerlink" title="接口初探"></a>接口初探</h2><p>下面通过一个简单示例来观察接口是如何工作的：</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printLabel</span>(<span class="hljs-params">labeledObj: &#123; label: <span class="hljs-built_in">string</span> &#125;</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(labeledObj.label);&#125;<span class="hljs-keyword">let</span> myObj = &#123; <span class="hljs-attr">size</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;Size 10 Object&quot;</span> &#125;;printLabel(myObj);</code></pre><p>类型检查器会查看<code>printLabel</code>的调用。 <code>printLabel</code>有一个参数，并要求这个对象参数有一个名为<code>label</code>类型为<code>string</code>的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候 TypeScript 却并不会这么宽松，我们下面会稍做讲解。</p><p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个<code>label</code>属性且类型为<code>string</code>：</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> LabeledValue &#123;  <span class="hljs-attr">label</span>: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printLabel</span>(<span class="hljs-params">labeledObj: LabeledValue</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(labeledObj.label);&#125;<span class="hljs-keyword">let</span> myObj = &#123; <span class="hljs-attr">size</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;Size 10 Object&quot;</span> &#125;;printLabel(myObj);</code></pre><p><code>LabeledValue</code>接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个<code>label</code>属性且类型为<code>string</code>的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给<code>printLabel</code>的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p><p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p><h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p><p>下面是应用了“option bags”的例子：</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> SquareConfig &#123;  color?: <span class="hljs-built_in">string</span>;  width?: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSquare</span>(<span class="hljs-params">config: SquareConfig</span>): </span>&#123; color: <span class="hljs-built_in">string</span>; area: <span class="hljs-built_in">number</span> &#125; &#123;  <span class="hljs-keyword">let</span> newSquare = &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;white&quot;</span>, <span class="hljs-attr">area</span>: <span class="hljs-number">100</span> &#125;;  <span class="hljs-keyword">if</span> (config.color) &#123;    newSquare.color = config.color;  &#125;  <span class="hljs-keyword">if</span> (config.width) &#123;    newSquare.area = config.width * config.width;  &#125;  <span class="hljs-keyword">return</span> newSquare;&#125;<span class="hljs-keyword">let</span> mySquare = createSquare(&#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;black&quot;</span> &#125;);</code></pre><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个<code>?</code>符号。</p><p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将<code>createSquare</code>里的<code>color</code>属性名拼错，就会得到一个错误提示：</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> SquareConfig &#123;  color?: <span class="hljs-built_in">string</span>;  width?: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSquare</span>(<span class="hljs-params">config: SquareConfig</span>): </span>&#123; color: <span class="hljs-built_in">string</span>; area: <span class="hljs-built_in">number</span> &#125; &#123;  <span class="hljs-keyword">let</span> newSquare = &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;white&quot;</span>, <span class="hljs-attr">area</span>: <span class="hljs-number">100</span> &#125;;  <span class="hljs-keyword">if</span> (config.clor) &#123;    <span class="hljs-comment">// Error: Property &#x27;clor&#x27; does not exist on type &#x27;SquareConfig&#x27;</span>    newSquare.color = config.clor;  &#125;  <span class="hljs-keyword">if</span> (config.width) &#123;    newSquare.area = config.width * config.width;  &#125;  <span class="hljs-keyword">return</span> newSquare;&#125;<span class="hljs-keyword">let</span> mySquare = createSquare(&#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;black&quot;</span> &#125;);</code></pre><h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用<code>readonly</code>来指定只读属性:</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Point &#123;  <span class="hljs-keyword">readonly</span> x: <span class="hljs-built_in">number</span>;  <span class="hljs-keyword">readonly</span> y: <span class="hljs-built_in">number</span>;&#125;</code></pre><p>你可以通过赋值一个对象字面量来构造一个<code>Point</code>。 赋值后，<code>x</code>和<code>y</code>再也不能被改变了。</p><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> p1: Point = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">20</span> &#125;;p1.x = <span class="hljs-number">5</span>; <span class="hljs-comment">// error!</span></code></pre><p>TypeScript 具有<code>ReadonlyArray&lt;T&gt;</code>类型，它与<code>Array&lt;T&gt;</code>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<span class="hljs-keyword">let</span> ro: ReadonlyArray&lt;<span class="hljs-built_in">number</span>&gt; = a;ro[<span class="hljs-number">0</span>] = <span class="hljs-number">12</span>; <span class="hljs-comment">// error!</span>ro.push(<span class="hljs-number">5</span>); <span class="hljs-comment">// error!</span>ro.length = <span class="hljs-number">100</span>; <span class="hljs-comment">// error!</span>a = ro; <span class="hljs-comment">// error!</span></code></pre><p>上面代码的最后一行，可以看到就算把整个<code>ReadonlyArray</code>赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p><pre><code class="hljs typescript">a = ro <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>[];</code></pre><h3 id="readonly-vs-const"><a href="#readonly-vs-const" class="headerlink" title="readonly vs const"></a><code>readonly</code> vs <code>const</code></h3><p>最简单判断该用<code>readonly</code>还是<code>const</code>的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用<code>const</code>，若做为属性则使用<code>readonly</code>。</p><h2 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h2><p>我们在第一个例子里使用了接口，TypeScript 让我们传入<code>&#123; size: number; label: string; &#125;</code>到仅期望得到<code>&#123; label: string; &#125;</code>的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。</p><p>然而，天真地将这两者结合的话就会像在 JavaScript 里那样搬起石头砸自己的脚。比如，拿<code>createSquare</code>例子来说：</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> SquareConfig &#123;  color?: <span class="hljs-built_in">string</span>;  width?: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSquare</span>(<span class="hljs-params">config: SquareConfig</span>): </span>&#123; color: <span class="hljs-built_in">string</span>; area: <span class="hljs-built_in">number</span> &#125; &#123;  <span class="hljs-comment">// ...</span>&#125;<span class="hljs-keyword">let</span> mySquare = createSquare(&#123; <span class="hljs-attr">colour</span>: <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">100</span> &#125;);</code></pre><p>注意传入<code>createSquare</code>的参数拼写为<code>colour</code>而不是<code>color</code>。 在 JavaScript 里，这会默默地失败。</p><p>你可能会争辩这个程序已经正确地类型化了，因为<code>width</code>属性是兼容的，不存在<code>color</code>属性，而且额外的<code>colour</code>属性是无意义的。</p><p>然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过_额外属性检查_，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p><pre><code class="hljs typescript"><span class="hljs-comment">// error: Object literal may only specify known properties, but &#x27;colour&#x27; does not exist in type &#x27;SquareConfig&#x27;. Did you mean to write &#x27;color&#x27;?</span><span class="hljs-keyword">let</span> mySquare = createSquare(&#123; <span class="hljs-attr">colour</span>: <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">100</span> &#125;);</code></pre><p>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> mySquare = createSquare(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.5</span> &#125; <span class="hljs-keyword">as</span> SquareConfig);</code></pre><p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果<code>SquareConfig</code>带有上面定义的类型的<code>color</code>和<code>width</code>属性，并且_还会_带有任意数量的其它属性，那么我们可以这样定义它：</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> SquareConfig &#123;  color?: <span class="hljs-built_in">string</span>;  width?: <span class="hljs-built_in">number</span>;  [propName: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;&#125;</code></pre><p>我们稍后会讲到索引签名，但在这我们要表示的是<code>SquareConfig</code>可以有任意数量的属性，并且只要它们不是<code>color</code>和<code>width</code>，那么就无所谓它们的类型是什么。</p><p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为<code>squareOptions</code>不会经过额外属性检查，所以编译器不会报错。</p><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> squareOptions = &#123; <span class="hljs-attr">colour</span>: <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">100</span> &#125;;<span class="hljs-keyword">let</span> mySquare = createSquare(squareOptions);</code></pre><p>上面的方法只在<code>squareOptions</code>和<code>SquareConfig</code>之间有共同的属性时才好用。 在这个例子中，这个属性为<code>width</code>。如果变量间不存在共同的对象属性将会报错。例如：</p><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> squareOptions = &#123; <span class="hljs-attr">colour</span>: <span class="hljs-string">&quot;red&quot;</span> &#125;;<span class="hljs-keyword">let</span> mySquare = createSquare(squareOptions);</code></pre><p>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的 bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入<code>color</code>或<code>colour</code>属性到<code>createSquare</code>，你应该修改<code>SquareConfig</code>定义来体现出这一点。</p><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p><p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> SearchFunc &#123;  (source: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;&#125;</code></pre><p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> mySearch: SearchFunc;mySearch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>) </span>&#123;  <span class="hljs-keyword">let</span> result = source.search(subString);  <span class="hljs-keyword">return</span> result &gt; -<span class="hljs-number">1</span>;&#125;;</code></pre><p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> mySearch: SearchFunc;mySearch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">src: <span class="hljs-built_in">string</span>, sub: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">boolean</span> </span>&#123;  <span class="hljs-keyword">let</span> result = src.search(sub);  <span class="hljs-keyword">return</span> result &gt; -<span class="hljs-number">1</span>;&#125;;</code></pre><p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了<code>SearchFunc</code>类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是<code>false</code>和<code>true</code>）。</p><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> mySearch: SearchFunc;mySearch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">src, sub</span>) </span>&#123;  <span class="hljs-keyword">let</span> result = src.search(sub);  <span class="hljs-keyword">return</span> result &gt; -<span class="hljs-number">1</span>;&#125;;</code></pre><p>如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与<code>SearchFunc</code>接口中的定义不匹配。</p><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> mySearch: SearchFunc;<span class="hljs-comment">// error: Type &#x27;(src: string, sub: string) =&gt; string&#x27; is not assignable to type &#x27;SearchFunc&#x27;.</span><span class="hljs-comment">// Type &#x27;string&#x27; is not assignable to type &#x27;boolean&#x27;.</span>mySearch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">src, sub</span>) </span>&#123;  <span class="hljs-keyword">let</span> result = src.search(sub);  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;string&quot;</span>;&#125;;</code></pre><h2 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h2><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如<code>a[10]</code>或<code>ageMap[&quot;daniel&quot;]</code>。 可索引类型具有一个_索引签名_，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> StringArray &#123;  [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-keyword">let</span> myArray: StringArray;myArray = [<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Fred&quot;</span>];<span class="hljs-keyword">let</span> myStr: <span class="hljs-built_in">string</span> = myArray[<span class="hljs-number">0</span>];</code></pre><p>上面例子里，我们定义了<code>StringArray</code>接口，它具有索引签名。 这个索引签名表示了当用<code>number</code>去索引<code>StringArray</code>时会得到<code>string</code>类型的返回值。</p><p>Typescript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用<code>number</code>来索引时，JavaScript 会将它转换成<code>string</code>然后再去索引对象。 也就是说用<code>100</code>（一个<code>number</code>）去索引等同于使用<code>&quot;100&quot;</code>（一个<code>string</code>）去索引，因此两者需要保持一致。</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;  <span class="hljs-attr">breed</span>: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-comment">// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!</span><span class="hljs-keyword">interface</span> NotOkay &#123;  [x: <span class="hljs-built_in">number</span>]: Animal;  [x: <span class="hljs-built_in">string</span>]: Dog;&#125;</code></pre><p>字符串索引签名能够很好的描述<code>dictionary</code>模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了<code>obj.property</code>和<code>obj[&quot;property&quot;]</code>两种形式都可以。 下面的例子里，<code>name</code>的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> NumberDictionary &#123;  [index: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>;  length: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 可以，length是number类型</span>  name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 错误，`name`的类型与索引类型返回值的类型不匹配</span>&#125;</code></pre><p>但如果索引签名是包含属性类型的联合类型，那么使用不同类型的属性就是允许的。</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> NumberOrStringDictionary &#123;   [index: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;   length: <span class="hljs-built_in">number</span>;    <span class="hljs-comment">// ok, length is a number</span>   name: <span class="hljs-built_in">string</span>;      <span class="hljs-comment">// ok, name is a string</span>&#125;</code></pre><p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> ReadonlyStringArray &#123;  <span class="hljs-keyword">readonly</span> [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-keyword">let</span> myArray: ReadonlyStringArray = [<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>];myArray[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;Mallory&quot;</span>; <span class="hljs-comment">// error!</span></code></pre><p>你不能设置<code>myArray[2]</code>，因为索引签名是只读的。</p><h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>与 C#或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> ClockInterface &#123;  <span class="hljs-attr">currentTime</span>: <span class="hljs-built_in">Date</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-title">implements</span> <span class="hljs-title">ClockInterface</span> </span>&#123;  <span class="hljs-attr">currentTime</span>: <span class="hljs-built_in">Date</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">h: <span class="hljs-built_in">number</span>, m: <span class="hljs-built_in">number</span></span>)</span> &#123;&#125;&#125;</code></pre><p>你也可以在接口中描述一个方法，在类里实现它，如同下面的<code>setTime</code>方法一样：</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> ClockInterface &#123;  <span class="hljs-attr">currentTime</span>: <span class="hljs-built_in">Date</span>;  setTime(d: <span class="hljs-built_in">Date</span>): <span class="hljs-built_in">void</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-title">implements</span> <span class="hljs-title">ClockInterface</span> </span>&#123;  <span class="hljs-attr">currentTime</span>: <span class="hljs-built_in">Date</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();  <span class="hljs-function"><span class="hljs-title">setTime</span>(<span class="hljs-params">d: <span class="hljs-built_in">Date</span></span>)</span> &#123;    <span class="hljs-built_in">this</span>.currentTime = d;  &#125;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">h: <span class="hljs-built_in">number</span>, m: <span class="hljs-built_in">number</span></span>)</span> &#123;&#125;&#125;</code></pre><p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p><h3 id="类静态部分与实例部分的区别"><a href="#类静态部分与实例部分的区别" class="headerlink" title="类静态部分与实例部分的区别"></a>类静态部分与实例部分的区别</h3><p>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> ClockConstructor &#123;  <span class="hljs-keyword">new</span> (hour: <span class="hljs-built_in">number</span>, <span class="hljs-attr">minute</span>: <span class="hljs-built_in">number</span>);&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-title">implements</span> <span class="hljs-title">ClockConstructor</span> </span>&#123;  <span class="hljs-attr">currentTime</span>: <span class="hljs-built_in">Date</span>;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">h: <span class="hljs-built_in">number</span>, m: <span class="hljs-built_in">number</span></span>)</span> &#123;&#125;&#125;</code></pre><p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor 存在于类的静态部分，所以不在检查的范围内。</p><p>因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口，<code>ClockConstructor</code>为构造函数所用和<code>ClockInterface</code>为实例方法所用。 为了方便我们定义一个构造函数<code>createClock</code>，它用传入的类型创建实例。</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> ClockConstructor &#123;  <span class="hljs-keyword">new</span> (hour: <span class="hljs-built_in">number</span>, <span class="hljs-attr">minute</span>: <span class="hljs-built_in">number</span>): ClockInterface;&#125;<span class="hljs-keyword">interface</span> ClockInterface &#123;  tick(): <span class="hljs-built_in">void</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createClock</span>(<span class="hljs-params"></span></span><span class="hljs-params"><span class="hljs-function">  ctor: ClockConstructor,</span></span><span class="hljs-params"><span class="hljs-function">  hour: <span class="hljs-built_in">number</span>,</span></span><span class="hljs-params"><span class="hljs-function">  minute: <span class="hljs-built_in">number</span></span></span><span class="hljs-params"><span class="hljs-function"></span>): <span class="hljs-title">ClockInterface</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ctor(hour, minute);&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DigitalClock</span> <span class="hljs-title">implements</span> <span class="hljs-title">ClockInterface</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">h: <span class="hljs-built_in">number</span>, m: <span class="hljs-built_in">number</span></span>)</span> &#123;&#125;  <span class="hljs-function"><span class="hljs-title">tick</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;beep beep&quot;</span>);  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnalogClock</span> <span class="hljs-title">implements</span> <span class="hljs-title">ClockInterface</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">h: <span class="hljs-built_in">number</span>, m: <span class="hljs-built_in">number</span></span>)</span> &#123;&#125;  <span class="hljs-function"><span class="hljs-title">tick</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;tick tock&quot;</span>);  &#125;&#125;<span class="hljs-keyword">let</span> digital = createClock(DigitalClock, <span class="hljs-number">12</span>, <span class="hljs-number">17</span>);<span class="hljs-keyword">let</span> analog = createClock(AnalogClock, <span class="hljs-number">7</span>, <span class="hljs-number">32</span>);</code></pre><p>因为<code>createClock</code>的第一个参数是<code>ClockConstructor</code>类型，在<code>createClock(AnalogClock, 7, 32)</code>里，会检查<code>AnalogClock</code>是否符合构造函数签名。</p><p>另一种简单方式是使用类表达式：</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> ClockConstructor &#123;  <span class="hljs-keyword">new</span> (hour: <span class="hljs-built_in">number</span>, <span class="hljs-attr">minute</span>: <span class="hljs-built_in">number</span>);&#125;<span class="hljs-keyword">interface</span> ClockInterface &#123;  tick();&#125;<span class="hljs-keyword">const</span> Clock: ClockConstructor = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-title">implements</span> <span class="hljs-title">ClockInterface</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">h: <span class="hljs-built_in">number</span>, m: <span class="hljs-built_in">number</span></span>)</span> &#123;&#125;  <span class="hljs-function"><span class="hljs-title">tick</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;beep beep&quot;</span>);  &#125;&#125;;</code></pre><h2 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h2><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Shape &#123;  <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-keyword">interface</span> Square <span class="hljs-keyword">extends</span> Shape &#123;  <span class="hljs-attr">sideLength</span>: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-keyword">let</span> square = &#123;&#125; <span class="hljs-keyword">as</span> Square;square.color = <span class="hljs-string">&quot;blue&quot;</span>;square.sideLength = <span class="hljs-number">10</span>;</code></pre><p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Shape &#123;  <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-keyword">interface</span> PenStroke &#123;  <span class="hljs-attr">penWidth</span>: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-keyword">interface</span> Square <span class="hljs-keyword">extends</span> Shape, PenStroke &#123;  <span class="hljs-attr">sideLength</span>: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-keyword">let</span> square = &#123;&#125; <span class="hljs-keyword">as</span> Square;square.color = <span class="hljs-string">&quot;blue&quot;</span>;square.sideLength = <span class="hljs-number">10</span>;square.penWidth = <span class="hljs-number">5.0</span>;</code></pre><h2 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h2><p>先前我们提过，接口能够描述 JavaScript 里丰富的类型。 因为 JavaScript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</p><p>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Counter &#123;  (start: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>;  interval: <span class="hljs-built_in">number</span>;  reset(): <span class="hljs-built_in">void</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCounter</span>(<span class="hljs-params"></span>): <span class="hljs-title">Counter</span> </span>&#123;  <span class="hljs-keyword">let</span> counter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">start: <span class="hljs-built_in">number</span></span>) </span>&#123;&#125; <span class="hljs-keyword">as</span> Counter;  counter.interval = <span class="hljs-number">123</span>;  counter.reset = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;  <span class="hljs-keyword">return</span> counter;&#125;<span class="hljs-keyword">let</span> c = getCounter();c(<span class="hljs-number">10</span>);c.reset();c.interval = <span class="hljs-number">5.0</span>;</code></pre><p>在使用 JavaScript 第三方库的时候，你可能需要像上面那样去完整地定义类型。</p><h2 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h2><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 private 和 protected 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p><p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 除了继承自基类，子类之间不必相关联。 例：</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Control</span> </span>&#123;  <span class="hljs-keyword">private</span> state: <span class="hljs-built_in">any</span>;&#125;<span class="hljs-keyword">interface</span> SelectableControl <span class="hljs-keyword">extends</span> Control &#123;  select(): <span class="hljs-built_in">void</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Control</span> <span class="hljs-title">implements</span> <span class="hljs-title">SelectableControl</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">select</span>(<span class="hljs-params"></span>)</span> &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Control</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">select</span>(<span class="hljs-params"></span>)</span> &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageControl</span> <span class="hljs-title">implements</span> <span class="hljs-title">SelectableControl</span> </span>&#123;<span class="hljs-comment">// Error: Class &#x27;ImageControl&#x27; incorrectly implements interface &#x27;SelectableControl&#x27;.</span><span class="hljs-comment">//  Types have separate declarations of a private property &#x27;state&#x27;.</span>  <span class="hljs-keyword">private</span> state: <span class="hljs-built_in">any</span>;  <span class="hljs-function"><span class="hljs-title">select</span>(<span class="hljs-params"></span>)</span> &#123;&#125;&#125;</code></pre><p>在上面的例子里，<code>SelectableControl</code>包含了<code>Control</code>的所有成员，包括私有成员<code>state</code>。 因为<code>state</code>是私有成员，所以只能够是<code>Control</code>的子类们才能实现<code>SelectableControl</code>接口。 因为只有<code>Control</code>的子类才能够拥有一个声明于<code>Control</code>的私有成员<code>state</code>，这对私有成员的兼容性是必需的。</p><p>在<code>Control</code>类内部，是允许通过<code>SelectableControl</code>的实例来访问私有成员<code>state</code>的。 实际上，<code>SelectableControl</code>就像<code>Control</code>一样，并拥有一个<code>select</code>方法。 <code>Button</code>和<code>TextBox</code>类是<code>SelectableControl</code>的子类（因为它们都继承自<code>Control</code>并有<code>select</code>方法）。而对于 <code>ImageControl</code> 类，它有自身的私有成员 <code>state</code> 而不是通过继承 <code>Control</code> 得来的，所以它不可以实现 <code>SelectableControl</code> 。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;TypeScript 的核心原则之一是对值所具有的_结构_进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。&lt;/p&gt;</summary>
    
    
    
    <category term="typescript" scheme="https://tangxiaomi.top/categories/typescript/"/>
    
    
    <category term="typescript" scheme="https://tangxiaomi.top/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title> 为什么要用setTimeout来模拟setInterval</title>
    <link href="https://tangxiaomi.top/2021/06/02/interview/ac86bf5243/"/>
    <id>https://tangxiaomi.top/2021/06/02/interview/ac86bf5243/</id>
    <published>2021-06-02T01:49:36.000Z</published>
    <updated>2021-06-24T01:47:53.076Z</updated>
    
    <content type="html"><![CDATA[<p>setTimeout(fn,time): 等待time时间后执行fn<br>setInterval(fn,time):  每隔time时间执行fn</p><p>我们希望setInterval是每隔一段时间自动执行，但是实际应用中，setInterval并不会按照我们预想的那样，它通常存在如下两个缺点。</p><pre><code>1. 在执行的时候可能会跳过指定时间间隔2. 多个定时器函数会立刻执行</code></pre><p>我们就实际场景来说一下这两个缺陷</p><a id="more"></a><h2 id="时间间隔"><a href="#时间间隔" class="headerlink" title="时间间隔"></a>时间间隔</h2><p>首先明确一个概念，定时器的时间间隔指的是什么？<br>它不是指函数的执行时间，而是函数<strong>被推入到消息队列的时间</strong>。<br>也就是说每隔time时间，fn就会被放入消息队列中，而不是执行。另外何时执行取决于何时被主线程的事件循环取到</p><p>另外，如果前一个任务没有被执行，也就是还处于消息队列中怎么办呢？ 浏览器规定<strong>：只有当前消息队列中不存在该任务，才会将下一个任务推进去</strong></p><p><img src="/images/20200609111645389.png"></p><p>我们分析一下上面的情况，</p><pre><code>* 隔了100ms之后，将t1推进去，因为js栈中主进程还没有执行完，所以t1这时候等待执行，* 又过了100ms，t1已经执行，t2被压入队列中* 又过了100ms，t1还没执行完，t2还存在在消息队列中，所以t3根据规定不能被压入队列中</code></pre><p>所以这时候你就会发现，t1 、 t2是连续执行的，他们之间没有时间间隔，满足不了我们的需求。</p><p>而我们可以用setTimeout模拟来弥补这两个缺陷。</p><h2 id="setTimeout-模拟-setInterval"><a href="#setTimeout-模拟-setInterval" class="headerlink" title="setTimeout 模拟 setInterval"></a>setTimeout 模拟 setInterval</h2><p>可以这么理解：<br>setTimeout执行后会立刻将fn放入到消息队列中，而setInterval每次在放入之前都会判断消息队列中存不存在上一个任务。</p><p>setTimeout的执行机制，也就是浏览器的事件循环机制，setTimeout是一个宏任务，当js栈空了，就会依次执行宏任务。</p><p>代码实现：</p><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">//.....</span>    <span class="hljs-built_in">setTimeout</span>(a,time)&#125;,time)</code></pre><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><p>在一个定时器执行完以前不会插入另一个定时器<br>确保了每个函数执行的等待时间间隔</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;setTimeout(fn,time): 等待time时间后执行fn&lt;br&gt;setInterval(fn,time):  每隔time时间执行fn&lt;/p&gt;
&lt;p&gt;我们希望setInterval是每隔一段时间自动执行，但是实际应用中，setInterval并不会按照我们预想的那样，它通常存在如下两个缺点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 在执行的时候可能会跳过指定时间间隔
2. 多个定时器函数会立刻执行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们就实际场景来说一下这两个缺陷&lt;/p&gt;</summary>
    
    
    
    <category term="Interview" scheme="https://tangxiaomi.top/categories/Interview/"/>
    
    
    <category term="Interview" scheme="https://tangxiaomi.top/tags/Interview/"/>
    
    <category term="javascript" scheme="https://tangxiaomi.top/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title> 枚举</title>
    <link href="https://tangxiaomi.top/2021/06/02/typescript/1c6b93719a/"/>
    <id>https://tangxiaomi.top/2021/06/02/typescript/1c6b93719a/</id>
    <published>2021-06-02T00:00:00.000Z</published>
    <updated>2021-06-24T01:47:53.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript支持数字的和基于字符串的枚举。</p><a id="more"></a><h3 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h3><p>首先我们看看数字枚举，如果你使用过其它编程语言应该会很熟悉。</p><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Direction &#123;    Up = <span class="hljs-number">1</span>,    Down,    Left,    Right&#125;</code></pre><p>如上，我们定义了一个数字枚举，<code>Up</code>使用初始化为<code>1</code>。 其余的成员会从<code>1</code>开始自动增长。 换句话说，<code>Direction.Up</code>的值为<code>1</code>，<code>Down</code>为<code>2</code>，<code>Left</code>为<code>3</code>，<code>Right</code>为<code>4</code>。</p><p>我们还可以完全不使用初始化器：</p><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Direction &#123;    Up,    Down,    Left,    Right,&#125;</code></pre><p>现在，<code>Up</code>的值为<code>0</code>，<code>Down</code>的值为<code>1</code>等等。 当我们不在乎成员的值的时候，这种自增长的行为是很有用处的，但是要注意每个枚举成员的值都是不同的。</p><p>使用枚举很简单：通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型：</p><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Response &#123;    No = <span class="hljs-number">0</span>,    Yes = <span class="hljs-number">1</span>,&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">respond</span>(<span class="hljs-params">recipient: <span class="hljs-built_in">string</span>, message: Response</span>): <span class="hljs-title">void</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;respond(<span class="hljs-string">&quot;Princess Caroline&quot;</span>, Response.Yes)</code></pre><p>数字枚举可以被混入到<a href="enums.md#computed-and-constant-members">计算过的和常量成员（如下所示）</a>。 简短地说，没有初始化器的成员要么在首位，要么必须在用数值常量或其他常量枚举成员初始化的数值枚举之后。 换句话说，下面的情况是不被允许的：</p><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> E &#123;    A = getSomeValue(),    B, <span class="hljs-comment">// Error! Enum member must have initializer.</span>&#125;</code></pre><h3 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h3><p>字符串枚举的概念很简单，但是有细微的<a href="enums.md#enums-at-runtime">运行时的差别</a>。 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。</p><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Direction &#123;    Up = <span class="hljs-string">&quot;UP&quot;</span>,    Down = <span class="hljs-string">&quot;DOWN&quot;</span>,    Left = <span class="hljs-string">&quot;LEFT&quot;</span>,    Right = <span class="hljs-string">&quot;RIGHT&quot;</span>,&#125;</code></pre><p>由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管<a href="enums.md#enums-at-runtime">反向映射</a>会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。</p><h3 id="异构枚举（Heterogeneous-enums）"><a href="#异构枚举（Heterogeneous-enums）" class="headerlink" title="异构枚举（Heterogeneous enums）"></a>异构枚举（Heterogeneous enums）</h3><p>从技术的角度来说，枚举可以混合字符串和数字成员，但是似乎你并不会这么做：</p><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> BooleanLikeHeterogeneousEnum &#123;    No = <span class="hljs-number">0</span>,    Yes = <span class="hljs-string">&quot;YES&quot;</span>,&#125;</code></pre><p>除非你真的想要利用JavaScript运行时的行为，否则我们不建议这样做。</p><h3 id="计算的和常量成员"><a href="#计算的和常量成员" class="headerlink" title="计算的和常量成员"></a>计算的和常量成员</h3><p>每个枚举成员都带有一个值，它可以是_常量_或_计算出来的_。 当满足如下条件时，枚举成员被当作是常量：</p><ul><li>它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值<code>0</code>：</li></ul><pre><code class="hljs typescript"><span class="hljs-comment">// E.X is constant:</span><span class="hljs-built_in">enum</span> E &#123; X &#125;</code></pre><ul><li>它不带有初始化器且它之前的枚举成员是一个_数字_常量。 这种情况下，当前枚举成员的值为它上一个枚举成员的值加1。</li></ul><pre><code class="hljs typescript"><span class="hljs-comment">// All enum members in &#x27;E1&#x27; and &#x27;E2&#x27; are constant.</span><span class="hljs-built_in">enum</span> E1 &#123; X, Y, Z &#125;<span class="hljs-built_in">enum</span> E2 &#123;    A = <span class="hljs-number">1</span>, B, C&#125;</code></pre><ul><li>枚举成员使用_常量枚举表达式_初始化。 常量枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式：</li></ul><ol><li>一个枚举表达式字面量（主要是字符串字面量或数字字面量）</li><li>一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）</li><li>带括号的常量枚举表达式</li><li>一元运算符<code>+</code>, <code>-</code>, <code>~</code>其中之一应用在了常量枚举表达式</li><li>常量枚举表达式做为二元运算符<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>的操作对象。</li></ol><p>若常量枚举表达式求值后为<code>NaN</code>或<code>Infinity</code>，则会在编译阶段报错。</p><p>所有其它情况的枚举成员被当作是需要计算得出的值。</p><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> FileAccess &#123;    <span class="hljs-comment">// constant members</span>    None,    Read    = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>,    Write   = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>,    ReadWrite  = Read | Write,    <span class="hljs-comment">// computed member</span>    G = <span class="hljs-string">&quot;123&quot;</span>.length&#125;</code></pre><h3 id="联合枚举与枚举成员的类型"><a href="#联合枚举与枚举成员的类型" class="headerlink" title="联合枚举与枚举成员的类型"></a>联合枚举与枚举成员的类型</h3><p>存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。 字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为</p><ul><li>任何字符串字面量（例如：<code>&quot;foo&quot;</code>，<code>&quot;bar&quot;</code>，<code>&quot;baz&quot;</code>）</li><li>任何数字字面量（例如：<code>1</code>, <code>100</code>）</li><li>应用了一元<code>-</code>符号的数字字面量（例如：<code>-1</code>, <code>-100</code>）</li></ul><p>当所有枚举成员都拥有字面量枚举值时，它就带有了一种特殊的语义。</p><p>首先，枚举成员成为了类型！ 例如，我们可以说某些成员_只能_是枚举成员的值：</p><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> ShapeKind &#123;    Circle,    Square,&#125;<span class="hljs-keyword">interface</span> Circle &#123;    <span class="hljs-attr">kind</span>: ShapeKind.Circle;    radius: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-keyword">interface</span> Square &#123;    <span class="hljs-attr">kind</span>: ShapeKind.Square;    sideLength: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-keyword">let</span> c: Circle = &#123;    <span class="hljs-attr">kind</span>: ShapeKind.Square, <span class="hljs-comment">// Error! Type &#x27;ShapeKind.Square&#x27; is not assignable to type &#x27;ShapeKind.Circle&#x27;.</span>    <span class="hljs-attr">radius</span>: <span class="hljs-number">100</span>,&#125;</code></pre><p>另一个变化是枚举类型本身变成了每个枚举成员的_联合_。 虽然我们还没有讨论<a href="advanced-types.md#union-types">联合类型</a>，但你只要知道通过联合枚举，类型系统能够利用这样一个事实，它可以知道枚举里的值的集合。 因此，TypeScript能够捕获在比较值的时候犯的愚蠢的错误。 例如：</p><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> E &#123;    Foo,    Bar,&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">x: E</span>) </span>&#123;    <span class="hljs-keyword">if</span> (x !== E.Foo || x !== E.Bar) &#123;        <span class="hljs-comment">//             ~~~~~~~~~~~</span>        <span class="hljs-comment">// Error! This condition will always return &#x27;true&#x27; since the types &#x27;E.Foo&#x27; and &#x27;E.Bar&#x27; have no overlap.</span>    &#125;&#125;</code></pre><p>这个例子里，我们先检查<code>x</code>是否不是<code>E.Foo</code>。 如果通过了这个检查，然后<code>||</code>会发生短路效果，<code>if</code>语句体里的内容会被执行。 然而，这个检查没有通过，那么<code>x</code>则_只能_为<code>E.Foo</code>，因此没理由再去检查它是否为<code>E.Bar</code>。</p><h3 id="运行时的枚举"><a href="#运行时的枚举" class="headerlink" title="运行时的枚举"></a>运行时的枚举</h3><p>枚举是在运行时真正存在的对象。 例如下面的枚举：</p><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> E &#123;    X, Y, Z&#125;</code></pre><p>可以传递给函数</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">obj: &#123; X: <span class="hljs-built_in">number</span> &#125;</span>) </span>&#123;    <span class="hljs-keyword">return</span> obj.X;&#125;<span class="hljs-comment">// 没问题，因为 &#x27;E&#x27;包含一个数值型属性&#x27;X&#x27;。</span>f(E);</code></pre><h3 id="编译时的枚举"><a href="#编译时的枚举" class="headerlink" title="编译时的枚举"></a>编译时的枚举</h3><p>尽管一个枚举是在运行时真正存在的对象，但<code>keyof</code>关键字的行为与其作用在对象上时有所不同。应该使用<code>keyof typeof</code>来获取一个表示枚举里所有字符串<code>key</code>的类型。</p><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> LogLevel &#123;    ERROR, WARN, INFO, DEBUG&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 等同于：</span><span class="hljs-comment"> * type LogLevelStrings = &#x27;ERROR&#x27; | &#x27;WARN&#x27; | &#x27;INFO&#x27; | &#x27;DEBUG&#x27;;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">type</span> LogLevelStrings = keyof <span class="hljs-keyword">typeof</span> LogLevel;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printImportant</span>(<span class="hljs-params">key: LogLevelStrings, message: <span class="hljs-built_in">string</span></span>) </span>&#123;    <span class="hljs-keyword">const</span> num = LogLevel[key];    <span class="hljs-keyword">if</span> (num &lt;= LogLevel.WARN) &#123;       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Log level key is: &#x27;</span>, key);       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Log level value is: &#x27;</span>, num);       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Log level message is: &#x27;</span>, message);    &#125;&#125;printImportant(<span class="hljs-string">&#x27;ERROR&#x27;</span>, <span class="hljs-string">&#x27;This is a message&#x27;</span>);</code></pre><h4 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h4><p>除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了_反向映射_，从枚举值到枚举名字。 例如，在下面的例子中：</p><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Enum &#123;    A&#125;<span class="hljs-keyword">let</span> a = Enum.A;<span class="hljs-keyword">let</span> nameOfA = Enum[a]; <span class="hljs-comment">// &quot;A&quot;</span></code></pre><p>TypeScript可能会将这段代码编译为下面的JavaScript：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Enum;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Enum</span>) </span>&#123;    Enum[Enum[<span class="hljs-string">&quot;A&quot;</span>] = <span class="hljs-number">0</span>] = <span class="hljs-string">&quot;A&quot;</span>;&#125;)(Enum || (Enum = &#123;&#125;));<span class="hljs-keyword">var</span> a = Enum.A;<span class="hljs-keyword">var</span> nameOfA = Enum[a]; <span class="hljs-comment">// &quot;A&quot;</span></code></pre><p>生成的代码中，枚举类型被编译成一个对象，它包含了正向映射（<code>name</code> -&gt; <code>value</code>）和反向映射（<code>value</code> -&gt; <code>name</code>）。 引用枚举成员总会生成为对属性访问并且永远也不会内联代码。</p><p>要注意的是_不会_为字符串枚举成员生成反向映射。</p><h4 id="const枚举"><a href="#const枚举" class="headerlink" title="const枚举"></a><code>const</code>枚举</h4><p>大多数情况下，枚举是十分有效的方案。 然而在某些情况下需求很严格。 为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用<code>const</code>枚举。 常量枚举通过在枚举上使用<code>const</code>修饰符来定义。</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">enum</span> Enum &#123;    A = <span class="hljs-number">1</span>,    B = A * <span class="hljs-number">2</span>&#125;</code></pre><p>常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">enum</span> Directions &#123;    Up,    Down,    Left,    Right&#125;<span class="hljs-keyword">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]</code></pre><p>生成后的代码为：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> directions = [<span class="hljs-number">0</span> <span class="hljs-comment">/* Up */</span>, <span class="hljs-number">1</span> <span class="hljs-comment">/* Down */</span>, <span class="hljs-number">2</span> <span class="hljs-comment">/* Left */</span>, <span class="hljs-number">3</span> <span class="hljs-comment">/* Right */</span>];</code></pre><h2 id="外部枚举"><a href="#外部枚举" class="headerlink" title="外部枚举"></a>外部枚举</h2><p>外部枚举用来描述已经存在的枚举类型的形状。</p><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-built_in">enum</span> Enum &#123;    A = <span class="hljs-number">1</span>,    B,    C = <span class="hljs-number">2</span>&#125;</code></pre><p>外部枚举和非外部枚举之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常量成员。 对于非常量的外部枚举而言，没有初始化方法时被当做需要经过计算的。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;枚举&quot;&gt;&lt;a href=&quot;#枚举&quot; class=&quot;headerlink&quot; title=&quot;枚举&quot;&gt;&lt;/a&gt;枚举&lt;/h2&gt;&lt;p&gt;使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript支持数字的和基于字符串的枚举。&lt;/p&gt;</summary>
    
    
    
    <category term="typescript" scheme="https://tangxiaomi.top/categories/typescript/"/>
    
    
    <category term="typescript" scheme="https://tangxiaomi.top/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title> ios 提醒事项同步日历快捷指令脚本</title>
    <link href="https://tangxiaomi.top/2021/05/03/other/6238c21f55/"/>
    <id>https://tangxiaomi.top/2021/05/03/other/6238c21f55/</id>
    <published>2021-05-03T00:00:00.000Z</published>
    <updated>2021-06-24T01:47:53.076Z</updated>
    
    <content type="html"><![CDATA[<ul><li>AppStore 安装运行脚本的软件 <code>scriptable</code></li></ul><p><a href="https://docs.scriptable.app/">scriptable https://docs.scriptable.app</a></p><pre><code class="hljs js"><span class="hljs-keyword">const</span> DUR_MONTH = <span class="hljs-number">1</span><span class="hljs-keyword">const</span> startDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()startDate.setMonth(startDate.getMonth() - DUR_MONTH)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`日历的开始时间 <span class="hljs-subst">$&#123;startDate.toLocaleDateString()&#125;</span>`</span>)<span class="hljs-keyword">const</span> endDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()endDate.setMonth(endDate.getMonth() + DUR_MONTH)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`日历的结束时间 <span class="hljs-subst">$&#123;endDate.toLocaleDateString()&#125;</span>`</span>)<span class="hljs-keyword">const</span> reminders = <span class="hljs-keyword">await</span> Reminder.allDueBetween(startDate, endDate)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`获取 <span class="hljs-subst">$&#123;reminders.length&#125;</span> 条提醒事项`</span>)<span class="hljs-keyword">var</span> calendar = <span class="hljs-keyword">await</span> Calendar.forEvents()<span class="hljs-comment">//获取日历名和对应的日历</span><span class="hljs-keyword">var</span> m_dict = &#123;&#125;<span class="hljs-keyword">for</span> (cal <span class="hljs-keyword">of</span> calendar) &#123;    m_dict[cal.title] = cal&#125;<span class="hljs-keyword">const</span> events = <span class="hljs-keyword">await</span> CalendarEvent.between(startDate, endDate, calendar)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`获取 <span class="hljs-subst">$&#123;events.length&#125;</span> 条日历`</span>)<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> reminder <span class="hljs-keyword">of</span> reminders) &#123;    <span class="hljs-comment">//reminder的标识符</span>    <span class="hljs-keyword">const</span> id = reminder.identifier.split(<span class="hljs-string">&#x27;-&#x27;</span>)[<span class="hljs-number">0</span>]    <span class="hljs-keyword">const</span> targetNote = <span class="hljs-string">`🍧 <span class="hljs-subst">$&#123;id&#125;</span> 🍰`</span>    <span class="hljs-comment">// 添加标识符存进备注 用来防止重复添加</span>    <span class="hljs-keyword">const</span> [targetEvent] = events.filter(        <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e.notes != <span class="hljs-literal">null</span> &amp;&amp; e.notes.indexOf(targetNote) != -<span class="hljs-number">1</span>    ) <span class="hljs-comment">//过滤重复的reminder</span>    <span class="hljs-keyword">if</span> (!m_dict[reminder.calendar.title]) &#123;        <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">&#x27;找不到日历&#x27;</span> + reminder.calendar.title)        <span class="hljs-keyword">continue</span>    &#125;    <span class="hljs-keyword">if</span> (targetEvent) &#123;        <span class="hljs-comment">//console.log(`找到已经创建的事项 $&#123;reminder.title&#125;`)</span>        updateEvent(targetEvent, reminder)    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`创建事项 <span class="hljs-subst">$&#123;reminder.title&#125;</span> 到 <span class="hljs-subst">$&#123;reminder.calendar.title&#125;</span>`</span>)        <span class="hljs-keyword">const</span> newEvent = <span class="hljs-keyword">new</span> CalendarEvent()        <span class="hljs-keyword">const</span> notes = reminder.notes ? reminder.notes : <span class="hljs-string">&#x27;&#x27;</span>        newEvent.notes = targetNote + <span class="hljs-string">&#x27;\n\n&#x27;</span> + notes <span class="hljs-comment">//要加入备注</span>        updateEvent(newEvent, reminder)    &#125;&#125;Script.complete()<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateEvent</span>(<span class="hljs-params">event, reminder</span>) </span>&#123;    event.title = <span class="hljs-string">`<span class="hljs-subst">$&#123;reminder.title&#125;</span>`</span>    cal_name = reminder.calendar.title    cal = m_dict[cal_name]    event.calendar = cal    <span class="hljs-comment">//已完成事项</span>    <span class="hljs-keyword">if</span> (reminder.isCompleted) &#123;        event.title = <span class="hljs-string">`✅ <span class="hljs-subst">$&#123;reminder.title&#125;</span>`</span>        event.isAllDay = <span class="hljs-literal">false</span>        event.startDate = reminder.completionDate        <span class="hljs-keyword">var</span> ending = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(reminder.completionDate)        ending.setHours(ending.getHours() + <span class="hljs-number">1</span>)        event.endDate = ending        <span class="hljs-keyword">var</span> period =            (reminder.dueDate - reminder.completionDate) / <span class="hljs-number">1000</span> / <span class="hljs-number">3600</span> / <span class="hljs-number">24</span>        period = period.toFixed(<span class="hljs-number">1</span>)        <span class="hljs-keyword">if</span> (period &lt; <span class="hljs-number">0</span>) &#123;            period = -period            event.location = <span class="hljs-string">&#x27; 延期&#x27;</span> + period + <span class="hljs-string">&#x27;天完成&#x27;</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (period == <span class="hljs-number">0</span>) &#123;            event.location = <span class="hljs-string">&#x27; 准时完成&#x27;</span>        &#125; <span class="hljs-keyword">else</span> &#123;            event.location = <span class="hljs-string">&#x27; 提前&#x27;</span> + period + <span class="hljs-string">&#x27;天完成&#x27;</span>        &#125;    &#125;    <span class="hljs-comment">//未完成事项</span>    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">const</span> nowtime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()        <span class="hljs-keyword">var</span> period = (reminder.dueDate - nowtime) / <span class="hljs-number">1000</span> / <span class="hljs-number">3600</span> / <span class="hljs-number">24</span>        period = period.toFixed(<span class="hljs-number">1</span>)        <span class="hljs-keyword">if</span> (period &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//待办顺延</span>            event.location = <span class="hljs-string">&#x27; 延期&#x27;</span> + -period + <span class="hljs-string">&#x27;天&#x27;</span>            <span class="hljs-comment">//如果不是在同一天,设置为全天事项</span>            <span class="hljs-keyword">if</span> (reminder.dueDate.getDate() != nowtime.getDate()) &#123;                event.title = <span class="hljs-string">`❌ <span class="hljs-subst">$&#123;reminder.title&#125;</span>`</span>                event.startDate = nowtime                event.endDate = nowtime                event.isAllDay = <span class="hljs-literal">true</span>            &#125;            <span class="hljs-comment">//在同一天的保持原来的时间</span>            <span class="hljs-keyword">else</span> &#123;                event.title = <span class="hljs-string">`⭕️ <span class="hljs-subst">$&#123;reminder.title&#125;</span>`</span>                event.isAllDay = <span class="hljs-literal">false</span>                event.startDate = reminder.dueDate                <span class="hljs-keyword">var</span> ending = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(reminder.dueDate)                ending.setHours(ending.getHours() + <span class="hljs-number">1</span>)                event.endDate = ending            &#125;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`【<span class="hljs-subst">$&#123;reminder.title&#125;</span>】待办顺延<span class="hljs-subst">$&#123;-period&#125;</span>天`</span>)        &#125; <span class="hljs-keyword">else</span> &#123;            event.title = <span class="hljs-string">`⭕️ <span class="hljs-subst">$&#123;reminder.title&#125;</span>`</span>            event.isAllDay = <span class="hljs-literal">false</span>            event.location = <span class="hljs-string">&#x27;还剩&#x27;</span> + period + <span class="hljs-string">&#x27;天&#x27;</span>            event.startDate = reminder.dueDate            <span class="hljs-keyword">var</span> ending = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(reminder.dueDate)            ending.setHours(ending.getHours() + <span class="hljs-number">1</span>)            event.endDate = ending        &#125;    &#125;    event.save()&#125;</code></pre><ul><li>提醒事项数据格式</li></ul><pre><code class="hljs json">&#123;  <span class="hljs-attr">&quot;identifier&quot;</span>: <span class="hljs-string">&quot;29803A1E-6C2F-454D-B366-2C67EB1F24BD&quot;</span>,  <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;Recite word&quot;</span>,  <span class="hljs-attr">&quot;isCompleted&quot;</span>: <span class="hljs-literal">false</span>,  <span class="hljs-attr">&quot;isOverdue&quot;</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">&quot;priority&quot;</span>: <span class="hljs-number">0</span>,  <span class="hljs-attr">&quot;dueDate&quot;</span>: <span class="hljs-string">&quot;2021-03-11T23:20:00.000Z&quot;</span>,  <span class="hljs-attr">&quot;dueDateIncludesTime&quot;</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">&quot;completionDate&quot;</span>: <span class="hljs-literal">null</span>,  <span class="hljs-attr">&quot;creationDate&quot;</span>: <span class="hljs-string">&quot;2021-03-12T03:28:00.621Z&quot;</span>,  <span class="hljs-attr">&quot;calendar&quot;</span>: &#123;    <span class="hljs-attr">&quot;identifier&quot;</span>: <span class="hljs-string">&quot;282088E0-DC16-4827-BA21-9B9FD5F0A16F&quot;</span>,    <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;Learn&quot;</span>,    <span class="hljs-attr">&quot;isSubscribed&quot;</span>: <span class="hljs-literal">false</span>,    <span class="hljs-attr">&quot;allowsContentModifications&quot;</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">&quot;color&quot;</span>: &#123;      <span class="hljs-attr">&quot;hex&quot;</span>: <span class="hljs-string">&quot;FF2968&quot;</span>,      <span class="hljs-attr">&quot;red&quot;</span>: <span class="hljs-number">1</span>,      <span class="hljs-attr">&quot;green&quot;</span>: <span class="hljs-number">0.1607843041419983</span>,      <span class="hljs-attr">&quot;blue&quot;</span>: <span class="hljs-number">0.40784314274787903</span>,      <span class="hljs-attr">&quot;alpha&quot;</span>: <span class="hljs-number">1</span>    &#125;  &#125;&#125;</code></pre><p><a href="https://tangxiaomi.top/2021/03/12/other/reminders-sync-calendar/">ios 提醒事项同步日历快捷指令脚本</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;AppStore 安装运行脚本的软件 &lt;code&gt;scriptable&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.scriptable.app/&quot;&gt;scriptable https://docs.scriptable.</summary>
      
    
    
    
    <category term="other" scheme="https://tangxiaomi.top/categories/other/"/>
    
    
    <category term="other" scheme="https://tangxiaomi.top/tags/other/"/>
    
  </entry>
  
  <entry>
    <title> 类</title>
    <link href="https://tangxiaomi.top/2021/05/03/typescript/98dfa9bae0/"/>
    <id>https://tangxiaomi.top/2021/05/03/typescript/98dfa9bae0/</id>
    <published>2021-05-03T00:00:00.000Z</published>
    <updated>2021-06-24T01:47:53.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。</p><a id="more"></a><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>下面看一个使用类的例子：</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeter</span> </span>&#123;    <span class="hljs-attr">greeting</span>: <span class="hljs-built_in">string</span>;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>)</span> &#123;        <span class="hljs-built_in">this</span>.greeting = message;    &#125;    <span class="hljs-function"><span class="hljs-title">greet</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-built_in">this</span>.greeting;    &#125;&#125;<span class="hljs-keyword">let</span> greeter = <span class="hljs-keyword">new</span> Greeter(<span class="hljs-string">&quot;world&quot;</span>);</code></pre><p>如果你使用过C#或Java，你会对这种语法非常熟悉。 我们声明一个<code>Greeter</code>类。这个类有3个成员：一个叫做<code>greeting</code>的属性，一个构造函数和一个<code>greet</code>方法。</p><p>你会注意到，我们在引用任何一个类成员的时候都用了<code>this</code>。 它表示我们访问的是类的成员。</p><p>最后一行，我们使用<code>new</code>构造了<code>Greeter</code>类的一个实例。 它会调用之前定义的构造函数，创建一个<code>Greeter</code>类型的新对象，并执行构造函数初始化它。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p><p>看下面的例子：</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>)</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Animal moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">bark</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Woof! Woof!&#x27;</span>);    &#125;&#125;<span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> Dog();dog.bark();dog.move(<span class="hljs-number">10</span>);dog.bark();</code></pre><p>这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，<code>Dog</code>是一个_派生类_，它派生自<code>Animal</code><em>基类</em>，通过<code>extends</code>关键字。 派生类通常被称作_子类_，基类通常被称作_超类_。</p><p>因为<code>Dog</code>继承了<code>Animal</code>的功能，因此我们可以创建一个<code>Dog</code>的实例，它能够<code>bark()</code>和<code>move()</code>。</p><p>下面我们来看个更加复杂的例子。</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>)</span> &#123; <span class="hljs-built_in">this</span>.name = theName; &#125;    <span class="hljs-function"><span class="hljs-title">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>)</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Snake</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>)</span> &#123; <span class="hljs-built_in">super</span>(name); &#125;    <span class="hljs-function"><span class="hljs-title">move</span>(<span class="hljs-params">distanceInMeters = <span class="hljs-number">5</span></span>)</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Slithering...&quot;</span>);        <span class="hljs-built_in">super</span>.move(distanceInMeters);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Horse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>)</span> &#123; <span class="hljs-built_in">super</span>(name); &#125;    <span class="hljs-function"><span class="hljs-title">move</span>(<span class="hljs-params">distanceInMeters = <span class="hljs-number">45</span></span>)</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Galloping...&quot;</span>);        <span class="hljs-built_in">super</span>.move(distanceInMeters);    &#125;&#125;<span class="hljs-keyword">let</span> sam = <span class="hljs-keyword">new</span> Snake(<span class="hljs-string">&quot;Sammy the Python&quot;</span>);<span class="hljs-keyword">let</span> tom: Animal = <span class="hljs-keyword">new</span> Horse(<span class="hljs-string">&quot;Tommy the Palomino&quot;</span>);sam.move();tom.move(<span class="hljs-number">34</span>);</code></pre><p>这个例子展示了一些上面没有提到的特性。 这一次，我们使用<code>extends</code>关键字创建了<code>Animal</code>的两个子类：<code>Horse</code>和<code>Snake</code>。</p><p>与前一个例子的不同点是，派生类包含了一个构造函数，它_必须_调用<code>super()</code>，它会执行基类的构造函数。 而且，在构造函数里访问<code>this</code>的属性之前，我们_一定_要调用<code>super()</code>。 这个是TypeScript强制执行的一条重要规则。</p><p>这个例子演示了如何在子类里可以重写父类的方法。 <code>Snake</code>类和<code>Horse</code>类都创建了<code>move</code>方法，它们重写了从<code>Animal</code>继承来的<code>move</code>方法，使得<code>move</code>方法根据不同的类而具有不同的功能。 注意，即使<code>tom</code>被声明为<code>Animal</code>类型，但因为它的值是<code>Horse</code>，调用<code>tom.move(34)</code>时，它会调用<code>Horse</code>里重写的方法：</p><pre><code class="hljs text">Slithering...Sammy the Python moved 5m.Galloping...Tommy the Palomino moved 34m.</code></pre><h2 id="公共，私有与受保护的修饰符"><a href="#公共，私有与受保护的修饰符" class="headerlink" title="公共，私有与受保护的修饰符"></a>公共，私有与受保护的修饰符</h2><h3 id="默认为public"><a href="#默认为public" class="headerlink" title="默认为public"></a>默认为<code>public</code></h3><p>在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用<code>public</code>来做修饰；例如，C#要求必须明确地使用<code>public</code>指定成员是可见的。 在TypeScript里，成员都默认为<code>public</code>。</p><p>你也可以明确的将一个成员标记成<code>public</code>。 我们可以用下面的方式来重写上面的<code>Animal</code>类：</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;    <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span>;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>)</span> &#123; <span class="hljs-built_in">this</span>.name = theName; &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span></span>)</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);    &#125;&#125;</code></pre><h3 id="理解private"><a href="#理解private" class="headerlink" title="理解private"></a>理解<code>private</code></h3><p>当成员被标记成<code>private</code>时，它就不能在声明它的类的外部访问。比如：</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;    <span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span>;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>)</span> &#123; <span class="hljs-built_in">this</span>.name = theName; &#125;&#125;<span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&quot;Cat&quot;</span>).name; <span class="hljs-comment">// 错误: &#x27;name&#x27; 是私有的.</span></code></pre><p>TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。</p><p>然而，当我们比较带有<code>private</code>或<code>protected</code>成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个<code>private</code>成员，那么只有当另外一个类型中也存在这样一个<code>private</code>成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于<code>protected</code>成员也使用这个规则。</p><p>下面来看一个例子，更好地说明了这一点：</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;    <span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span>;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>)</span> &#123; <span class="hljs-built_in">this</span>.name = theName; &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rhino</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;Rhino&quot;</span>); &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;    <span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span>;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>)</span> &#123; <span class="hljs-built_in">this</span>.name = theName; &#125;&#125;<span class="hljs-keyword">let</span> animal = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&quot;Goat&quot;</span>);<span class="hljs-keyword">let</span> rhino = <span class="hljs-keyword">new</span> Rhino();<span class="hljs-keyword">let</span> employee = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">&quot;Bob&quot;</span>);animal = rhino;animal = employee; <span class="hljs-comment">// 错误: Animal 与 Employee 不兼容.</span></code></pre><p>这个例子中有<code>Animal</code>和<code>Rhino</code>两个类，<code>Rhino</code>是<code>Animal</code>类的子类。 还有一个<code>Employee</code>类，其类型看上去与<code>Animal</code>是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为<code>Animal</code>和<code>Rhino</code>共享了来自<code>Animal</code>里的私有成员定义<code>private name: string</code>，因此它们是兼容的。 然而<code>Employee</code>却不是这样。当把<code>Employee</code>赋值给<code>Animal</code>的时候，得到一个错误，说它们的类型不兼容。 尽管<code>Employee</code>里也有一个私有成员<code>name</code>，但它明显不是<code>Animal</code>里面定义的那个。</p><h3 id="理解protected"><a href="#理解protected" class="headerlink" title="理解protected"></a>理解<code>protected</code></h3><p><code>protected</code>修饰符与<code>private</code>修饰符的行为很相似，但有一点不同，<code>protected</code>成员在派生类中仍然可以访问。例如：</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">protected</span> name: <span class="hljs-built_in">string</span>;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>)</span> &#123; <span class="hljs-built_in">this</span>.name = name; &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> department: <span class="hljs-built_in">string</span>;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, department: <span class="hljs-built_in">string</span></span>)</span> &#123;        <span class="hljs-built_in">super</span>(name)        <span class="hljs-built_in">this</span>.department = department;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">getElevatorPitch</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> and I work in <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.department&#125;</span>.`</span>;    &#125;&#125;<span class="hljs-keyword">let</span> howard = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">&quot;Howard&quot;</span>, <span class="hljs-string">&quot;Sales&quot;</span>);<span class="hljs-built_in">console</span>.log(howard.getElevatorPitch());<span class="hljs-built_in">console</span>.log(howard.name); <span class="hljs-comment">// 错误</span></code></pre><p>注意，我们不能在<code>Person</code>类外使用<code>name</code>，但是我们仍然可以通过<code>Employee</code>类的实例方法访问，因为<code>Employee</code>是由<code>Person</code>派生而来的。</p><p>构造函数也可以被标记成<code>protected</code>。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如，</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">protected</span> name: <span class="hljs-built_in">string</span>;    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>)</span> &#123; <span class="hljs-built_in">this</span>.name = theName; &#125;&#125;<span class="hljs-comment">// Employee 能够继承 Person</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> department: <span class="hljs-built_in">string</span>;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, department: <span class="hljs-built_in">string</span></span>)</span> &#123;        <span class="hljs-built_in">super</span>(name);        <span class="hljs-built_in">this</span>.department = department;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">getElevatorPitch</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> and I work in <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.department&#125;</span>.`</span>;    &#125;&#125;<span class="hljs-keyword">let</span> howard = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">&quot;Howard&quot;</span>, <span class="hljs-string">&quot;Sales&quot;</span>);<span class="hljs-keyword">let</span> john = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;John&quot;</span>); <span class="hljs-comment">// 错误: &#x27;Person&#x27; 的构造函数是被保护的.</span></code></pre><h2 id="readonly修饰符"><a href="#readonly修饰符" class="headerlink" title="readonly修饰符"></a>readonly修饰符</h2><p>你可以使用<code>readonly</code>关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Octopus</span> </span>&#123;    <span class="hljs-keyword">readonly</span> name: <span class="hljs-built_in">string</span>;    <span class="hljs-keyword">readonly</span> numberOfLegs: <span class="hljs-built_in">number</span> = <span class="hljs-number">8</span>;    <span class="hljs-title">constructor</span> (<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>) &#123;        <span class="hljs-built_in">this</span>.name = theName;    &#125;&#125;<span class="hljs-keyword">let</span> dad = <span class="hljs-keyword">new</span> Octopus(<span class="hljs-string">&quot;Man with the 8 strong legs&quot;</span>);dad.name = <span class="hljs-string">&quot;Man with the 3-piece suit&quot;</span>; <span class="hljs-comment">// 错误! name 是只读的.</span></code></pre><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>在上面的例子中，我们不得不在在<code>Person</code>类里定义一个只读成员<code>name</code>和一个构造函数参数<code>theName</code>。这样做是为了在<code>Octopus</code>构造函数被执行后，就可以访问<code>theName</code>的值。 这种情况经常会遇到。_参数属性_可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前<code>Animal</code>类的修改版，使用了参数属性：</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span></span>)</span> &#123; &#125;    <span class="hljs-function"><span class="hljs-title">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span></span>)</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);    &#125;&#125;</code></pre><p>注意看我们是如何舍弃了<code>theName</code>，仅在构造函数里使用<code>private name: string</code>参数来创建和初始化<code>name</code>成员。 我们把声明和赋值合并至一处。</p><p>参数属性通过给构造函数参数添加一个访问限定符来声明。 使用<code>private</code>限定一个参数属性会声明并初始化一个私有成员；对于<code>public</code>和<code>protected</code>来说也是一样。</p><h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><p>TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p><p>下面来看如何把一个简单的类改写成使用<code>get</code>和<code>set</code>。 首先，我们从一个没有使用存取器的例子开始。</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;    <span class="hljs-attr">fullName</span>: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-keyword">let</span> employee = <span class="hljs-keyword">new</span> Employee();employee.fullName = <span class="hljs-string">&quot;Bob Smith&quot;</span>;<span class="hljs-keyword">if</span> (employee.fullName) &#123;    <span class="hljs-built_in">console</span>.log(employee.fullName);&#125;</code></pre><p>允许随意设置<code>fullName</code>虽然方便，但是我们仍想在设置<code>fullName</code>强制执行某些约束。</p><p>在这个版本里，我们添加一个<code>setter</code>来检查<code>newName</code>的长度，以确保它满足数据库字段的最大长度限制。若它不满足，那么我们就抛一个错误来告诉客户端出错了。</p><p>为保留原有的功能，我们同时添加一个<code>getter</code>用来读取<code>fullName</code>。</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> fullNameMaxLength = <span class="hljs-number">10</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;    <span class="hljs-keyword">private</span> _fullName: <span class="hljs-built_in">string</span>;    <span class="hljs-keyword">get</span> <span class="hljs-title">fullName</span>(): <span class="hljs-title">string</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._fullName;    &#125;    <span class="hljs-keyword">set</span> <span class="hljs-title">fullName</span>(<span class="hljs-params">newName: <span class="hljs-built_in">string</span></span>) &#123;        <span class="hljs-keyword">if</span> (newName &amp;&amp; newName.length &gt; fullNameMaxLength) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;fullName has a max length of &quot;</span> + fullNameMaxLength);        &#125;        <span class="hljs-built_in">this</span>._fullName = newName;    &#125;&#125;<span class="hljs-keyword">let</span> employee = <span class="hljs-keyword">new</span> Employee();employee.fullName = <span class="hljs-string">&quot;Bob Smith&quot;</span>;<span class="hljs-keyword">if</span> (employee.fullName) &#123;    alert(employee.fullName);&#125;</code></pre><p>为证明我们写的存取器现在能检查长度，我们可以给名字赋一个长度大于<code>10</code>字符的值，并验证是否得到一个错误。</p><p>对于存取器有下面几点需要注意的：</p><p>首先，存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有<code>get</code>不带有<code>set</code>的存取器自动被推断为<code>readonly</code>。 这在从代码生成<code>.d.ts</code>文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</p><h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p>到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用<code>static</code>定义<code>origin</code>，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在<code>origin</code>前面加上类名。 如同在实例属性上使用<code>this.</code>前缀来访问属性一样，这里我们使用<code>Grid.</code>来访问静态属性。</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Grid</span> </span>&#123;    <span class="hljs-keyword">static</span> origin = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>&#125;;    <span class="hljs-function"><span class="hljs-title">calculateDistanceFromOrigin</span>(<span class="hljs-params">point: &#123;x: <span class="hljs-built_in">number</span>; y: <span class="hljs-built_in">number</span>;&#125;</span>)</span> &#123;        <span class="hljs-keyword">let</span> xDist = (point.x - Grid.origin.x);        <span class="hljs-keyword">let</span> yDist = (point.y - Grid.origin.y);        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.sqrt(xDist * xDist + yDist * yDist) / <span class="hljs-built_in">this</span>.scale;    &#125;    <span class="hljs-title">constructor</span> (<span class="hljs-params"><span class="hljs-keyword">public</span> scale: <span class="hljs-built_in">number</span></span>) &#123; &#125;&#125;<span class="hljs-keyword">let</span> grid1 = <span class="hljs-keyword">new</span> Grid(<span class="hljs-number">1.0</span>);  <span class="hljs-comment">// 1x scale</span><span class="hljs-keyword">let</span> grid2 = <span class="hljs-keyword">new</span> Grid(<span class="hljs-number">5.0</span>);  <span class="hljs-comment">// 5x scale</span><span class="hljs-built_in">console</span>.log(grid1.calculateDistanceFromOrigin(&#123;<span class="hljs-attr">x</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">10</span>&#125;));<span class="hljs-built_in">console</span>.log(grid2.calculateDistanceFromOrigin(&#123;<span class="hljs-attr">x</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">10</span>&#125;));</code></pre><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节（抽象类中除抽象函数之外，其他函数可以包含具体实现）。 <code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;    <span class="hljs-keyword">abstract</span> makeSound(): <span class="hljs-built_in">void</span>;    move(): <span class="hljs-built_in">void</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;roaming the earth...&quot;</span>);    &#125;&#125;</code></pre><p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含<code>abstract</code>关键字并且可以包含访问修饰符。</p><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Department</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>)</span> &#123;    &#125;    printName(): <span class="hljs-built_in">void</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Department name: &#x27;</span> + <span class="hljs-built_in">this</span>.name);    &#125;    <span class="hljs-keyword">abstract</span> printMeeting(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 必须在派生类中实现</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountingDepartment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Department</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-built_in">super</span>(<span class="hljs-string">&#x27;Accounting and Auditing&#x27;</span>); <span class="hljs-comment">// 在派生类的构造函数中必须调用 super()</span>    &#125;    printMeeting(): <span class="hljs-built_in">void</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The Accounting Department meets each Monday at 10am.&#x27;</span>);    &#125;    generateReports(): <span class="hljs-built_in">void</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Generating accounting reports...&#x27;</span>);    &#125;&#125;<span class="hljs-keyword">let</span> department: Department; <span class="hljs-comment">// 允许创建一个对抽象类型的引用</span>department = <span class="hljs-keyword">new</span> Department(); <span class="hljs-comment">// 错误: 不能创建一个抽象类的实例</span>department = <span class="hljs-keyword">new</span> AccountingDepartment(); <span class="hljs-comment">// 允许对一个抽象子类进行实例化和赋值</span>department.printName();department.printMeeting();department.generateReports(); <span class="hljs-comment">// 错误: 方法在声明的抽象类中不存在</span></code></pre><h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>当你在TypeScript里声明了一个类的时候，实际上同时声明了很多东西。 首先就是类的_实例_的类型。</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeter</span> </span>&#123;    <span class="hljs-attr">greeting</span>: <span class="hljs-built_in">string</span>;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>)</span> &#123;        <span class="hljs-built_in">this</span>.greeting = message;    &#125;    <span class="hljs-function"><span class="hljs-title">greet</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-built_in">this</span>.greeting;    &#125;&#125;<span class="hljs-keyword">let</span> greeter: Greeter;greeter = <span class="hljs-keyword">new</span> Greeter(<span class="hljs-string">&quot;world&quot;</span>);<span class="hljs-built_in">console</span>.log(greeter.greet());</code></pre><p>这里，我们写了<code>let greeter: Greeter</code>，意思是<code>Greeter</code>类的实例的类型是<code>Greeter</code>。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。</p><p>我们也创建了一个叫做_构造函数_的值。 这个函数会在我们使用<code>new</code>创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：</p><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> Greeter = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeter</span>(<span class="hljs-params">message</span>) </span>&#123;        <span class="hljs-built_in">this</span>.greeting = message;    &#125;    Greeter.prototype.greet = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-built_in">this</span>.greeting;    &#125;;    <span class="hljs-keyword">return</span> Greeter;&#125;)();<span class="hljs-keyword">let</span> greeter;greeter = <span class="hljs-keyword">new</span> Greeter(<span class="hljs-string">&quot;world&quot;</span>);<span class="hljs-built_in">console</span>.log(greeter.greet());</code></pre><p>上面的代码里，<code>let Greeter</code>将被赋值为构造函数。 当我们调用<code>new</code>并执行了这个函数后，便会得到一个类的实例。 这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有_实例部分_与_静态部分_这两个部分。</p><p>让我们稍微改写一下这个例子，看看它们之间的区别：</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeter</span> </span>&#123;    <span class="hljs-keyword">static</span> standardGreeting = <span class="hljs-string">&quot;Hello, there&quot;</span>;    greeting: <span class="hljs-built_in">string</span>;    <span class="hljs-function"><span class="hljs-title">greet</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.greeting) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-built_in">this</span>.greeting;        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> Greeter.standardGreeting;        &#125;    &#125;&#125;<span class="hljs-keyword">let</span> greeter1: Greeter;greeter1 = <span class="hljs-keyword">new</span> Greeter();<span class="hljs-built_in">console</span>.log(greeter1.greet());<span class="hljs-keyword">let</span> greeterMaker: <span class="hljs-keyword">typeof</span> Greeter = Greeter;greeterMaker.standardGreeting = <span class="hljs-string">&quot;Hey there!&quot;</span>;<span class="hljs-keyword">let</span> greeter2: Greeter = <span class="hljs-keyword">new</span> greeterMaker();<span class="hljs-built_in">console</span>.log(greeter2.greet());</code></pre><p>这个例子里，<code>greeter1</code>与之前看到的一样。 我们实例化<code>Greeter</code>类，并使用这个对象。 与我们之前看到的一样。</p><p>再之后，我们直接使用类。 我们创建了一个叫做<code>greeterMaker</code>的变量。 这个变量保存了这个类或者说保存了类构造函数。 然后我们使用<code>typeof Greeter</code>，意思是取Greeter类的类型，而不是实例的类型。 或者更确切的说，”告诉我<code>Greeter</code>标识符的类型”，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在<code>greeterMaker</code>上使用<code>new</code>，创建<code>Greeter</code>的实例。</p><h3 id="把类当做接口使用"><a href="#把类当做接口使用" class="headerlink" title="把类当做接口使用"></a>把类当做接口使用</h3><p>如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;    y: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-keyword">interface</span> Point3d <span class="hljs-keyword">extends</span> Point &#123;    <span class="hljs-attr">z</span>: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-keyword">let</span> point3d: Point3d = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">3</span>&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。&lt;/p&gt;</summary>
    
    
    
    <category term="typescript" scheme="https://tangxiaomi.top/categories/typescript/"/>
    
    
    <category term="typescript" scheme="https://tangxiaomi.top/tags/typescript/"/>
    
  </entry>
  
</feed>

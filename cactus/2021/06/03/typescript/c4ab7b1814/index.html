<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="介绍TypeScript 的核心原则之一是对值所具有的_结构_进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。">
<meta property="og:type" content="article">
<meta property="og:title" content=" 接口">
<meta property="og:url" content="https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/index.html">
<meta property="og:site_name" content="糖小米 · 博客">
<meta property="og:description" content="介绍TypeScript 的核心原则之一是对值所具有的_结构_进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-06-03T00:00:00.000Z">
<meta property="article:modified_time" content="2021-06-24T01:47:53.076Z">
<meta property="article:author" content="糖小米">
<meta property="article:tag" content="typescript">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/cactus/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/cactus/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/cactus/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title> 接口</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/cactus/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/cactus/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.0.0"><link rel="alternate" href="/cactus/atom.xml" title="糖小米 · 博客" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/cactus/">首页</a></li>
         
          <li><a href="/cactus/tags/">标签</a></li>
         
          <li><a href="/cactus/archives/">归档</a></li>
         
          <li><a href="/cactus/search/">搜索</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/cactus/2021/06/03/typescript/c4dbac2ca2/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/cactus/2021/06/02/interview/ac86bf5243/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <!-- <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li> -->
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/&text= 接口"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/&title= 接口"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/&is_video=false&description= 接口"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject= 接口&body=Check out this article: https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/&title= 接口"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/&title= 接口"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/&title= 接口"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/&title= 接口"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/&name= 接口&description=&lt;h2 id=&#34;介绍&#34;&gt;&lt;a href=&#34;#介绍&#34; class=&#34;headerlink&#34; title=&#34;介绍&#34;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;TypeScript 的核心原则之一是对值所具有的_结构_进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。&lt;/p&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/&t= 接口"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%88%9D%E6%8E%A2"><span class="toc-number">2.</span> <span class="toc-text">接口初探</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">可选属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">4.</span> <span class="toc-text">只读属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#readonly-vs-const"><span class="toc-number">4.1.</span> <span class="toc-text">readonly vs const</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84%E5%B1%9E%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="toc-number">5.</span> <span class="toc-text">额外的属性检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">函数类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.</span> <span class="toc-text">可索引的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">类类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.1.</span> <span class="toc-text">实现接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E9%9D%99%E6%80%81%E9%83%A8%E5%88%86%E4%B8%8E%E5%AE%9E%E4%BE%8B%E9%83%A8%E5%88%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.2.</span> <span class="toc-text">类静态部分与实例部分的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.</span> <span class="toc-text">继承接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.</span> <span class="toc-text">混合类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E7%B1%BB"><span class="toc-number">11.</span> <span class="toc-text">接口继承类</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
         接口
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">糖小米</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-06-03T00:00:00.000Z" itemprop="datePublished">2021-06-03</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/cactus/categories/typescript/">typescript</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/cactus/tags/typescript/" rel="tag">typescript</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>TypeScript 的核心原则之一是对值所具有的_结构_进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>
<a id="more"></a>

<h2 id="接口初探"><a href="#接口初探" class="headerlink" title="接口初探"></a>接口初探</h2><p>下面通过一个简单示例来观察接口是如何工作的：</p>
<pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printLabel</span>(<span class="hljs-params">labeledObj: &#123; label: <span class="hljs-built_in">string</span> &#125;</span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(labeledObj.label);
&#125;

<span class="hljs-keyword">let</span> myObj = &#123; <span class="hljs-attr">size</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;Size 10 Object&quot;</span> &#125;;
printLabel(myObj);</code></pre>

<p>类型检查器会查看<code>printLabel</code>的调用。 <code>printLabel</code>有一个参数，并要求这个对象参数有一个名为<code>label</code>类型为<code>string</code>的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候 TypeScript 却并不会这么宽松，我们下面会稍做讲解。</p>
<p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个<code>label</code>属性且类型为<code>string</code>：</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> LabeledValue &#123;
  <span class="hljs-attr">label</span>: <span class="hljs-built_in">string</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printLabel</span>(<span class="hljs-params">labeledObj: LabeledValue</span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(labeledObj.label);
&#125;

<span class="hljs-keyword">let</span> myObj = &#123; <span class="hljs-attr">size</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;Size 10 Object&quot;</span> &#125;;
printLabel(myObj);</code></pre>

<p><code>LabeledValue</code>接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个<code>label</code>属性且类型为<code>string</code>的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给<code>printLabel</code>的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p>
<p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p>
<h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p>
<p>下面是应用了“option bags”的例子：</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> SquareConfig &#123;
  color?: <span class="hljs-built_in">string</span>;
  width?: <span class="hljs-built_in">number</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSquare</span>(<span class="hljs-params">config: SquareConfig</span>): </span>&#123; color: <span class="hljs-built_in">string</span>; area: <span class="hljs-built_in">number</span> &#125; &#123;
  <span class="hljs-keyword">let</span> newSquare = &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;white&quot;</span>, <span class="hljs-attr">area</span>: <span class="hljs-number">100</span> &#125;;
  <span class="hljs-keyword">if</span> (config.color) &#123;
    newSquare.color = config.color;
  &#125;
  <span class="hljs-keyword">if</span> (config.width) &#123;
    newSquare.area = config.width * config.width;
  &#125;
  <span class="hljs-keyword">return</span> newSquare;
&#125;

<span class="hljs-keyword">let</span> mySquare = createSquare(&#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;black&quot;</span> &#125;);</code></pre>

<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个<code>?</code>符号。</p>
<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将<code>createSquare</code>里的<code>color</code>属性名拼错，就会得到一个错误提示：</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> SquareConfig &#123;
  color?: <span class="hljs-built_in">string</span>;
  width?: <span class="hljs-built_in">number</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSquare</span>(<span class="hljs-params">config: SquareConfig</span>): </span>&#123; color: <span class="hljs-built_in">string</span>; area: <span class="hljs-built_in">number</span> &#125; &#123;
  <span class="hljs-keyword">let</span> newSquare = &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;white&quot;</span>, <span class="hljs-attr">area</span>: <span class="hljs-number">100</span> &#125;;
  <span class="hljs-keyword">if</span> (config.clor) &#123;
    <span class="hljs-comment">// Error: Property &#x27;clor&#x27; does not exist on type &#x27;SquareConfig&#x27;</span>
    newSquare.color = config.clor;
  &#125;
  <span class="hljs-keyword">if</span> (config.width) &#123;
    newSquare.area = config.width * config.width;
  &#125;
  <span class="hljs-keyword">return</span> newSquare;
&#125;

<span class="hljs-keyword">let</span> mySquare = createSquare(&#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;black&quot;</span> &#125;);</code></pre>

<h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用<code>readonly</code>来指定只读属性:</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Point &#123;
  <span class="hljs-keyword">readonly</span> x: <span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">readonly</span> y: <span class="hljs-built_in">number</span>;
&#125;</code></pre>

<p>你可以通过赋值一个对象字面量来构造一个<code>Point</code>。 赋值后，<code>x</code>和<code>y</code>再也不能被改变了。</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">let</span> p1: Point = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">20</span> &#125;;
p1.x = <span class="hljs-number">5</span>; <span class="hljs-comment">// error!</span></code></pre>

<p>TypeScript 具有<code>ReadonlyArray&lt;T&gt;</code>类型，它与<code>Array&lt;T&gt;</code>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
<span class="hljs-keyword">let</span> ro: ReadonlyArray&lt;<span class="hljs-built_in">number</span>&gt; = a;
ro[<span class="hljs-number">0</span>] = <span class="hljs-number">12</span>; <span class="hljs-comment">// error!</span>
ro.push(<span class="hljs-number">5</span>); <span class="hljs-comment">// error!</span>
ro.length = <span class="hljs-number">100</span>; <span class="hljs-comment">// error!</span>
a = ro; <span class="hljs-comment">// error!</span></code></pre>

<p>上面代码的最后一行，可以看到就算把整个<code>ReadonlyArray</code>赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p>
<pre><code class="hljs typescript">a = ro <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>[];</code></pre>

<h3 id="readonly-vs-const"><a href="#readonly-vs-const" class="headerlink" title="readonly vs const"></a><code>readonly</code> vs <code>const</code></h3><p>最简单判断该用<code>readonly</code>还是<code>const</code>的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用<code>const</code>，若做为属性则使用<code>readonly</code>。</p>
<h2 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h2><p>我们在第一个例子里使用了接口，TypeScript 让我们传入<code>&#123; size: number; label: string; &#125;</code>到仅期望得到<code>&#123; label: string; &#125;</code>的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。</p>
<p>然而，天真地将这两者结合的话就会像在 JavaScript 里那样搬起石头砸自己的脚。比如，拿<code>createSquare</code>例子来说：</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> SquareConfig &#123;
  color?: <span class="hljs-built_in">string</span>;
  width?: <span class="hljs-built_in">number</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSquare</span>(<span class="hljs-params">config: SquareConfig</span>): </span>&#123; color: <span class="hljs-built_in">string</span>; area: <span class="hljs-built_in">number</span> &#125; &#123;
  <span class="hljs-comment">// ...</span>
&#125;

<span class="hljs-keyword">let</span> mySquare = createSquare(&#123; <span class="hljs-attr">colour</span>: <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">100</span> &#125;);</code></pre>

<p>注意传入<code>createSquare</code>的参数拼写为<code>colour</code>而不是<code>color</code>。 在 JavaScript 里，这会默默地失败。</p>
<p>你可能会争辩这个程序已经正确地类型化了，因为<code>width</code>属性是兼容的，不存在<code>color</code>属性，而且额外的<code>colour</code>属性是无意义的。</p>
<p>然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过_额外属性检查_，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p>
<pre><code class="hljs typescript"><span class="hljs-comment">// error: Object literal may only specify known properties, but &#x27;colour&#x27; does not exist in type &#x27;SquareConfig&#x27;. Did you mean to write &#x27;color&#x27;?</span>
<span class="hljs-keyword">let</span> mySquare = createSquare(&#123; <span class="hljs-attr">colour</span>: <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">100</span> &#125;);</code></pre>

<p>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">let</span> mySquare = createSquare(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.5</span> &#125; <span class="hljs-keyword">as</span> SquareConfig);</code></pre>

<p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果<code>SquareConfig</code>带有上面定义的类型的<code>color</code>和<code>width</code>属性，并且_还会_带有任意数量的其它属性，那么我们可以这样定义它：</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> SquareConfig &#123;
  color?: <span class="hljs-built_in">string</span>;
  width?: <span class="hljs-built_in">number</span>;
  [propName: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;
&#125;</code></pre>

<p>我们稍后会讲到索引签名，但在这我们要表示的是<code>SquareConfig</code>可以有任意数量的属性，并且只要它们不是<code>color</code>和<code>width</code>，那么就无所谓它们的类型是什么。</p>
<p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为<code>squareOptions</code>不会经过额外属性检查，所以编译器不会报错。</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">let</span> squareOptions = &#123; <span class="hljs-attr">colour</span>: <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">100</span> &#125;;
<span class="hljs-keyword">let</span> mySquare = createSquare(squareOptions);</code></pre>

<p>上面的方法只在<code>squareOptions</code>和<code>SquareConfig</code>之间有共同的属性时才好用。 在这个例子中，这个属性为<code>width</code>。如果变量间不存在共同的对象属性将会报错。例如：</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">let</span> squareOptions = &#123; <span class="hljs-attr">colour</span>: <span class="hljs-string">&quot;red&quot;</span> &#125;;
<span class="hljs-keyword">let</span> mySquare = createSquare(squareOptions);</code></pre>

<p>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的 bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入<code>color</code>或<code>colour</code>属性到<code>createSquare</code>，你应该修改<code>SquareConfig</code>定义来体现出这一点。</p>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> SearchFunc &#123;
  (source: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;
&#125;</code></pre>

<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">let</span> mySearch: SearchFunc;
mySearch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>) </span>&#123;
  <span class="hljs-keyword">let</span> result = source.search(subString);
  <span class="hljs-keyword">return</span> result &gt; -<span class="hljs-number">1</span>;
&#125;;</code></pre>

<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">let</span> mySearch: SearchFunc;
mySearch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">src: <span class="hljs-built_in">string</span>, sub: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">boolean</span> </span>&#123;
  <span class="hljs-keyword">let</span> result = src.search(sub);
  <span class="hljs-keyword">return</span> result &gt; -<span class="hljs-number">1</span>;
&#125;;</code></pre>

<p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了<code>SearchFunc</code>类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是<code>false</code>和<code>true</code>）。</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">let</span> mySearch: SearchFunc;
mySearch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">src, sub</span>) </span>&#123;
  <span class="hljs-keyword">let</span> result = src.search(sub);
  <span class="hljs-keyword">return</span> result &gt; -<span class="hljs-number">1</span>;
&#125;;</code></pre>

<p>如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与<code>SearchFunc</code>接口中的定义不匹配。</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">let</span> mySearch: SearchFunc;

<span class="hljs-comment">// error: Type &#x27;(src: string, sub: string) =&gt; string&#x27; is not assignable to type &#x27;SearchFunc&#x27;.</span>
<span class="hljs-comment">// Type &#x27;string&#x27; is not assignable to type &#x27;boolean&#x27;.</span>
mySearch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">src, sub</span>) </span>&#123;
  <span class="hljs-keyword">let</span> result = src.search(sub);
  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;string&quot;</span>;
&#125;;</code></pre>

<h2 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h2><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如<code>a[10]</code>或<code>ageMap[&quot;daniel&quot;]</code>。 可索引类型具有一个_索引签名_，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> StringArray &#123;
  [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>;
&#125;

<span class="hljs-keyword">let</span> myArray: StringArray;
myArray = [<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Fred&quot;</span>];

<span class="hljs-keyword">let</span> myStr: <span class="hljs-built_in">string</span> = myArray[<span class="hljs-number">0</span>];</code></pre>

<p>上面例子里，我们定义了<code>StringArray</code>接口，它具有索引签名。 这个索引签名表示了当用<code>number</code>去索引<code>StringArray</code>时会得到<code>string</code>类型的返回值。</p>
<p>Typescript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用<code>number</code>来索引时，JavaScript 会将它转换成<code>string</code>然后再去索引对象。 也就是说用<code>100</code>（一个<code>number</code>）去索引等同于使用<code>&quot;100&quot;</code>（一个<code>string</code>）去索引，因此两者需要保持一致。</p>
<pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;
  <span class="hljs-attr">breed</span>: <span class="hljs-built_in">string</span>;
&#125;

<span class="hljs-comment">// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!</span>
<span class="hljs-keyword">interface</span> NotOkay &#123;
  [x: <span class="hljs-built_in">number</span>]: Animal;
  [x: <span class="hljs-built_in">string</span>]: Dog;
&#125;</code></pre>

<p>字符串索引签名能够很好的描述<code>dictionary</code>模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了<code>obj.property</code>和<code>obj[&quot;property&quot;]</code>两种形式都可以。 下面的例子里，<code>name</code>的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> NumberDictionary &#123;
  [index: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>;
  length: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 可以，length是number类型</span>
  name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 错误，`name`的类型与索引类型返回值的类型不匹配</span>
&#125;</code></pre>

<p>但如果索引签名是包含属性类型的联合类型，那么使用不同类型的属性就是允许的。</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> NumberOrStringDictionary &#123;
   [index: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;
   length: <span class="hljs-built_in">number</span>;    <span class="hljs-comment">// ok, length is a number</span>
   name: <span class="hljs-built_in">string</span>;      <span class="hljs-comment">// ok, name is a string</span>
&#125;</code></pre>

<p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> ReadonlyStringArray &#123;
  <span class="hljs-keyword">readonly</span> [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>;
&#125;
<span class="hljs-keyword">let</span> myArray: ReadonlyStringArray = [<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>];
myArray[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;Mallory&quot;</span>; <span class="hljs-comment">// error!</span></code></pre>

<p>你不能设置<code>myArray[2]</code>，因为索引签名是只读的。</p>
<h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>与 C#或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> ClockInterface &#123;
  <span class="hljs-attr">currentTime</span>: <span class="hljs-built_in">Date</span>;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-title">implements</span> <span class="hljs-title">ClockInterface</span> </span>&#123;
  <span class="hljs-attr">currentTime</span>: <span class="hljs-built_in">Date</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">h: <span class="hljs-built_in">number</span>, m: <span class="hljs-built_in">number</span></span>)</span> &#123;&#125;
&#125;</code></pre>

<p>你也可以在接口中描述一个方法，在类里实现它，如同下面的<code>setTime</code>方法一样：</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> ClockInterface &#123;
  <span class="hljs-attr">currentTime</span>: <span class="hljs-built_in">Date</span>;
  setTime(d: <span class="hljs-built_in">Date</span>): <span class="hljs-built_in">void</span>;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-title">implements</span> <span class="hljs-title">ClockInterface</span> </span>&#123;
  <span class="hljs-attr">currentTime</span>: <span class="hljs-built_in">Date</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
  <span class="hljs-function"><span class="hljs-title">setTime</span>(<span class="hljs-params">d: <span class="hljs-built_in">Date</span></span>)</span> &#123;
    <span class="hljs-built_in">this</span>.currentTime = d;
  &#125;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">h: <span class="hljs-built_in">number</span>, m: <span class="hljs-built_in">number</span></span>)</span> &#123;&#125;
&#125;</code></pre>

<p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p>
<h3 id="类静态部分与实例部分的区别"><a href="#类静态部分与实例部分的区别" class="headerlink" title="类静态部分与实例部分的区别"></a>类静态部分与实例部分的区别</h3><p>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> ClockConstructor &#123;
  <span class="hljs-keyword">new</span> (hour: <span class="hljs-built_in">number</span>, <span class="hljs-attr">minute</span>: <span class="hljs-built_in">number</span>);
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-title">implements</span> <span class="hljs-title">ClockConstructor</span> </span>&#123;
  <span class="hljs-attr">currentTime</span>: <span class="hljs-built_in">Date</span>;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">h: <span class="hljs-built_in">number</span>, m: <span class="hljs-built_in">number</span></span>)</span> &#123;&#125;
&#125;</code></pre>

<p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor 存在于类的静态部分，所以不在检查的范围内。</p>
<p>因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口，<code>ClockConstructor</code>为构造函数所用和<code>ClockInterface</code>为实例方法所用。 为了方便我们定义一个构造函数<code>createClock</code>，它用传入的类型创建实例。</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> ClockConstructor &#123;
  <span class="hljs-keyword">new</span> (hour: <span class="hljs-built_in">number</span>, <span class="hljs-attr">minute</span>: <span class="hljs-built_in">number</span>): ClockInterface;
&#125;
<span class="hljs-keyword">interface</span> ClockInterface &#123;
  tick(): <span class="hljs-built_in">void</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createClock</span>(<span class="hljs-params"></span></span>
<span class="hljs-params"><span class="hljs-function">  ctor: ClockConstructor,</span></span>
<span class="hljs-params"><span class="hljs-function">  hour: <span class="hljs-built_in">number</span>,</span></span>
<span class="hljs-params"><span class="hljs-function">  minute: <span class="hljs-built_in">number</span></span></span>
<span class="hljs-params"><span class="hljs-function"></span>): <span class="hljs-title">ClockInterface</span> </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ctor(hour, minute);
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DigitalClock</span> <span class="hljs-title">implements</span> <span class="hljs-title">ClockInterface</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">h: <span class="hljs-built_in">number</span>, m: <span class="hljs-built_in">number</span></span>)</span> &#123;&#125;
  <span class="hljs-function"><span class="hljs-title">tick</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;beep beep&quot;</span>);
  &#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnalogClock</span> <span class="hljs-title">implements</span> <span class="hljs-title">ClockInterface</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">h: <span class="hljs-built_in">number</span>, m: <span class="hljs-built_in">number</span></span>)</span> &#123;&#125;
  <span class="hljs-function"><span class="hljs-title">tick</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;tick tock&quot;</span>);
  &#125;
&#125;

<span class="hljs-keyword">let</span> digital = createClock(DigitalClock, <span class="hljs-number">12</span>, <span class="hljs-number">17</span>);
<span class="hljs-keyword">let</span> analog = createClock(AnalogClock, <span class="hljs-number">7</span>, <span class="hljs-number">32</span>);</code></pre>

<p>因为<code>createClock</code>的第一个参数是<code>ClockConstructor</code>类型，在<code>createClock(AnalogClock, 7, 32)</code>里，会检查<code>AnalogClock</code>是否符合构造函数签名。</p>
<p>另一种简单方式是使用类表达式：</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> ClockConstructor &#123;
  <span class="hljs-keyword">new</span> (hour: <span class="hljs-built_in">number</span>, <span class="hljs-attr">minute</span>: <span class="hljs-built_in">number</span>);
&#125;

<span class="hljs-keyword">interface</span> ClockInterface &#123;
  tick();
&#125;

<span class="hljs-keyword">const</span> Clock: ClockConstructor = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-title">implements</span> <span class="hljs-title">ClockInterface</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">h: <span class="hljs-built_in">number</span>, m: <span class="hljs-built_in">number</span></span>)</span> &#123;&#125;
  <span class="hljs-function"><span class="hljs-title">tick</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;beep beep&quot;</span>);
  &#125;
&#125;;</code></pre>

<h2 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h2><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Shape &#123;
  <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>;
&#125;

<span class="hljs-keyword">interface</span> Square <span class="hljs-keyword">extends</span> Shape &#123;
  <span class="hljs-attr">sideLength</span>: <span class="hljs-built_in">number</span>;
&#125;

<span class="hljs-keyword">let</span> square = &#123;&#125; <span class="hljs-keyword">as</span> Square;
square.color = <span class="hljs-string">&quot;blue&quot;</span>;
square.sideLength = <span class="hljs-number">10</span>;</code></pre>

<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Shape &#123;
  <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>;
&#125;

<span class="hljs-keyword">interface</span> PenStroke &#123;
  <span class="hljs-attr">penWidth</span>: <span class="hljs-built_in">number</span>;
&#125;

<span class="hljs-keyword">interface</span> Square <span class="hljs-keyword">extends</span> Shape, PenStroke &#123;
  <span class="hljs-attr">sideLength</span>: <span class="hljs-built_in">number</span>;
&#125;

<span class="hljs-keyword">let</span> square = &#123;&#125; <span class="hljs-keyword">as</span> Square;
square.color = <span class="hljs-string">&quot;blue&quot;</span>;
square.sideLength = <span class="hljs-number">10</span>;
square.penWidth = <span class="hljs-number">5.0</span>;</code></pre>

<h2 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h2><p>先前我们提过，接口能够描述 JavaScript 里丰富的类型。 因为 JavaScript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</p>
<p>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Counter &#123;
  (start: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>;
  interval: <span class="hljs-built_in">number</span>;
  reset(): <span class="hljs-built_in">void</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCounter</span>(<span class="hljs-params"></span>): <span class="hljs-title">Counter</span> </span>&#123;
  <span class="hljs-keyword">let</span> counter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">start: <span class="hljs-built_in">number</span></span>) </span>&#123;&#125; <span class="hljs-keyword">as</span> Counter;
  counter.interval = <span class="hljs-number">123</span>;
  counter.reset = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;
  <span class="hljs-keyword">return</span> counter;
&#125;

<span class="hljs-keyword">let</span> c = getCounter();
c(<span class="hljs-number">10</span>);
c.reset();
c.interval = <span class="hljs-number">5.0</span>;</code></pre>

<p>在使用 JavaScript 第三方库的时候，你可能需要像上面那样去完整地定义类型。</p>
<h2 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h2><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 private 和 protected 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p>
<p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 除了继承自基类，子类之间不必相关联。 例：</p>
<pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Control</span> </span>&#123;
  <span class="hljs-keyword">private</span> state: <span class="hljs-built_in">any</span>;
&#125;

<span class="hljs-keyword">interface</span> SelectableControl <span class="hljs-keyword">extends</span> Control &#123;
  select(): <span class="hljs-built_in">void</span>;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Control</span> <span class="hljs-title">implements</span> <span class="hljs-title">SelectableControl</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">select</span>(<span class="hljs-params"></span>)</span> &#123;&#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Control</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">select</span>(<span class="hljs-params"></span>)</span> &#123;&#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageControl</span> <span class="hljs-title">implements</span> <span class="hljs-title">SelectableControl</span> </span>&#123;
<span class="hljs-comment">// Error: Class &#x27;ImageControl&#x27; incorrectly implements interface &#x27;SelectableControl&#x27;.</span>
<span class="hljs-comment">//  Types have separate declarations of a private property &#x27;state&#x27;.</span>
  <span class="hljs-keyword">private</span> state: <span class="hljs-built_in">any</span>;
  <span class="hljs-function"><span class="hljs-title">select</span>(<span class="hljs-params"></span>)</span> &#123;&#125;
&#125;</code></pre>

<p>在上面的例子里，<code>SelectableControl</code>包含了<code>Control</code>的所有成员，包括私有成员<code>state</code>。 因为<code>state</code>是私有成员，所以只能够是<code>Control</code>的子类们才能实现<code>SelectableControl</code>接口。 因为只有<code>Control</code>的子类才能够拥有一个声明于<code>Control</code>的私有成员<code>state</code>，这对私有成员的兼容性是必需的。</p>
<p>在<code>Control</code>类内部，是允许通过<code>SelectableControl</code>的实例来访问私有成员<code>state</code>的。 实际上，<code>SelectableControl</code>就像<code>Control</code>一样，并拥有一个<code>select</code>方法。 <code>Button</code>和<code>TextBox</code>类是<code>SelectableControl</code>的子类（因为它们都继承自<code>Control</code>并有<code>select</code>方法）。而对于 <code>ImageControl</code> 类，它有自身的私有成员 <code>state</code> 而不是通过继承 <code>Control</code> 得来的，所以它不可以实现 <code>SelectableControl</code> 。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/cactus/">首页</a></li>
         
          <li><a href="/cactus/tags/">标签</a></li>
         
          <li><a href="/cactus/archives/">归档</a></li>
         
          <li><a href="/cactus/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%88%9D%E6%8E%A2"><span class="toc-number">2.</span> <span class="toc-text">接口初探</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">可选属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">4.</span> <span class="toc-text">只读属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#readonly-vs-const"><span class="toc-number">4.1.</span> <span class="toc-text">readonly vs const</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84%E5%B1%9E%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="toc-number">5.</span> <span class="toc-text">额外的属性检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">函数类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.</span> <span class="toc-text">可索引的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">类类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.1.</span> <span class="toc-text">实现接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E9%9D%99%E6%80%81%E9%83%A8%E5%88%86%E4%B8%8E%E5%AE%9E%E4%BE%8B%E9%83%A8%E5%88%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.2.</span> <span class="toc-text">类静态部分与实例部分的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.</span> <span class="toc-text">继承接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.</span> <span class="toc-text">混合类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E7%B1%BB"><span class="toc-number">11.</span> <span class="toc-text">接口继承类</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/&text= 接口"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/&title= 接口"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/&is_video=false&description= 接口"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject= 接口&body=Check out this article: https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/&title= 接口"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/&title= 接口"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/&title= 接口"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/&title= 接口"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/&name= 接口&description=&lt;h2 id=&#34;介绍&#34;&gt;&lt;a href=&#34;#介绍&#34; class=&#34;headerlink&#34; title=&#34;介绍&#34;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;TypeScript 的核心原则之一是对值所具有的_结构_进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://tangxiaomi.top/2021/06/03/typescript/c4ab7b1814/&t= 接口"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <!-- <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a> -->
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021
    糖小米
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/cactus/">首页</a></li>
         
          <li><a href="/cactus/tags/">标签</a></li>
         
          <li><a href="/cactus/archives/">归档</a></li>
         
          <li><a href="/cactus/search/">搜索</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/cactus/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/cactus/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/cactus/lib/jquery/jquery.min.js"></script>


<script src="/cactus/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/cactus/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/cactus/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>

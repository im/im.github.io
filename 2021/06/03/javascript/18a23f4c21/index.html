<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title> 实时协同编辑的实现 - 糖小米 · 笔记</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="糖小米 · 笔记"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/im/oss@master/logo/logo.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="糖小米 · 笔记"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="在最近某个项目中打算使用协同编辑来解决冲突问题，因此抽空调研了现有的实现方案，结果发现要想做完美是很难的，但我们可以低成本地做到不错的效果，本文将介绍几种实现方法，大家在项目中如果有需要可以参考。 什么是实时协同编辑这里所说的实时协同编辑，是指多人同时编辑一个文档，最典型的例子是 Google Docs，你可以实时看到别人做出的修改，不用手动刷新页面。 要实现实时编辑，我们需要解决两个技术点：实时"><meta property="og:type" content="blog"><meta property="og:title" content=" 实时协同编辑的实现"><meta property="og:url" content="https://tangxiaomi.top/2021/06/03/javascript/18a23f4c21/"><meta property="og:site_name" content="糖小米 · 笔记"><meta property="og:description" content="在最近某个项目中打算使用协同编辑来解决冲突问题，因此抽空调研了现有的实现方案，结果发现要想做完美是很难的，但我们可以低成本地做到不错的效果，本文将介绍几种实现方法，大家在项目中如果有需要可以参考。 什么是实时协同编辑这里所说的实时协同编辑，是指多人同时编辑一个文档，最典型的例子是 Google Docs，你可以实时看到别人做出的修改，不用手动刷新页面。 要实现实时编辑，我们需要解决两个技术点：实时"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tangxiaomi.top/images/merge.png"><meta property="og:image" content="https://tangxiaomi.top/images/order-problem.png"><meta property="og:image" content="https://tangxiaomi.top/images/data-atomic.png"><meta property="og:image" content="https://tangxiaomi.top/images/version-problem.png"><meta property="og:image" content="https://tangxiaomi.top/images/version-solution.png"><meta property="article:published_time" content="2021-06-03T00:00:00.000Z"><meta property="article:modified_time" content="2021-06-04T02:20:37.390Z"><meta property="article:author" content="糖小米"><meta property="article:tag" content="javascript"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/images/merge.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tangxiaomi.top/2021/06/03/javascript/18a23f4c21/"},"headline":"糖小米 · 笔记","image":["https://tangxiaomi.top/images/merge.png","https://tangxiaomi.top/images/order-problem.png","https://tangxiaomi.top/images/data-atomic.png","https://tangxiaomi.top/images/version-problem.png","https://tangxiaomi.top/images/version-solution.png"],"datePublished":"2021-06-03T00:00:00.000Z","dateModified":"2021-06-04T02:20:37.390Z","author":{"@type":"Person","name":"糖小米"},"description":"在最近某个项目中打算使用协同编辑来解决冲突问题，因此抽空调研了现有的实现方案，结果发现要想做完美是很难的，但我们可以低成本地做到不错的效果，本文将介绍几种实现方法，大家在项目中如果有需要可以参考。 什么是实时协同编辑这里所说的实时协同编辑，是指多人同时编辑一个文档，最典型的例子是 Google Docs，你可以实时看到别人做出的修改，不用手动刷新页面。 要实现实时编辑，我们需要解决两个技术点：实时"}</script><link rel="canonical" href="https://tangxiaomi.top/2021/06/03/javascript/18a23f4c21/"><link rel="alternate" href="/./atom.xml" title="糖小米 · 笔记" type="application/atom+xml"><link rel="icon" href="https://cdn.jsdelivr.net/gh/im/oss@master/logo/logo.png"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/im/hexo-theme@icarus/source/fontawesome/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.0.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">糖小米 · 笔记</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/links">Links</a><a class="navbar-item" href="/cactus">Theme</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Github" href="https://github.com/im"><i class="fab fa-github"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="RSS" href="/./atom.xml"><i class="fas fa-rss"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-03T00:00:00.000Z" title="2021-06-03T00:00:00.000Z">2021-06-03</time>发表</span><span class="level-item"><time dateTime="2021-06-04T02:20:37.390Z" title="2021-06-04T02:20:37.390Z">2021-06-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">33 分钟读完 (大约4934个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"> 实时协同编辑的实现</h1><div class="content"><p>在最近某个项目中打算使用协同编辑来解决冲突问题，因此抽空调研了现有的实现方案，结果发现要想做完美是很难的，但我们可以低成本地做到不错的效果，本文将介绍几种实现方法，大家在项目中如果有需要可以参考。</p>
<h2 id="什么是实时协同编辑"><a href="#什么是实时协同编辑" class="headerlink" title="什么是实时协同编辑"></a>什么是实时协同编辑</h2><p>这里所说的实时协同编辑，是指多人同时编辑一个文档，最典型的例子是 Google Docs，你可以实时看到别人做出的修改，不用手动刷新页面。</p>
<p>要实现实时编辑，我们需要解决两个技术点：实时通信问题、编辑冲突问题，其中实时通信问题比较好解决，可以使用 long pull 或 WebSocket，所以这里就不过多讨论了，重点将放在如何解决编辑冲突问题上。</p>
<h2 id="可选方案"><a href="#可选方案" class="headerlink" title="可选方案"></a>可选方案</h2><p>接下来将从易至难的顺序来介绍几种可行的方案，分别是：「编辑锁」、「GNU diff-patch」、「Myer’s diff-patch」、「Operational Transformation」和「分布式 Operational Transformation」。</p>
<a id="more"></a>
<h3 id="编辑锁"><a href="#编辑锁" class="headerlink" title="编辑锁"></a>编辑锁</h3><p>编辑锁这是实现协同编辑最简单的方法，简单来说就是当有人在编辑某个文档时，系统会将这个文档锁定，避免其他人同时编辑，因为实现简单，所以这个方案是应用最广的，比如公司内部常用的 TWiki 系统，采用这种方式虽然可以在一定程度上避免覆盖问题，但它的使用体验不好，也做不到「实时」，所以这里就不讨论了。</p>
<h3 id="GNU-diff-patch"><a href="#GNU-diff-patch" class="headerlink" title="GNU diff-patch"></a>GNU diff-patch</h3><p>Git 等版本管理软件其实也是一种协同编辑工具，因为每个人都可以并行编辑，遇到编辑同一个文件时可以自动合并，因此我们也能使用类似的原理来实现协同编辑，具体可以有两种方法：diff-patch 和 merge。</p>
<p>先说 diff-patch，这里的 diff 和 patch 是指两个 unix 下的命令，diff 能输出两个文本的不同之处，然后用 patch 来更新其它文件，我们只要在 JS 中实现这两个算法，就能通过如下流程来实现协同编辑：</p>
<ol>
<li>每个用户进来时都建立长连接，保存好当前文档副本</li>
<li>有人编辑时，如果停顿 5 秒（具体要根据产品策略），就将现有文档和之前的副本进行 diff，将结果传给服务端，更新副本</li>
<li>服务端更新文档，然后通过长连接将这个 diff 结果发给同时在编辑的其它用户，这些用户使用 patch 方法来更新 ta 们文档</li>
</ol>
<p>但 GNU diff 有个问题，因为基于行匹配的，所以很容易冲突，让我们测试一下「百度 Web」和「百度 Web 前端」这两段文本的 diff 结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[nwind@fex ~]$ diff old.txt other-new.txt &gt; old-to-other-new.patch</span><br><span class="line">[nwind@fex ~]$ cat old-to-other-new.patch</span><br><span class="line">1c1</span><br><span class="line">&lt; 百度 Web</span><br><span class="line">---</span><br><span class="line">&gt; 百度 Web 前端</span><br></pre></td></tr></table></figure>

<p>在这个 diff 结果中， <code>1c1</code> 的第一个「1」代表修改前的第一行，后面的「c」代表「修改」，第二个「1」代表修改后的行，也就是说将第一行的「百度 Web」改成「百度 Web 前端」，修改后的内容放第一行。也就意味着如果两人同时修改一行就会冲突，可以通过下面的测试来确认：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[nwind@fex ~]$ cat my-new.txt</span><br><span class="line">Web [nwind@fex ~]$ patch my-new.txt &lt; old-to-other-new.patch</span><br><span class="line">patching file b-new.txt</span><br><span class="line">Hunk #1 FAILED at 1.</span><br><span class="line">1 out of 1 hunk FAILED -- saving rejects to file my-new.txt.rej [nwind@fex ~]$ cat my-new.txt.rej</span><br><span class="line">***************</span><br><span class="line">*** 1</span><br><span class="line">- 百度 Web--- 1 -----</span><br><span class="line">+ 百度 Web 前端</span><br></pre></td></tr></table></figure>

<p>其中 <code>my-new.txt</code> 是我修改的版本，我去掉了前面的「百度 」，只留下「Web」，其实这两处修改是不冲突的，它们可以合并成「Web 前端」，如下图所示</p>
<p><img src="/images/merge.png"><br>但使用 patch 命令部下，它在冲突后会生成一个新文件 <code>my-new.txt.rej</code> 来描述失败原因，这种展现方式不直观，需要打开两个文件比对，我们使用另一种方式来更好地展现，那就是接下来介绍的 merge 命令，它的使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nwind@fex ~]$ merge my-new.txt old.txt other-new.txt</span><br><span class="line">merge: warning: conflicts during merge [nwind@fex ~]$ cat my-new.txt</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; my-new.txt</span><br><span class="line">Web=======</span><br><span class="line">百度 Web 前端&gt;&gt;&gt;&gt;&gt;&gt;&gt; other-new.txt</span><br></pre></td></tr></table></figure>

<p>可以看到它直接将冲突的地方写到 <code>my-new.txt</code> 里了，这点比 patch 看起来要方便些，对于这个结果估计大部分同学都会眼熟，因为 merge 命令和 Git 等工具 <a target="_blank" rel="noopener" href="https://github.com/git/git/blob/master/Documentation/git-merge.txt#L211">中的合并算法是一样的</a> 。</p>
<p>通过使用我们可以发现 merge 命令有个缺点，那就是需要使用 3 份完整的文本来进行比较，为了避免每次传递所有文本内容，我们可以结合使用 diff 来减小传输体积，在后端 patch 成新的文本。</p>
<p>无论是 diff 还是 merge，由于它们的算法都是基于行进行比较，导致对同一行的编辑必然冲突，为了解决这个问题，我们可以尝试基于字符粒度的 diff 算法，那就是接下来将介绍的 Myer’s diff-patch。</p>
<h3 id="Myer’s-diff-patch"><a href="#Myer’s-diff-patch" class="headerlink" title="Myer’s diff-patch"></a>Myer’s diff-patch</h3><p><a target="_blank" rel="noopener" href="http://neil.fraser.name/software/diff_match_patch/myers.pdf">Myer 算法</a> 是另一种 diff-patch 算法，它有很多 <a target="_blank" rel="noopener" href="https://code.google.com/p/google-diff-match-patch/">语言的开源实现</a> ，这里我们就不介绍细节算法了，直接用之前的例子来测试它的效果，首先看一下它的 diff 结果，调用代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var old_text = &quot;百度 Web&quot;;</span><br><span class="line">var new_text = &quot;百度 Web 前端&quot;; var dmp = new diff_match_patch();</span><br><span class="line">var patch_list = dmp.patch_make(old_text, new_text);</span><br><span class="line">patch_text = dmp.patch_toText(patch_list); console.log(decodeURI(patch_text))</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@@ -1,6 +1,9 @@</span><br><span class="line"> 百度 Web</span><br><span class="line">+ 前端</span><br></pre></td></tr></table></figure>

<p>其中第一行的 <code>-</code> 和 <code>+</code> 两个符号没有什么意义，这句话表示修改处之前的起始位置为 1（由于数组是从 0 开始的，所以内部计算时会先减一），长度为 6，后面的 <code>1,9</code> ，表示修改后的起始位置为 1，长度为 9。在接下来的两段文本代表修改的地方，注意「百度 Web」前面有空格，这代表相等，也就是直接添加这个字符串，而后面的 <code>+</code> 代表添加文本，具体细节可以通过它的 <a target="_blank" rel="noopener" href="https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js#2100">实现源码</a> 了解。</p>
<p>因此确定它的 diff 策略是基于字符匹配的，这样能否解决我们之前遇到的冲突问题呢？接下来来测试一下，源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//相关代码同上</span><br><span class="line">var patches = dmp.patch_fromText(patch_text);</span><br><span class="line">var results = dmp.patch_apply(patches, &quot;Web&quot;); console.log(results[0]); //Web 前端</span><br></pre></td></tr></table></figure>

<p>这个输出结果是正确的，也就是说它能很好地解决之前的问题，但如果是同一个位置的修改会怎样？我继续做了几个实验：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var old_text = &quot;百度 Web&quot;;</span><br><span class="line">var other_new_text = &quot;百度 Web 后端&quot;;</span><br><span class="line">var my_new_text = &quot;百度 Web 前端&quot;;</span><br><span class="line">...</span><br><span class="line">//结果为「百度 Web 前端 后端」 ===</span><br><span class="line">var old_text = &quot;百度 Web 前端&quot;;</span><br><span class="line">var other_new_text = &quot;百度 Web 后端&quot;;</span><br><span class="line">var my_new_text = &quot;百度 Web 全端&quot;;</span><br><span class="line">...</span><br><span class="line">//结果为「百度 Web 后端」 ===</span><br><span class="line">var old_text = &quot;百度 Web&quot;;</span><br><span class="line">var other_new_text = &quot;Web 前端&quot;;</span><br><span class="line">var my_new_text = &quot;百度 FE&quot;;</span><br><span class="line">//结果为「FE 前」</span><br></pre></td></tr></table></figure>

<p>第一个例子是在后面添加不同的字符，它的结果是两个添加都生效，第二个例子是在同一处修改成不同的字符，它的结果是别人的修改生效，但最后一个例子出错了，丢失了「端」字，这里看起来还好，但如果内容是富文本就有问题了，比如 <code>&lt;b&gt;</code> 少了 <code>&gt;</code> 是不行的。</p>
<p>整体来看 Myer 算法可以低成本地解决大部分问题，所以有些在线编辑器选择它来实现协同编辑功能，比如 <a target="_blank" rel="noopener" href="http://codebox.io/">codebox</a> ，它的客户端代码 <a target="_blank" rel="noopener" href="https://github.com/FriendCode/codebox/blob/master/client/utils/filesync.js">在这</a> ，服务端代码 <a target="_blank" rel="noopener" href="https://github.com/FriendCode/codebox/blob/master/core/cb.files.sync/models/document.js">在这</a> 。</p>
<p>不过 Myer 在某些情况下会丢字符，是否还有更好的方法？答案是有，那就是接下来介绍的 Operational Transformation 技术。</p>
<h3 id="Operational-Transformation"><a href="#Operational-Transformation" class="headerlink" title="Operational Transformation"></a>Operational Transformation</h3><p>Operational Transformation（下面简称 OT）技术正是 Google Docs 中所采用的方案，因此是经过验证的，值得研究。</p>
<p>最开始我一直觉得 OT 会很复杂，因为它的相关介绍文章都写得很长，比如 <a target="_blank" rel="noopener" href="http://www3.ntu.edu.sg/home/czsun/projects/otfaq/">这篇</a> 及维基百科上的 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Operational_transformation">介绍</a> ，不过看了之后才后发现它的原理并不复杂，我将在这里进行简单的说明。</p>
<p>首先，我们可以将文本内容修改转成以下 3 种类型的操作(Operational)：</p>
<ul>
<li>retain(n)：保持 n 个字符，也就是说这 n 个字符不变</li>
<li>insert(str)：插入字符 str</li>
<li>delete(str)：删除字符 str</li>
</ul>
<p>举个例子，假设 A 用户将「百度 Web」变成「Web 前端」，相当于产生了如下 3 个操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete(&#x27;百度 &#x27;),  //删掉「百度 」</span><br><span class="line">retain(3),       //跳过 3 个字符（也就是「Web」）</span><br><span class="line">insert(&#x27; 前端&#x27;)   //插入「 前端」</span><br></pre></td></tr></table></figure>

<p>提取这些操作可以通过 Levenshtein distance（编辑距离）算法来实现。那它如何解决冲突问题了？比如这时如果 B 用户将「百度 Web」改成了「百度 FE」，B 所生产的操作步骤将会是如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">retain(3),       //跳过 3 个字符（也就是「百度 」）</span><br><span class="line">delete(&#x27;Web&#x27;),</span><br><span class="line">insert(&#x27;FE&#x27;)</span><br></pre></td></tr></table></figure>

<p>如果我们先应用 A 的操作，将字符串变为「Web 前端」，然后再应用 B 的操作时就会失效，因为在执行 B 的第二个操作 <code>delete(&#39;Web&#39;)</code> 时并没有「Web」，这时从第四个字符开始已经变成了「 前端」。</p>
<p>因此我们需要转换 B 的操作来适应新的字符串，比如调成如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete(&#x27;Web&#x27;),</span><br><span class="line">insert(&#x27;FE&#x27;),</span><br><span class="line">retain(3)</span><br></pre></td></tr></table></figure>

<p>这个转换算法就是 OT 的核心，实际上 OT 指的是一类技术，而不是具体的算法，这个思路就是首先将编辑转成操作(Operational)，如果多人操作同时进行，需要对这些操作进行转换(Transformation)，这就是为什么叫 Operational Transformation，而具体应该拆分成哪些操作以及转换算法都是可以自定义的，因此 OT 可以灵活地支持各种协同编辑应用，比如非文本类的编辑。</p>
<p>回到之前 Myer 算法导致丢字符的那个例子，我们看看 OT 是否能解决，这里我使用了一个开源库 <a target="_blank" rel="noopener" href="https://github.com/marcelklehr/changesets">changesets</a> ，以下是基于它实现合并的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Changeset = require(&#x27;changesets&#x27;).Changeset; var text = &quot;百度 Web&quot; , textA = &quot;Web 前端&quot; , textB = &quot;百度 FE&quot;; var csA = Changeset.fromDiff(text, textA);</span><br><span class="line">var csB = Changeset.fromDiff(text, textB); var csB_new = csB.transformAgainst(csA); //这里这就是操作转换 var textA_new = csA.apply(text);</span><br><span class="line">console.log(csB_new.apply(textA_new)); //结果是「 前端FE」</span><br></pre></td></tr></table></figure>

<p>结果并不正确，正确的应该是「FE 前端」，查看一下 <code>csB_new</code> 的内容，发现它实际上是转换成了如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete(3),   //注意 changesets 在这里的参数不是字符串而是数字，它会直接删掉 3 个字符，不够内容是什么</span><br><span class="line">retain(3),</span><br><span class="line">insert(&#x27;FE&#x27;)</span><br></pre></td></tr></table></figure>

<p>需要注意这并不是 OT 技术本身的问题，而是 changesets 所实现的转换算法问题，虽然不够完美，但和之前的 Myer 算法相比，至少没丢字符，后来我又做了几个测试，发现 OT 技术的准确率比 Myer 高，因此它是最适合用于协同编辑的技术。</p>
<h3 id="分布式-Operational-Transformation"><a href="#分布式-Operational-Transformation" class="headerlink" title="分布式 Operational Transformation"></a>分布式 Operational Transformation</h3><p>如果看完上面的文章你觉得实现实时协同编辑似乎不难，那你就错了，因为我们之前都没有考虑分布式的问题，OT 技术在学术界都研究 20 多年了，至今也没人总结出一个最好的方法，前 Google Wave 工程师在 <a target="_blank" rel="noopener" href="http://sharejs.org/">ShareJS</a> 首页上这样写道：</p>
<blockquote>
<p>Unfortunately, implementing OT sucks. There’s a million algorithms with different tradeoffs, mostly trapped in academic papers. The algorithms are really hard and time consuming to implement correctly. I am an ex Google Wave engineer. Wave took 2 years to write and if we rewrote it today, it would take almost as long to write a second time.  </p>
</blockquote>
<p>所以其实要做好是很难的，这里面最麻烦的就是分布式导致的问题，接下来将介绍 3 个我能想到的问题及解决方法。</p>
<p><strong>1. 顺序问题</strong></p>
<p>首先第一个问题是顺序问题，因为 OT 等算法都是依赖顺序的，不同顺序会导致结果不同，我们通过下面这张图来说明：</p>
<p><img src="/images/order-problem.png"><br>假设 <code>Client A</code> 在做两次修改时发了两个异步请求，可能因为网络延迟导致第二个请求反而先到了，导致最终服务器版本和 <code>Client A</code> 所看到的不一致，同样在服务器发往其它客户端的请求时也会出现乱序的问题，如图中 <code>Client B</code> 也有问题。</p>
<p>这个问题的解决方法很简单，我们可以在客户端和服务器端都加上队列来保证请求顺序，等前一个请求结束后再发下一个请求。</p>
<p><strong>2. 存储的原子操作</strong></p>
<p>如果有多台服务器，或者有多个线程/进程在同时处理请求时就会遇到覆盖问题，因为读写数据库并不是原子操作，比如下面的例子：</p>
<p><img src="/images/data-atomic.png"><br><code>Web Server A</code> 和 <code>Web Server B</code> 同时访问数据库，结果导致 <code>Web Server A</code> 的修改被覆盖了。</p>
<p>好在这种问题还算比较常见，解决办法可以有 3 种：</p>
<ul>
<li>保证操作只在一个线程中执行，比如某个文档的更新只在某个固定的机器，使用 Node 这样的单线程模型提供服务，这样就不可能并行修改了</li>
<li>如果数据库支持事务(transaction)，可以通过事务来解决</li>
<li>如果数据库不支持事务，就只能用分布式锁了，如 ZooKeeper</li>
</ul>
<p>从实现角度来看，第一和第二种方法都比较简单，而第三种方法会带来很多问题，比如可能导致文档被锁死，假如上锁后由于种种原因没有执行解锁操作，这个文档就会永远被锁住，所以还得加上超时限制等策略。</p>
<p>然而在解决了原子操作后，我们将发现一个新的问题，那就是版本管理问题。</p>
<p><strong>3. 版本管理问题</strong></p>
<p>在前面的例子中，两段新文本的修改都是基于同一个旧版本的，如果旧版本不一样，就有可能出错，具体可以通过下面这张图来解释：</p>
<p><img src="/images/version-problem.png"><br>在这个例子中，Web Server A 接收到操作命令是将「a」文本改成「aa」，Web Server B 接收到操作命令是将「a」文本改成「ab」，这里我们加上了锁机制来避免同时读写数据，Web Server A 首先得到了锁，然后修改并更新数据，而 Web Server B 需要先等待数据解锁，等 Web Server B 拿到数据后它已经从「a」变成了「aa」，如果还按照 <code>retain(1), insert(&#39;b&#39;)</code> 进行修改，数据将变成「ab」，而不是正确的「aab」，引起这个问题的原因就是旧版本不一致，Web Server B 需要根据 Web Server A 的操作进行操作转换，变成 <code>retain(2), insert(&#39;b&#39;)</code> ，然后才能对数据进行修改。</p>
<p>因此想要解决这个问题，就必须引入版本，每次修改后都需要存储下新版本，有了版本我们就能使用 diff 功能来计算不同版本的差异，得到其它人修改的内容，然后通过 OT 合并算法合并两个操作，如下所示：</p>
<p><img src="/images/version-solution.png"><br>在 <code>Web Server A</code> 操作前数据版本是 <code>v=1</code> ，操作后变成了 <code>v=2</code> ，等到 <code>Web Server B</code> 处理的时候，它通过版本比较发现不一致，所以就首先通过编辑距离算法算出 <code>Web Server A</code> 所做的操作，然后用这个操作来对自己的操作进行转换，得到正确的新操作，从而避免了覆盖问题。</p>
<p>如果保存所有版本会导致数据量大大增加，所以还需要再优化，比如每个服务器保存一个数据副本，但这里就不再展开了，可以看要支持分布式 还是挺麻烦的，不过目前出现了一些前后端整合的方案，如 <a target="_blank" rel="noopener" href="http://sharejs.org/">ShareJS</a> 和 <a target="_blank" rel="noopener" href="https://github.com/opencoweb/coweb">OpenCoweb Framework</a> ，可以参考。</p>
<p>另外之前提到的 Myer’s diff 算法也有分布式解决方案，具体细节可以参考 <a target="_blank" rel="noopener" href="https://neil.fraser.name/writing/sync/">这篇文档</a> 。</p>
<h2 id="初步结论"><a href="#初步结论" class="headerlink" title="初步结论"></a>初步结论</h2><ul>
<li><p>如果你只是一个内部小项目，实时性要求不高，但对准确性要求比较高</p>
<ul>
<li>推荐用 merge 或 diff3 工具，出现同一行冲突时由用户来解决，这样能避免自动合并有可能出错的问题</li>
</ul>
</li>
<li><p>如果想具备一定的实时性，流量不大，不想实现太复杂，且对少量的冲突可以忍受</p>
<ul>
<li>推荐用 Myer’s diff，后端只开一个 Node 进程</li>
</ul>
</li>
<li><p>如果想具备实时性，且有多台后端服务同时处理</p>
<ul>
<li>可以用 Operational Transformation 或 Myer’s diff，但需要注意分布式带来的问题</li>
</ul>
</li>
<li><p>如果需要很精细的控制，如支持富文本编辑等非单纯文本格式</p>
<ul>
<li>只能使用 Operational Transformation，但要自己实现操作合并算法，比如 XML 可以参考 <a target="_blank" rel="noopener" href="http://www.codecommit.com/blog/java/understanding-and-applying-operational-transformation">这篇文章</a></li>
</ul>
</li>
</ul>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>除了文本合并，真正要做在线编辑还有很多细节处理，感兴趣的同学可以继续研究：</p>
<ul>
<li>支持选区，看到其他人选择的文本段，当然，这也有合并问题</li>
<li>指针要更随文本变化移动到正确的位置</li>
<li>支持 undo</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://fex.baidu.com/blog/2014/04/realtime-collaboration/">实时协同编辑的实现</a></p>
<p>#javascript </p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/javascript/">javascript</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/06/03/git/91c8e247e4/"><i class="level-item fas fa-chevron-left"></i><span class="level-item"> SVN与Git比较的优缺点差异</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/06/03/javascript/419340c52c/"><span class="level-item"> 你不知道的浏览器渲染原理</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "b9b25ed8421f1d398517831586079a7b",
            repo: "im.github.io",
            owner: "im",
            clientID: "b5b53b3c7256700567b5",
            clientSecret: "c6d4a0611585e5584f30108dd75c50b9c28fcc6f",
            admin: "im",
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#什么是实时协同编辑"><span class="level-left"><span class="level-item">1</span><span class="level-item">什么是实时协同编辑</span></span></a></li><li><a class="level is-mobile" href="#可选方案"><span class="level-left"><span class="level-item">2</span><span class="level-item">可选方案</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#编辑锁"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">编辑锁</span></span></a></li><li><a class="level is-mobile" href="#GNU-diff-patch"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">GNU diff-patch</span></span></a></li><li><a class="level is-mobile" href="#Myer’s-diff-patch"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Myer’s diff-patch</span></span></a></li><li><a class="level is-mobile" href="#Operational-Transformation"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">Operational Transformation</span></span></a></li><li><a class="level is-mobile" href="#分布式-Operational-Transformation"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">分布式 Operational Transformation</span></span></a></li></ul></li><li><a class="level is-mobile" href="#初步结论"><span class="level-left"><span class="level-item">3</span><span class="level-item">初步结论</span></span></a></li><li><a class="level is-mobile" href="#后续"><span class="level-left"><span class="level-item">4</span><span class="level-item">后续</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-03T05:36:57.000Z">2021-06-03</time></p><p class="title"><a href="/2021/06/03/javascript/fa59b4bb32/"> 数组扁平化</a></p><p class="categories"><a href="/categories/javascript/">javascript</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-03T02:02:28.000Z">2021-06-03</time></p><p class="title"><a href="/2021/06/03/javascript/cbbeb436fb/"> JavaScript里的循环方法：forEach，for-in，for-of</a></p><p class="categories"><a href="/categories/javascript/">javascript</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-03T01:49:36.000Z">2021-06-03</time></p><p class="title"><a href="/2021/06/03/interview/ac86bf5243/"> 为什么要用setTimeout来模拟setInterval</a></p><p class="categories"><a href="/categories/Interview/">Interview</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-03T01:49:36.000Z">2021-06-03</time></p><p class="title"><a href="/2021/06/03/javascript/ef320f6e2a/"> JS事件循环（Event Loop）</a></p><p class="categories"><a href="/categories/javascript/">javascript</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-03T00:00:00.000Z">2021-06-03</time></p><p class="title"><a href="/2021/06/03/Windows/0748fd3045/"> Windows下如何查看某个端口被谁占用</a></p><p class="categories"><a href="/categories/Windows/">Windows</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">糖小米 · 笔记</a><p class="is-size-7"><span>&copy; 2021 糖小米</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/im/im.github.io"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>
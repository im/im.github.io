<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Notes</title>
    <link>https://tangxiaomi.top/posts/</link>
    <description>Recent content in Posts on Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language>
    <lastBuildDate>Thu, 01 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://tangxiaomi.top/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Unsplash 图片链接</title>
      <link>https://tangxiaomi.top/posts/other/unsplash/</link>
      <pubDate>Thu, 01 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://tangxiaomi.top/posts/other/unsplash/</guid>
      <description>随机图片链接 如果你需要一张随机的图片来让内容更加生动、有趣，只需要在 Unsplash 的基础图片链接后面加上“/random/”即可。例如以下链接将返回一个宽度为 640 像素、高度为 480 像素的随机图片：
https://source.unsplash.com/random/640x480 如果需要过滤主题，只需在链接末尾加上标签即可，例如以下链接将会返回一个范围包括 mountain 和 landscape 的随机图片：
https://source.unsplash.com/random/640x480?landscape,mountain 固定图片链接 如果你需要一张特定的图片，只需使用 Unsplash 图片的 ID，拼接图片链接即可。例如以下链接将会返回 ID 为 &amp;ldquo;hgytITrCiec&amp;rdquo; 的 Unsplash 图片，并且将图片宽度设置为 640 像素，高度设置为 480 像素：
https://source.unsplash.com/hgytITrCiec/640x480 在 Markdown 中使用 Unsplash 图片链接 在 Markdown 编辑器中，你可以使用以下语法插入 Unsplash 图片链接：
![图片描述](图片链接) 例如，在你的文章中插入一张宽度为 640 像素、高度为 480 像素的随机图片，可以使用以下代码：
![随机图片](https://source.unsplash.com/random/640x480) 如果你想要插入一张特定的图片，可以使用 ID 和固定图片链接：
![特定图片](https://source.unsplash.com/hgytITrCiec/640x480) 以上就是如何使用 Unsplash 图片链接的简单介绍。希望这篇文章对你有帮助！</description>
    </item>
    
    <item>
      <title>husky</title>
      <link>https://tangxiaomi.top/posts/git/husky/</link>
      <pubDate>Tue, 30 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://tangxiaomi.top/posts/git/husky/</guid>
      <description>安装 Husky  使用 npm 进行安装：
npm install husky --save-dev 配置 Git 钩子  在 package.json 文件中添加 &amp;ldquo;husky&amp;rdquo; 配置：
&amp;#34;husky&amp;#34;: { &amp;#34;hooks&amp;#34;: { &amp;#34;pre-commit&amp;#34;: &amp;#34;npm run lint&amp;#34;, // 在执行 git commit 命令时，会执行 npm run lint 命令 &amp;#34;pre-push&amp;#34;: &amp;#34;npm run test&amp;#34; // 在执行 git push 命令时，会执行 npm run test 命令 } } 配置 pre-commit 钩子  在 package.json 文件中添加 &amp;ldquo;scripts&amp;rdquo; 属性：
&amp;#34;scripts&amp;#34;: { &amp;#34;lint&amp;#34;: &amp;#34;eslint .&amp;#34; } 这里的 &amp;ldquo;lint&amp;rdquo; 命令使用 ESlint 对整个项目进行代码风格检查。</description>
    </item>
    
    <item>
      <title>git 将远程分支拉到本地</title>
      <link>https://tangxiaomi.top/posts/git/remote-branch/</link>
      <pubDate>Mon, 29 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://tangxiaomi.top/posts/git/remote-branch/</guid>
      <description>可以使用以下命令将远程分支拉到本地：
 首先，使用 git remote 命令查看已经添加的远程仓库：  git remote 然后，使用 git fetch 命令将远程分支拉取到本地仓库（不会进行合并）：  git fetch origin remote_branch 最后，使用 git checkout 命令将远程分支切换到本地分支：  git checkout local_branch 组合命令  git fetch origin remote_branch:local_branch 其中，remote_branch 为远程分支名称，origin 为远程仓库名称，local_branch 为本地分支名称，可以根据实际情况进行替换。</description>
    </item>
    
    <item>
      <title>vscode 所有配置对照表</title>
      <link>https://tangxiaomi.top/posts/vscode/setting/</link>
      <pubDate>Mon, 29 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://tangxiaomi.top/posts/vscode/setting/</guid>
      <description>{ // 在保存时自动格式化代码 &amp;#34;editor.formatOnSave&amp;#34;: true, // 在按下“Commit”字符(如&amp;#34;.&amp;#34;或&amp;#34;;&amp;#34;)时接受建议 &amp;#34;editor.acceptSuggestionOnCommitCharacter&amp;#34;: true, // 在按下“Enter”时接受建议 &amp;#34;editor.acceptSuggestionOnEnter&amp;#34;: &amp;#34;on&amp;#34;, // 自动启用辅助功能 &amp;#34;editor.accessibilitySupport&amp;#34;: &amp;#34;auto&amp;#34;, // 启用背景颜色样式，在编辑器中显示错误和警告等 &amp;#34;editor.colorDecorators&amp;#34;: true, // 光标闪烁类型(&amp;#34;blink&amp;#34;、&amp;#34;smooth&amp;#34; 或 &amp;#34;phase&amp;#34;) &amp;#34;editor.cursorBlinking&amp;#34;: &amp;#34;blink&amp;#34;, // 开启平滑光标动画 &amp;#34;editor.cursorSmoothCaretAnimation&amp;#34;: false, // 光标样式(&amp;#34;block&amp;#34;, &amp;#34;line&amp;#34; 或 &amp;#34;underline&amp;#34;) &amp;#34;editor.cursorStyle&amp;#34;: &amp;#34;line&amp;#34;, // 高亮当前行周围的行数(Highlight current line plus n lines) &amp;#34;editor.cursorSurroundingLines&amp;#34;: 3, // 光标宽度，0 表示使用默认值 &amp;#34;editor.cursorWidth&amp;#34;: 0, // 禁用字形图层提示 &amp;#34;editor.disableLayerHinting&amp;#34;: true, // 禁用等宽字体的优化 &amp;#34;editor.disableMonospaceOptimizations&amp;#34;: false, // 启用拖放支持 &amp;#34;editor.dragAndDrop&amp;#34;: true, // 在空文本中复制时复制当前行或上次选区内容 &amp;#34;editor.emptySelectionClipboard&amp;#34;: true, // 额外的编辑器类名 &amp;#34;editor.</description>
    </item>
    
    <item>
      <title>用VSCode配置ESLint自动保存校验</title>
      <link>https://tangxiaomi.top/posts/vscode/eslint/</link>
      <pubDate>Mon, 29 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://tangxiaomi.top/posts/vscode/eslint/</guid>
      <description>简介 ESLint是一个开源的 JavaScript 代码检查工具，可以帮助我们发现代码中存在的错误和潜在问题，并给出推荐的修复方案，从而提高代码的质量和可读性。
本文将要介绍如何在VSCode中配置ESLint，实现自动保存校验功能，让我们的代码更加健康。
步骤 第一步：安装ESLint插件 如果没有安装ESLint插件的话，我们需要先到VSCode插件商店中安装ESLint插件，安装过程非常简单，只需要在搜索框中输入“ESLint”即可。
第二步：安装ESLint模块 在项目中安装ESLint模块依赖，可以使用npm或yarn，如下：
npm install eslint --save-dev 或
yarn add eslint --dev 第三步：创建ESLint配置文件 创建一个名为.eslintrc.json的文件，用来存放ESLint配置信息。
{ &amp;quot;extends&amp;quot;: &amp;quot;eslint:recommended&amp;quot;, &amp;quot;rules&amp;quot;: {} } 这里使用了eslint:recommended作为配置的扩展，这些规则是由ESLint核心团队定义的一组推荐的规则。当然你也可以自定义一些规则，具体可参考官方文档。
第四步：配置VSCode 我们需要在VSCode的配置文件中，添加以下内容实现自动保存校验。
{ &amp;quot;editor.codeActionsOnSave&amp;quot;: { &amp;quot;source.fixAll.eslint&amp;quot;: true }, &amp;quot;editor.formatOnSave&amp;quot;: false, &amp;quot;eslint.alwaysShowStatus&amp;quot;: true, &amp;quot;eslint.validate&amp;quot;: [ &amp;quot;javascript&amp;quot;, &amp;quot;javascriptreact&amp;quot;, { &amp;quot;language&amp;quot;: &amp;quot;vue&amp;quot;, &amp;quot;autoFix&amp;quot;: true }, { &amp;quot;language&amp;quot;: &amp;quot;html&amp;quot;, &amp;quot;autoFix&amp;quot;: true } ] } 这里通过&amp;quot;editor.codeActionsOnSave&amp;quot;属性实现自动保存校验，当我们保存文件时，如果存在ESLint报错，VSCode会自动执行修复操作。
同时将&amp;quot;editor.formatOnSave&amp;quot;设置为false，表示不对存储时代码格式进行调整。
最后配置&amp;quot;eslint.validate&amp;quot;即可，这里我们对&amp;quot;javascript&amp;quot;和&amp;quot;javascriptreact&amp;quot;进行校验和自动修复，同时对Vue和HTML代码添加支持。
总结 通过这个简单的配置，我们可以让ESLint与VSCode紧密地结合在一起，实现在保存代码之前、常规编写过程中进行代码检查校验。这将使我们能够更快地发现并修复潜在的问题，从而提高代码的质量和可读性。</description>
    </item>
    
    <item>
      <title>微信小程序开发入门教程</title>
      <link>https://tangxiaomi.top/posts/mini-program/getting-started/</link>
      <pubDate>Sat, 27 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://tangxiaomi.top/posts/mini-program/getting-started/</guid>
      <description>🚀 前言 微信小程序是一种全新的应用模式，它可以在微信中直接运行，用户无需下载安装即可使用，具有开发简单、轻量级、低成本等优点，非常适合创业公司、个人开发者等快速开发原型或小型商业应用。
🔧 准备工作 1. 安装微信开发者工具 微信小程序开发需要使用微信官方提供的开发者工具，点击这里下载适用于您的操作系统的开发者工具。
2. 注册微信小程序账号 点击这里，注册一个微信小程序账号。
3. 创建小程序 打开微信开发者工具，点击&amp;quot;新建小程序&amp;quot;按钮，按照提示填写小程序基本信息，即可创建一个最简单的小程序。
🚀 开发第一个小程序 1. 目录结构 创建小程序后，微信开发者工具会自动生成一些模板文件，目录结构如下：
myproject ├── app.js ├── app.json ├── app.wxss └── pages └── index ├── index.js ├── index.json ├── index.wxml └── index.wxss 其中，app.js是小程序的脚本文件，app.json是小程序的配置文件，app.wxss是小程序的全局样式表。
pages目录下是小程序的页面文件，每个页面文件都由4个文件组成：脚本文件（.js）、配置文件（.json）、模板文件（.wxml）和样式表文件（.wxss）。
2. Hello World 打开index.wxml，在其中输入以下代码：
&amp;lt;!--index.wxml--&amp;gt; &amp;lt;text&amp;gt;{{message}}&amp;lt;/text&amp;gt; 打开index.js，在其中输入以下代码：
//index.js Page({ data: { message: &amp;#34;Hello World&amp;#34; } }) 应用这些变更后，点击微信开发者工具的&amp;quot;预览&amp;quot;按钮，可以在微信中查看效果。
3. 组件介绍 在示例代码中，我们使用了&amp;lt;text&amp;gt;标签，这是一种小程序内置的组件。在小程序中，所有显示内容都是由组件构成的，组件可以嵌套使用，从而构成丰富的页面布局。
下面简单介绍几个常用组件：
 &amp;lt;view&amp;gt;：与HTML中的&amp;lt;div&amp;gt;类似，用于嵌套其它组件，可以设置样式或事件。 &amp;lt;text&amp;gt;：用于显示文本，可以设置颜色、字体大小等。 &amp;lt;button&amp;gt;：用于创建按钮，可以设置事件。 &amp;lt;image&amp;gt;：用于显示图片，可以设置 src 属性。  4. 数据绑定 在示例代码中，我们使用了{{message}}语法，将message变量的值绑定到&amp;lt;text&amp;gt;组件的内容中。</description>
    </item>
    
    <item>
      <title>js高阶函数</title>
      <link>https://tangxiaomi.top/posts/js/higher-order-function/</link>
      <pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://tangxiaomi.top/posts/js/higher-order-function/</guid>
      <description>JavaScript的高阶函数是一个非常强大的特性，它允许我们编写更加灵活和可重用的代码。在本文中，我们将探讨高阶函数的概念、它们如何实现以及一些示例。
什么是高阶函数 高阶函数是指接受一个或多个函数作为参数，并可以返回函数作为结果的函数。这种函数可以用来将其他函数“包装起来”或者实现某种通用的行为。ES6的箭头函数使得编写高阶函数变得更加简单和方便。
高阶函数的实现 下面是一个使用普通函数实现高阶函数的例子：
function map(arr, fn) { const mappedArr = []; for (let i=0; i&amp;lt;arr.length; i++) { const val = fn(arr[i], i, arr); mappedArr.push(val); } return mappedArr; } 这个函数实现了一个非常常见的高阶函数——map()。它接受一个数组和一个函数作为参数，并返回一个新数组，这个新数组的元素是将原数组的每个元素传递给函数之后得到的新值。
使用箭头函数，我们可以更加简洁地实现同样的功能：
const map = (arr, fn) =&amp;gt; arr.map(fn); 这个例子中，我们用箭头函数实现了一个新的map()函数。它使用了原生的Array.map()方法实现了同样的功能，代码更加简洁和优雅。
高阶函数的示例 现在我们来看一些常见的高阶函数例子，以及它们如何用于实现通用的行为。
forEach() forEach()是一个很常见的高阶函数，它用于遍历数组。我们可以使用它将一个函数应用于数组的每个元素：
const numbers = [1, 2, 3, 4, 5]; numbers.forEach(num =&amp;gt; console.log(num)); 这将会打印数组中的每个数字。
filter() filter()是另一个常见的高阶函数，它用于过滤数组。我们可以使用它筛选出我们想要的元素：
const people = [ {name: &amp;#39;John&amp;#39;, age: 25}, {name: &amp;#39;Jane&amp;#39;, age: 30}, {name: &amp;#39;Bob&amp;#39;, age: 20} ]; const adults = people.</description>
    </item>
    
    <item>
      <title>git 命令手册 📖</title>
      <link>https://tangxiaomi.top/posts/git/guide/</link>
      <pubDate>Tue, 23 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://tangxiaomi.top/posts/git/guide/</guid>
      <description>这是一份 Git 命令的快速查找手册，包含了 Git 的常用命令和基本用法。快速找到你需要的命令和用法，让你的 Git 使用更加轻松自如。
🚀 初始化  git init : 初始化一个 Git 仓库。 git clone &amp;lt;URL&amp;gt; : 克隆一个远程 Git 仓库。  📝 添加与提交  git add &amp;lt;file&amp;gt; : 将文件添加到暂存区。 git add . : 将所有修改添加到暂存区。 git commit -m &amp;quot;&amp;lt;message&amp;gt;&amp;quot; : 提交变更并附上提交信息。 git commit -a : 跳过暂存区，直接提交所有变更。  🌿 分支和合并  git branch : 列出当前仓库的所有分支。 git branch &amp;lt;branch&amp;gt; : 创建一个新分支。 git checkout &amp;lt;branch&amp;gt; : 切换到一个分支。 git checkout -b &amp;lt;branch&amp;gt; : 创建一个新的分支并立即切换到该分支。 git merge &amp;lt;branch&amp;gt; : 合并指定分支到当前分支。 git merge --no-ff &amp;lt;branch&amp;gt; : 强制 Git 创建一个新的合并提交，即使当前分支可以通过快进合并到指定分支。  🔀 推送与拉取  git pull : 从远程仓库拉取代码。 git push : 将本地分支的更改推送到远程仓库。 git push -u &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt; : 第一次推送分支时，使用此命令将本地分支推送到远程仓库。 git fetch &amp;lt;remote&amp;gt; : 从远程仓库拉取变更，但不自动合并它们。 git fetch --all : 从远程仓库拉取所有分支的变更，但不自动合并它们。 git push &amp;lt;remote&amp;gt; --delete &amp;lt;branch&amp;gt; : 从远程仓库删除指定分支。  🔎 查看日志  git log : 查看提交日志。 git log --oneline : 查看简洁的提交日志。 git log --graph --oneline : 查看提交日志并显示分支合并图。 git blame &amp;lt;file&amp;gt; : 显示指定文件的每一行是由谁添加的。  ❌ 撤销与修改  git checkout &amp;lt;file&amp;gt; : 用仓库中的文件替换工作目录中的文件，从而撤消最近的修订。 git reset HEAD &amp;lt;file&amp;gt; : 取消已暂存文件。 git reset HEAD~ : 返回上一个commit版本，并将文件修改保留在工作目录。 git reset &amp;lt;commit&amp;gt; : 恢复指定提交的状态，同时将工作区和暂存区的修改移回到工作区。 git reset --hard : 取消所有本地修改，并恢复到最近的提交状态。 git clean -f : 删除未被跟踪的文件。  🎨 其他命令  git status : 显示工作目录下已提交和未提交的修改。 git diff : 显示工作目录和本地仓库之间的差异。 git stash : 将工作目录中的未提交修改保存到一个栈中。 git stash apply : 恢复最新的stash，并将内容应用于工作区。 git stash list : 显示所有的stash记录。 git stash pop : 删除最新的stash，并将其应用于工作区。 git stash drop : 删除最新的stash。 git remote add &amp;lt;name&amp;gt; &amp;lt;url&amp;gt; : 将一个新远程仓库添加到当前 Git 仓库中。 git remote -v : 显示当前仓库的所有远程仓库及其 URL。 git tag : 列出已经存在的标签。 git tag &amp;lt;tagname&amp;gt; : 新建一个标签，默认为HEAD，用于后续推送到远程仓库。 git push origin &amp;lt;tagname&amp;gt; : 将指定标签推送到远程仓库。 git push origin --tags : 将所有标签推送到远程仓库。 git show &amp;lt;commit&amp;gt; : 显示指定提交的信息。  </description>
    </item>
    
    <item>
      <title>如何在 Vite 中拦截开发服务器并使用 express</title>
      <link>https://tangxiaomi.top/posts/vite/express/</link>
      <pubDate>Tue, 23 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://tangxiaomi.top/posts/vite/express/</guid>
      <description>Vite 是一个快速、轻量级、易于使用的前端工具。它为开发者提供了一种现代的构建方式，可以快速地构建出高效且易于维护的 Web 应用程序。
在 Vite 版本 4.2 及以上的版本中，我们可以使用 configureServer 方法来拦截 Vite 开发服务器，并将其替换为 express HTTP 服务器。这样，我们就可以使用更加灵活的 HTTP 服务器组合，并且可以方便地实现登录、鉴权等功能。
配置 Vite 插件 为了使用自定义的 express 应用程序，我们需要编写一个 Vite 插件
我们可以通过 myPlugin 函数来创建一个新插件。这个插件暴露了一个 configureServer 方法，我们可以在这个方法中创建并配置一个 express 应用程序。
import express from &amp;#39;express&amp;#39; import cors from &amp;#39;cors&amp;#39; import bodyParser from &amp;#39;body-parser&amp;#39; import cookieParser from &amp;#39;cookie-parser&amp;#39; export default function myPlugin () { return { name: &amp;#39;my-plugin&amp;#39;, configureServer (server) { const app = express() app.use(cors({ credentials: true, origin: true })) app.</description>
    </item>
    
  </channel>
</rss>

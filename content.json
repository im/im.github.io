{"pages":[{"title":"links","text":"将纯色背景的图片转换为背景透明的图片 https://www.aigei.com/bgremover/ ui组件 https://bulma.io/documentation/","link":"/links/index.html"},{"title":"search","text":"","link":"/search/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"links","text":"CodeSandbox","link":"/2021/05/26/links/"},{"title":"Windows下如何查看某个端口被谁占用","text":"开始—-&gt;运行—-&gt; cmd ，或者是 window+R 组合键，调出命令窗口。 查找所有运行的端口1netstat -ano 查看被占用端口对应的 PID1netstat -aon|findstr &quot;8081&quot; 查看指定 PID 的进程1tasklist|findstr &quot;9088&quot; 结束进程强制（/F参数）杀死 pid 为 9088 的所有进程包括子进程（/T参数）： 1taskkill /T /F /PID 9088 #Windows#","link":"/2021/05/26/Windows/Windows%E4%B8%8B%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E7%AB%AF%E5%8F%A3%E8%A2%AB%E8%B0%81%E5%8D%A0%E7%94%A8/"},{"title":"Flex布局教程：实例篇","text":"[[Flex 布局教程：语法篇]] 介绍了Flex布局的语法，今天介绍常见布局的Flex写法。 你会看到，不管是什么布局，Flex往往都可以几行命令搞定。 我只列出代码，详细的语法解释请查阅 [[Flex 布局教程：语法篇]]。我的主要参考资料是 Landon Schropp 的文章和 Solved by Flexbox 。 一、骰子的布局骰子的一面，最多可以放置9个点。 下面，就来看看Flex如何实现，从1个点到9个点的布局。你可以到 codepen 查看Demo。 如果不加说明，本节的HTML模板一律如下。 123&lt;div class=&quot;box&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt;&lt;/div&gt; 上面代码中，div元素（代表骰子的一个面）是Flex容器，span元素（代表一个点）是Flex项目。如果有多个项目，就要添加多个span元素，以此类推。 1.1 单项目首先，只有左上角1个点的情况。Flex布局默认就是首行左对齐，所以一行代码就够了。 123.box { display: flex;} 设置项目的对齐方式，就能实现居中对齐和右对齐。 1234.box { display: flex; justify-content: center;} 1234.box { display: flex; justify-content: flex-end;} 设置交叉轴对齐方式，可以垂直移动主轴。 1234.box { display: flex; align-items: center;} 12345.box { display: flex; justify-content: center; align-items: center;} 12345.box { display: flex; justify-content: center; align-items: flex-end;} 12345.box { display: flex; justify-content: flex-end; align-items: flex-end;} 1.2 双项目 1234.box { display: flex; justify-content: space-between;} 12345.box { display: flex; flex-direction: column; justify-content: space-between;} 123456.box { display: flex; flex-direction: column; justify-content: space-between; align-items: center;} 123456.box { display: flex; flex-direction: column; justify-content: space-between; align-items: flex-end;} 1234567.box { display: flex;}.item:nth-child(2) { align-self: center;} 12345678.box { display: flex; justify-content: space-between;}.item:nth-child(2) { align-self: flex-end;} 1.3 三项目 1234567891011.box { display: flex;}.item:nth-child(2) { align-self: center;}.item:nth-child(3) { align-self: flex-end;} 1.4 四项目 123456.box { display: flex; flex-wrap: wrap; justify-content: flex-end; align-content: space-between;} HTML代码如下。 12345678910&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; CSS代码如下。 1234567891011.box { display: flex; flex-wrap: wrap; align-content: space-between;}.column { flex-basis: 100%; display: flex; justify-content: space-between;} 1.5 六项目 12345.box { display: flex; flex-wrap: wrap; align-content: space-between;} 123456.box { display: flex; flex-direction: column; flex-wrap: wrap; align-content: space-between;} HTML代码如下。 1234567891011121314&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; CSS代码如下。 1234567891011121314151617.box { display: flex; flex-wrap: wrap;}.row{ flex-basis: 100%; display:flex;}.row:nth-child(2){ justify-content: center;}.row:nth-child(3){ justify-content: space-between;} 1.6 九项目 1234.box { display: flex; flex-wrap: wrap;} 二、网格布局2.1 基本网格布局最简单的网格布局，就是平均分布。在容器里面平均分配空间，跟上面的骰子布局很像，但是需要设置项目的自动缩放。 HTML代码如下。 12345&lt;div class=&quot;Grid&quot;&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt;&lt;/div&gt; CSS代码如下。 1234567.Grid { display: flex;}.Grid-cell { flex: 1;} 2.2 百分比布局某个网格的宽度为固定的百分比，其余网格平均分配剩余的空间。 HTML代码如下。 12345&lt;div class=&quot;Grid&quot;&gt; &lt;div class=&quot;Grid-cell u-1of4&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell u-1of3&quot;&gt;...&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223.Grid { display: flex;}.Grid-cell { flex: 1;}.Grid-cell.u-full { flex: 0 0 100%;}.Grid-cell.u-1of2 { flex: 0 0 50%;}.Grid-cell.u-1of3 { flex: 0 0 33.3333%;}.Grid-cell.u-1of4 { flex: 0 0 25%;} 三、圣杯布局圣杯布局 （Holy Grail Layout）指的是一种最常见的网站布局。页面从上到下，分成三个部分：头部（header），躯干（body），尾部（footer）。其中躯干又水平分成三栏，从左到右为：导航、主栏、副栏。 HTML代码如下。 123456789&lt;body class=&quot;HolyGrail&quot;&gt; &lt;header&gt;...&lt;/header&gt; &lt;div class=&quot;HolyGrail-body&quot;&gt; &lt;main class=&quot;HolyGrail-content&quot;&gt;...&lt;/main&gt; &lt;nav class=&quot;HolyGrail-nav&quot;&gt;...&lt;/nav&gt; &lt;aside class=&quot;HolyGrail-ads&quot;&gt;...&lt;/aside&gt; &lt;/div&gt; &lt;footer&gt;...&lt;/footer&gt;&lt;/body&gt; CSS代码如下。 1234567891011121314151617181920212223242526272829.HolyGrail { display: flex; min-height: 100vh; flex-direction: column;}header,footer { flex: 1;}.HolyGrail-body { display: flex; flex: 1;}.HolyGrail-content { flex: 1;}.HolyGrail-nav, .HolyGrail-ads { /* 两个边栏的宽度设为12em */ flex: 0 0 12em;}.HolyGrail-nav { /* 导航放到最左边 */ order: -1;} 如果是小屏幕，躯干的三栏自动变为垂直叠加。 1234567891011@media (max-width: 768px) { .HolyGrail-body { flex-direction: column; flex: 1; } .HolyGrail-nav, .HolyGrail-ads, .HolyGrail-content { flex: auto; }} 四、输入框的布局我们常常需要在输入框的前方添加提示，后方添加按钮。 HTML代码如下。 12345&lt;div class=&quot;InputAddOn&quot;&gt; &lt;span class=&quot;InputAddOn-item&quot;&gt;...&lt;/span&gt; &lt;input class=&quot;InputAddOn-field&quot;&gt; &lt;button class=&quot;InputAddOn-item&quot;&gt;...&lt;/button&gt;&lt;/div&gt; CSS代码如下。 1234567.InputAddOn { display: flex;}.InputAddOn-field { flex: 1;} 五、悬挂式布局有时，主栏的左侧或右侧，需要添加一个图片栏。 HTML代码如下。 1234&lt;div class=&quot;Media&quot;&gt; &lt;img class=&quot;Media-figure&quot; src=&quot;&quot; alt=&quot;&quot;&gt; &lt;p class=&quot;Media-body&quot;&gt;...&lt;/p&gt;&lt;/div&gt; CSS代码如下。 123456789101112.Media { display: flex; align-items: flex-start;}.Media-figure { margin-right: 1em;}.Media-body { flex: 1;} 六、固定的底栏有时，页面内容太少，无法占满一屏的高度，底栏就会抬高到页面的中间。这时可以采用Flex布局，让底栏总是出现在页面的底部。 HTML代码如下。 12345&lt;body class=&quot;Site&quot;&gt; &lt;header&gt;...&lt;/header&gt; &lt;main class=&quot;Site-content&quot;&gt;...&lt;/main&gt; &lt;footer&gt;...&lt;/footer&gt;&lt;/body&gt; CSS代码如下。 123456789.Site { display: flex; min-height: 100vh; flex-direction: column;}.Site-content { flex: 1;} 七，流式布局每行的项目数固定，会自动分行。 CSS的写法。 12345678910111213141516.parent { width: 200px; height: 150px; background-color: black; display: flex; flex-flow: row wrap; align-content: flex-start;}.child { box-sizing: border-box; background-color: white; flex: 0 0 25%; height: 50px; border: 1px solid red;} （完） Flex 布局教程：实例篇 #css","link":"/2021/05/26/css/Flex%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B%EF%BC%9A%E5%AE%9E%E4%BE%8B%E7%AF%87/"},{"title":"Flex布局教程：语法篇","text":"网页布局（layout）是 CSS 的一个重点应用。 布局的传统解决方案，基于 盒状模型 ，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如， 垂直居中 就不容易实现。 2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex 布局将成为未来布局的首选方案。本文介绍它的语法， 下一篇文章 给出常见布局的 Flex 写法。网友 JailBreak 为本文的所有示例制作了 Demo ，也可以参考。 以下内容主要参考了下面两篇文章： A Complete Guide to Flexbox 和 A Visual Guide to CSS3 Flexbox Properties 。 一、Flex 布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 123.box{ display: flex;} 行内元素也可以使用 Flex 布局。 123.box{ display: inline-flex;} Webkit 内核的浏览器，必须加上 -webkit 前缀。 1234.box{ display: -webkit-flex; /* Safari */ display: flex;} 注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。 二、基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start ，结束位置叫做 main end ；交叉轴的开始位置叫做 cross start ，结束位置叫做 cross end 。 项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size ，占据的交叉轴空间叫做 cross size 。 三、容器的属性以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 3.1 flex-direction属性flex-direction 属性决定主轴的方向（即项目的排列方向）。 123.box { flex-direction: row | row-reverse | column | column-reverse;} 它可能有4个值。 row （默认值）：主轴为水平方向，起点在左端。 row-reverse ：主轴为水平方向，起点在右端。 column ：主轴为垂直方向，起点在上沿。 column-reverse ：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。 flex-wrap 属性定义，如果一条轴线排不下，如何换行。 123.box{ flex-wrap: nowrap | wrap | wrap-reverse;} 它可能取三个值。 （1） nowrap （默认）：不换行。 （2） wrap ：换行，第一行在上方。 （3） wrap-reverse ：换行，第一行在下方。 3.3 flex-flowflex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap 。 123.box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;} 3.4 justify-content属性justify-content 属性定义了项目在主轴上的对齐方式。 123.box { justify-content: flex-start | flex-end | center | space-between | space-around;} 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start （默认值）：左对齐 flex-end ：右对齐 center ： 居中 space-between ：两端对齐，项目之间的间隔都相等。 space-around ：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性align-items 属性定义项目在交叉轴上如何对齐。 123.box { align-items: flex-start | flex-end | center | baseline | stretch;} 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start ：交叉轴的起点对齐。 flex-end ：交叉轴的终点对齐。 center ：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch （默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.box { align-content: flex-start | flex-end | center | space-between | space-around | stretch;} 该属性可能取6个值。 flex-start ：与交叉轴的起点对齐。 flex-end ：与交叉轴的终点对齐。 center ：与交叉轴的中点对齐。 space-between ：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around ：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch （默认值）：轴线占满整个交叉轴。 四、项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 4.1 order属性order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.item { order: &lt;integer&gt;;} 4.2 flex-grow属性flex-grow 属性定义项目的放大比例，默认为 0 ，即如果存在剩余空间，也不放大。 123.item { flex-grow: &lt;number&gt;; /* default 0 */} 如果所有项目的 flex-grow 属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的 flex-grow 属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item { flex-shrink: &lt;number&gt;; /* default 1 */} 如果所有项目的 flex-shrink 属性都为1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4.4 flex-basis属性flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto ，即项目的本来大小。 123.item { flex-basis: &lt;length&gt; | auto; /* default auto */} 它可以设为跟 width 或 height 属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto 。后两个属性可选。 123.item { flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]} 该属性有两个快捷值： auto ( 1 1 auto ) 和 none ( 0 0 auto )。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto ，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch 。 123.item { align-self: auto | flex-start | flex-end | center | baseline | stretch;} 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 （完） Flex 布局教程：语法篇 #css","link":"/2021/05/26/css/Flex%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B%EF%BC%9A%E8%AF%AD%E6%B3%95%E7%AF%87/"},{"title":"css中的bfc（BlockFormattingContexts）","text":"常见定位方案在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案: 普通流 (normal flow) 在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。 浮动 (float) 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。 绝对定位 (absolute positioning) 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。 BFC 概念Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 那么 BFC 是什么呢？ BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。 具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。 通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 触发 BFC只要元素满足下面任一条件即可触发 BFC 特性： body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) BFC 特性及应用同一个 BFC 下外边距会发生折叠从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。 See the Pen BFC边距重叠1 by 糖小米 . (@tangxiaomi) on CodePen. 首先这不是 CSS 的 bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 See the Pen BFC边距重叠2 by 糖小米 . (@tangxiaomi) on CodePen. ### BFC 可以包含浮动的元素（清除浮动） 我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子 See the Pen BFC浮动1 by 糖小米 . (@tangxiaomi) on CodePen. 由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。 See the Pen BFC浮动2 by 糖小米 . (@tangxiaomi) on CodePen. ### BFC 可以阻止元素被浮动元素覆盖 先来看一个文字环绕效果： See the Pen BFC浮动覆盖1 by 糖小米 . (@tangxiaomi) on CodePen. 这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden，就会变成： See the Pen BFC浮动覆盖2 by 糖小米 . (@tangxiaomi) on CodePen. 这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。 #css","link":"/2021/05/26/css/css%E4%B8%AD%E7%9A%84bfc%EF%BC%88BlockFormattingContexts%EF%BC%89/"},{"title":"gitsubmodule","text":"添加12345git submodule add -b [指定分支] [仓库地址] [路径]example:git submodule add -b icarus https://github.com/im/hexo-theme.git themes/icarus 命令执行完成，会在当前工程根路径下生成一个名为 .gitmodules 的文件，其中记录了子模块的信息。 .gitmodules 1234[submodule &quot;themes/icarus&quot;] path = themes/icarus url = https://github.com/im/hexo-theme.git branch = icarus 更新1git submodule update 删除submodule 的删除稍微麻烦点：首先，要在 .gitmodules 文件中删除相应配置信息。然后，执行 git rm –cached 命令将子模块所在的文件从 git 中删除。 下载的工程带有submodule1git submodule update --init --recursive #git","link":"/2021/05/26/git/gitsubmodule/"},{"title":"git修改远程仓库地址","text":"命令直接修改1git remote set-url origin [url] 先删后加1git remote rm origingit remote add origin [url] 直接修改配置文件1234567891011121314151617181920[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true[remote &quot;origin&quot;] url = https://github.com/im/im.github.io.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;main&quot;] remote = origin merge = refs/heads/main[submodule &quot;themes/icarus&quot;] active = true url = https://github.com/im/hexo-theme.git[submodule &quot;themes/cactus&quot;] url = https://github.com/im/hexo-theme.git active = true 查看远程地址1git remote -v git 修改远程仓库地址 #git","link":"/2021/05/26/git/git%E4%BF%AE%E6%94%B9%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80/"},{"title":"git常用命令","text":"恢复修改过的文件1git checkout file_name 获取远程分支1git checkout --track origin/branch_name 本地分支关联远程分支1git branch --set-upstream-to=origin/[branch_name] [branch_name] 合并某一次提交1git cherry-pick commit_id 查看最近3条更新日志，并且简单显示修改的文件12# 查看最近3条更新日志，并且简单显示修改的文件 git log -3 -—stat 命令行看提交记录图形1git log --oneline --graph 查看指定提交的内容1git show [commit_id] -—stat 恢复修改过的文件1git chekout [file_name] 本地分支推送到远程分支1git push -—set-upstream origin [branch_nam] 将远程分支拉到本地1git checkout —track origin/branch_name 合并某一次提交到指定分支* 获取此次提交的commit_id * 切换到需要合并的分支 1git cherry-pick [commit_id] 远程分支覆盖本地分支123git fetch -—all // fetch所有分支上的内容，也可以选择只备份一部分内容 git reset -—hard origin/master // 重置本地分支（这里master要修改为对应的分支名） git pull clone 远程仓库1git clone ssh://git@github.com:im/im.github.io.git 初始化本地 git 仓库（新建仓库）1git init 查看当前版本状态（是否修改）1git status 显示所有未添加至 index 的变更1git diff 比较与上一个版本的差异1git diff HEAD^ / HEAD -- ./lib 增加更改过的文件至 index1git add . / add * ... 提交1git commit -m ‘xxx’ 合并上一次提交（用于反复修改）12345git commit -amend -m ‘xxx’add 和 commit 合为一步git commit -am ‘xxx’ 显示日志1git log 显示某个提交的详细内容1git show &lt;commit&gt; 在每一行显示 commit 号,提交者,最早提交日期1git blame &lt;file&gt; 显示本地分支1git branch 切换分支1git checkout &lt;branch&gt; 新建分支1git branch &lt;new-branch&gt; 创建新分支跟踪远程分支1git branch --track &lt;new&gt; &lt;remote&gt; 删除本地分支1git branch -d &lt;branch&gt; 给当前分支打标签1git tag &lt;tag-name&gt; 列出远程分支详细信息1git remote -v 显示某个分支信息1git remote show &lt;remote&gt; 添加一个新的远程仓库1git remote add &lt;remote&gt; &lt;url&gt; 获取远程分支，但不更新本地分支，另需 merge1git fetch &lt;remote&gt; 获取远程分支，并更新本地分支1git pull &lt;remote&gt; &lt;branch&gt; 推送本地更新到远程分支1git push &lt;remote&gt; &lt;branch&gt; 删除一个远程分支1git push &lt;remote&gt; --delete &lt;branch&gt; 推送本地标签1git push --tags 合并分支到当前分支，存在两个1git merge &lt;branch&gt; 合并分支到当前分支，存在一个1git rebase &lt;branch&gt; 回到执行 rebase 之前123git rebase --abort 解决矛盾后继续执行 rebase git rebase --continue 使用 mergetool 解决冲突git mergetool 使用冲突文件解决冲突123git add &lt;resolve-file&gt;git rm &lt;resolved-file&gt; 将当前版本重置为 HEAD（用于 merge 失败）1git reset --hard HEAD 将当前版本重置至某一个提交状态（慎用！）1git reset --hard &lt;commit&gt; 将当前版本重置至某一个提交状态，代码不变1git reset &lt;commit&gt; 重置至某一状态，保留版本库中不同的文件1git reset --merge &lt;commit&gt; 重置至某一状态，重置变化的文件，代码改变1git reset --keep &lt;commit&gt; 丢弃本地更改信息并将其存入特定文件1git checkout HEAD &lt;file&gt; 撤销提交1git revert &lt;commit&gt; #git","link":"/2021/05/26/git/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"git添加sshkey","text":"创建 SSH Key123ssh-keygen -t rsa -C &quot;tangxiaomiemail@gmail.com&quot;cd ~/.sshcat id_rsa.pub 如果一切顺利的话，可以在用户主目录里找到 .ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人. 全局配置12git config --global user.name &quot;tangxiaomi&quot;git config --global user.email &quot;tangxiaomiemail@gmail.com&quot; 非全局配置 删除 --global12git config user.name &quot;tangxiaomi&quot;git config user.email &quot;tangxiaomiemail@gmail.com&quot; 查看配置12git config --global user.namegit config --global user.email 取消全局配置12345git config --global --unset user.namegit config --global --unset user.emailgit config --global user.name #(查看)全局配置账户是否已经移除git config --global user.email #(查看)全局配置邮箱是否已经移除 #git","link":"/2021/05/26/git/git%E6%B7%BB%E5%8A%A0sshkey/"},{"title":"1.页面导入样式时，使用link和@import有什么区别？","text":"描述 页面导入样式时，使用link和@import有什么区别？ 解答 link 是HTML标签，@import 是 css 提供的。 link 引入的样式页面加载时同时加载，@import 引入的样式需等页面加载完成后再加载。 link 没有兼容性问题，@import 不兼容 ie5 以下。 link 可以通过 js 操作 DOM 动态引入样式表改变样式，而 @import 不可以。 #interview/html","link":"/2021/05/26/interview/1.%E9%A1%B5%E9%9D%A2%E5%AF%BC%E5%85%A5%E6%A0%B7%E5%BC%8F%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8link%E5%92%8C@import%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"},{"title":"2.圣杯布局和双飞翼布局的理解和区别，并用代码实现","text":"理解圣杯布局和双飞翼布局都是为了解决两边定宽，中间自适应且优先渲染的布局需求，那么为了自适应且优先渲染，必须要把中间的 dom 放在最顶端，以保证主要内容能最先被浏览器解析 圣杯布局为了中间 div 内容不被遮挡，将中间 div 设置了左右 padding-left 和 padding-right 后，将左右两个 div 用相对布局 position: relative 并分别配合 right 和 left 属性，以便左右两栏 div 移动后不遮挡中间 div html123456789&lt;body&gt; &lt;div id=&quot;hd&quot;&gt;header&lt;/div&gt; &lt;div id=&quot;bd&quot;&gt; &lt;div id=&quot;middle&quot;&gt;middle&lt;/div&gt; &lt;div id=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt;&lt;/body&gt; css12345678910111213141516171819202122232425262728293031323334353637383940#hd height: 50px background:666 text-align: center#bd /* 左右栏通过添加负的margin放到正确的位置了，此段代码是为了摆正中间栏的位置 */ padding: 0 200px 0 180px height: 100px#middle float: left width: 100% /* 左栏上去到第一行 */ height: 100px background: blue#left float: left width: 180px height: 100px margin-left: -100% background:#0c9 /* 中间栏的位置摆正之后，左栏的位置也相应右移，通过相对定位的left恢复到正确位置 */ position: relative left: -180px#right float: left width: 200px height: 100px margin-left: -200px background:#0c9 /* 中间栏的位置摆正之后，右栏的位置也相应左移，通过相对定位的right恢复到正确位置 */ position: relative right: -200px#footer height: 50px background:#666 text-align: center 双飞翼布局为了中间 div 内容不被遮挡，直接在中间 div 内部创建子 div 用于放置内容，在该子 div 里用 margin-left 和 margin-right 为左右两栏 div 留出位置。多了1个 div ，少用大致4个 css 属性（圣杯布局中间 div padding-left 和 padding-right 这2个属性，加上左右两个 div 用相对布局 position: relative 及对应的 right 和 left 共4个属性，一共6个；而双飞翼布局子div里用 margin-left 和 margin-right 共2个属性，6-2=4），个人感觉比圣杯布局思路更直接和简洁一点。 hrml123456789&lt;body&gt; &lt;div id=&quot;hd&quot;&gt;header&lt;/div&gt; &lt;div id=&quot;middle&quot;&gt; &lt;div id=&quot;inside&quot;&gt;middle&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;right&lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt;&lt;/body&gt; css1234567891011121314151617181920212223242526272829303132333435#hd height: 50px background:#666 text-align: center#middle float: left width: 100% /* 左栏上去到第一行 */ height: 100px background: blue#left float: left width: 180px height: 100px margin-left: -100% background:#0c9#right float: left width: 200px height: 100px margin-left: -200px background:#0c9/* 给内部div添加margin，把内容放到中间栏，其实整个背景还是100% */#inside margin: 0 200px 0 180px height: 100px#footer clear: both /* 记得清楚浮动 */ height: 50px background:#666 text-align: center flex 实现圣杯布局html12345&lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;center&quot;&gt;center&lt;/div&gt; &lt;div id=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;right&lt;/div&gt;&lt;/div&gt; css123456789101112131415161718#container display: flex#center flex: 1 height 50px background blue#left flex: 0 0 200px order: -1 height 50px background yellow#right flex: 0 0 150px height 50px background green 参考文章： 圣杯布局和双飞翼布局的理解与思考 #interview/css","link":"/2021/05/26/interview/2.%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%B9%B6%E7%94%A8%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"},{"title":"3.用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值","text":"描述这是一道大题目，把考点拆成了4个小项；需要侯选人用递归算法实现（限制15行代码以内实现；限制时间10分钟内完成）： 生成一个长度为5的空数组 arr 。 生成一个（2－32）之间的随机整数 rand。 把随机数 rand 插入到数组 arr 内，如果数组arr内已存在与 rand 相同的数字，则重新生成随机数rand并插入到arr内[需要使用递归实现，不能使用 for/while 等循环] 最终输出一个长度为5，且内容不重复的数组 arr 。 解答1234567891011const arr = new Array(5);const randomNum = () =&gt; (Math.floor(Math.random() * 31 + 2))const randomArr = (n) =&gt; { if (n === 0) return arr; const num = randomNum(); if (arr.includes(num)) return randomArr(n) arr[n -1] = num; return randomArr(n - 1)};randomArr(arr.length) #interview/javascript","link":"/2021/05/26/interview/3.%E7%94%A8%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%8C%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E4%B8%BA5%E4%B8%94%E5%85%83%E7%B4%A0%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%9C%A82-32%E9%97%B4%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%80%BC/"},{"title":"4.html的元素有哪些（包含H5）？","text":"描述区分出行内元素、块级元素、空元素并在后面简要标注下作用 行内元素 a b span strong i em button input label br textarea select 块元素 div p h1-h6 ol ul li table tbody td tr thead dl dt dd H5新增元素 section 标签定义文档中的节 article 标签的内容独立于文档的其余部分 audio 标签定义声音，比如音乐或其他音频流 video 标签定义视频，比如电影片段或其他视频流 hearder 标签定义文档的页眉（介绍信息） footer 标签定义文档或节的页脚 small 标签呈现小号字体效果 canvas 定义画布 #interview/html","link":"/2021/05/26/interview/4.html%E7%9A%84%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%88%E5%8C%85%E5%90%ABH5%EF%BC%89%EF%BC%9F/"},{"title":"6.写一个方法去掉字符串中的空格","text":"描述写一个方法去掉字符串中的空格，要求传入不同的类型分别能去掉前、后、前后、中间的空格 解答12345678910111213141516171819202122232425262728293031323334353637383940const str = &quot; s t r &quot;;const POSITION = Object.freeze({ left: Symbol(), right: Symbol(), both: Symbol(), center: Symbol(), all: Symbol()});function trim(str, position = POSITION.both) { if (!!POSITION[position]) throw new Error(&quot;unexpected position value&quot;); switch (position) { case POSITION.left: str = str.replace(/^\\s+/, &quot;&quot;); break; case POSITION.right: str = str.replace(/\\s+$/, &quot;&quot;); break; case POSITION.both: str = str.replace(/^\\s+/, &quot;&quot;).replace(/\\s+$/, &quot;&quot;); break; case POSITION.center: while (str.match(/\\w\\s+\\w/)) { str = str.replace(/(\\w)(\\s+)(\\w)/, `$1$3`); } break; case POSITION.all: str = str.replace(/\\s/g, &quot;&quot;); break; default: } return str;}const result = trim(str);console.log(`|${result}|`); // |s t r| #interview/javascript","link":"/2021/05/26/interview/6.%E5%86%99%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%8E%BB%E6%8E%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC/"},{"title":"7.HTML全局属性(globalattribute)有哪些（包含H5）？","text":"accesskey 设置快捷键class 为元素设置类标识contenteditable 指定元素内容是否可编辑contextmenu 自定义鼠标右键弹出上下文菜单内容（仅firefox支持）data-* 为元素增加自定义属性dir：设置元素文本方向（默认ltr；rtl）draggable 设置元素是否可拖拽dropzone 设置元素拖放类型（copy|move|link,H5新属性，主流均不支持）hidden 规定元素仍未或不在相关id 元素id，文档内唯一lang 元素内容的语言spellcheck 是否启动拼写和语法检查style 行内css样式tabindex 设置元素可以获得焦点，通过tab导航title 规定元素有关的额外信息 相关链接：Global attributes #interview/html","link":"/2021/05/26/interview/7.HTML%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7(globalattribute)%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%88%E5%8C%85%E5%90%ABH5%EF%BC%89%EF%BC%9F/"},{"title":"8.在页面上隐藏元素的方法有哪些？","text":"描述在页面上隐藏元素的方法有哪些？ 并简述出第一种方法的应用场景和优劣势 解答 占位: visibility: hidden; 看不见但是会占据空间margin-left: -100%;opacity: 0; 看不见但是会占据空间transform: scale(0);filter: opacity(0); 不占位: display: none; 页面不会渲染width: 0;height: 0;overflow: hidden; 页面会渲染但是不显示position 配合 z-index; 或者 left/top/bottom/right ： -100%；transform: scale(0);translateX(+-100%);translateY(+-100%);rotateX(90deg); 仅对块内文本元素: text-indent: -9999px;font-size: 0; #interview/css","link":"/2021/05/26/interview/8.%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%8A%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"},{"title":"HTML5Canvas生成粒子效果","text":"Installbreathing-halftone.pkgd.min.js Usage12345678910// get the image// jqueryvar img = $('#hero img')[0]// or vanilla JSvar img = document.querySelector('#hero img')// init halftonenew BreathingHalftone(img, { // options...}) Options1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556{ &quot;dotSize&quot;: 1 / 150, //点的大小 //作为图像对角线的一小部分 //较小的点=较多的点=性能较差 &quot;dotSizeThreshold&quot;: 0.05, //隐藏小于百分比的点 &quot;initVelocity&quot;: 0.1, //点开始增长的速度 &quot;oscPeriod&quot;: 3, //点大小振荡或“呼吸”周期的持续时间（以秒为单位） &quot;oscAmplitude&quot;: 0.2, //振荡变化百分比 &quot;isAdditive&quot;: false, //添加剂是带有RGB点的黑色， //减法为带有CMK点的白色 &quot;isRadial&quot;: false, //启用径向网格布局 &quot;channels&quot;: [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;], //点层 //'lum'是另一个受支持的通道，以实现亮度 &quot;isChannelLens&quot;: true, //禁用位移时更改点的大小 &quot;friction&quot;: 0.06, //较低的点使点更容易移动，较高的点使点更难 &quot;hoverDiameter&quot;: 0.2, //悬停效果的大小 //作为图像对角线的一小部分 &quot;hoverForce&quot;: 0.01, //悬停效果的力量 //负值会拉入点，正值会拉出 &quot;activeDiameter&quot;: 0.6, //点击/点击效果的大小 //作为图像对角线的一小部分 &quot;activeForce&quot;: 0.01 //悬停效果的力量 //负值会拉入点，正值会拉出} Dome12345678910&lt;script src=&quot;https://cdn.jsdelivr.net/gh/im/oss@master/js/breathing-halftone.pkgd.min.js&quot;&gt;&lt;/script&gt;&lt;img width=&quot;400&quot; height=&quot;400&quot; id=&quot;html5-canvas-particle-effect-dome&quot; src=&quot;/images/header/avatar.jpg&quot; /&gt;&lt;script&gt;window.onload = function () { var img = document.getElementById('html5-canvas-particle-effect-dome') new BreathingHalftone(img, { &quot;dotSize&quot;: 1 / 150 })}&lt;/script&gt; Quote http://breathing-halftone.desandro.com/ #javascript","link":"/2021/05/26/javascript/HTML5Canvas%E7%94%9F%E6%88%90%E7%B2%92%E5%AD%90%E6%95%88%E6%9E%9C/"},{"title":"JavaScript内存泄漏教程","text":"程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。 对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。 有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。 123456char * buffer;buffer = (char*) malloc(42);// Do something with bufferfree(buffer); 上面是 C 语言代码， malloc 方法用来申请内存，使用完毕之后，必须自己用 free 方法释放内存。 这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”（garbage collector）。 二、垃圾回收机制垃圾回收机制怎么知道，哪些内存不再需要呢？ 最常使用的方法叫做 “引用计数” （reference counting）：语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是 0 ，就表示这个值不再用到了，因此可以将这块内存释放。 上图中，左下角的两个值，没有任何引用，所以可以释放。 如果一个值不再需要了，引用数却不为 0 ，垃圾回收机制无法释放这块内存，从而导致内存泄漏。 12const arr = [1, 2, 3, 4];console.log('hello world'); 上面代码中，数组 [1, 2, 3, 4] 是一个值，会占用内存。变量 arr 是仅有的对这个值的引用，因此引用次数为 1 。尽管后面的代码没有用到 arr ，它还是会持续占用内存。 如果增加一行代码，解除 arr 对 [1, 2, 3, 4] 引用，这块内存就可以被垃圾回收机制释放了。 123let arr = [1, 2, 3, 4];console.log('hello world');arr = null; 上面代码中， arr 重置为 null ，就解除了对 [1, 2, 3, 4] 的引用，引用次数变成了 0 ，内存就可以释放出来了。 因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。 三、内存泄漏的识别方法怎样可以观察到内存泄漏呢？ 经验法则 是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。 3.1 浏览器Chrome 浏览器查看内存占用，按照以下步骤操作。 打开开发者工具，选择 Timeline 面板 在顶部的 Capture 字段里面勾选 Memory 点击左上角的录制按钮。 在页面上进行各种操作，模拟用户的使用情况。 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。 如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。 反之，就是内存泄漏了。 3.2 命令行命令行可以使用 Node 提供的 process.memoryUsage 方法。 12345console.log(process.memoryUsage());// { rss: 27709440,// heapTotal: 5685248,// heapUsed: 3449392,// external: 8772 } process.memoryUsage 返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，单位是字节， 含义 如下。 rss（resident set size）：所有内存占用，包括指令区和堆栈。 heapTotal：”堆”占用的内存，包括用到的和没用到的。 heapUsed：用到的堆的部分。 external： V8 引擎内部的 C++ 对象占用的内存。 判断内存泄漏，以 heapUsed 字段为准。 四、WeakMap前面说过，及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄漏。 最好能有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。 ES6 考虑到了这一点，推出了两种新的数据结构： WeakSet 和 WeakMap 。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个”Weak”，表示这是弱引用。 下面以 WeakMap 为例，看看它是怎么解决内存泄漏的。 123456const wm = new WeakMap();const element = document.getElementById('example');wm.set(element, 'some information');wm.get(element) // &quot;some information&quot; 上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对 element 的引用就是弱引用，不会被计入垃圾回收机制。 也就是说，DOM 节点对象的引用计数是 1 ，而不是 2 。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。 五、WeakMap 示例WeakMap 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 WeakMap 的键名了，导致无法证实那个键名是不是存在。 我一直想不出办法，直到有一天贺师俊老师 提示 ，如果引用所指向的值占用特别多的内存，就可以通过 process.memoryUsage 方法看出来。 根据这个思路，网友 vtxf 补充了下面的 例子 。 首先，打开 Node 命令行。 1$ node --expose-gc 上面代码中， --expose-gc 参数表示允许手动执行垃圾回收机制。 然后，执行下面的代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 手动执行一次垃圾回收，保证获取的内存使用状态准确&gt; global.gc(); undefined// 查看内存占用的初始状态，heapUsed 为 4M 左右&gt; process.memoryUsage(); { rss: 21106688, heapTotal: 7376896, heapUsed: 4153936, external: 9059 }&gt; let wm = new WeakMap();undefined&gt; let b = new Object();undefined&gt; global.gc();undefined// 此时，heapUsed 仍然为 4M 左右&gt; process.memoryUsage(); { rss: 20537344, heapTotal: 9474048, heapUsed: 3967272, external: 8993 }// 在 WeakMap 中添加一个键值对，// 键名为对象 b，键值为一个 5*1024*1024 的数组 &gt; wm.set(b, new Array(5*1024*1024));WeakMap {}// 手动执行一次垃圾回收&gt; global.gc();undefined// 此时，heapUsed 为 45M 左右&gt; process.memoryUsage(); { rss: 62652416, heapTotal: 51437568, heapUsed: 45911664, external: 8951 }// 解除对象 b 的引用 &gt; b = null;null// 再次执行垃圾回收&gt; global.gc();undefined// 解除 b 的引用以后，heapUsed 变回 4M 左右// 说明 WeakMap 中的那个长度为 5*1024*1024 的数组被销毁了&gt; process.memoryUsage(); { rss: 20639744, heapTotal: 8425472, heapUsed: 3979792, external: 8956 } 上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了它的帮助，解决内存泄漏就会简单很多。 JavaScript 内存泄漏教程 #javascript","link":"/2021/05/26/javascript/JavaScript%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%95%99%E7%A8%8B/"},{"title":"JavaScript实现前端下载图片","text":"实现思路 将图片装换成 Data URLs 下载图片 Data URLs Data URLs，即前缀为 data: 协议的的 URL，其允许内容创建者向文档中嵌入小文件。Data URLs 由四个部分组成：前缀(data:)、指示数据类型的 MIME 类型、如果非文本则为可选的 base64 标记、数据本身：data:[][;base64],mediative 是个 MIME 类型的字符串，例如 “image/jpeg” 表示 JPEG 图像文件。如果被省略，则默认值为 text/plain;charset=US-ASCII如果数据是文本类型，你可以直接将文本嵌入 (根据文档类型，使用合适的实体字符或转义字符)。如果是二进制数据，你可以将数据进行 base64 编码之后再进行嵌入。 详细请看 MDN 对 Data URLs 的解释。 代码实现以下是获取图片 DataURL 的示例代码： 123456789101112131415161718/*** 获取图片的 base64 编码 DataURL* @param image JS 图像对象* @return {string} 已编码的 DataURL*/getImageDataURL(image) { // 创建画布 const canvas = document.createElement('canvas'); canvas.width = image.width; canvas.height = image.height; const ctx = canvas.getContext('2d'); // 以图片为背景剪裁画布 ctx.drawImage(image, 0, 0, image.width, image.height); // 获取图片后缀名 const extension = image.src.substring(image.src.lastIndexOf('.') + 1).toLowerCase(); // 某些图片 url 可能没有后缀名，默认是 png return canvas.toDataURL('image/' + extension, 1);} 执行上面的函数后会返回如下面的格式一样的字符串 1data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAgAElEQVR4Xu1dB3hUxfb/bc3uppOeQOgIAioKCiqWJ/bysFd89vcXe0WfvSJ2wY6gPhX1WZ... 注意：图片越大，转换后的 base64 编码越长，尽量避免对大图进行 DataURL 转换，防止转换后的长度超出浏览器限制 以下是下载图片的示例代码： 12345678910111213141516downLoad(downloadName, url) { const tag = document.createElement('a'); // 此属性的值就是下载时图片的名称，注意，名称中不能有半角点，否则下载时后缀名会错误 tag.setAttribute('download', downloadName.replace(/\\./g, '。')); const image = new Image(); // 设置 image 的 url, 添加时间戳，防止浏览器缓存图片 image.src = url + '?time=' + new Date().getTime(); //重要，设置 crossOrigin 属性，否则图片跨域会报错 image.setAttribute('crossOrigin', 'Anonymous'); // 图片未加载完成时操作会报错 image.onload = () =&gt; { tag.href = getImageDataURL(image); tag.click(); };} #javascript","link":"/2021/05/26/javascript/JavaScript%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87/"},{"title":"JavaScript实现复制粘贴","text":"实现思路html:1&lt;button onclick=&quot;copyToClip('内容')&quot;&gt;Copy&lt;/button&gt; javascript:123456789101112131415161718/** * 复制内容到粘贴板 * content : 需要复制的内容 * message : 复制完后的提示，不传则默认提示&quot;复制成功&quot; */function copyToClip(content, message) { var aux = document.createElement('input') aux.setAttribute('value', content) document.body.appendChild(aux) aux.select() document.execCommand('copy') document.body.removeChild(aux) if (message == null) { alert('复制成功') } else { alert(mesage) }} (clipboard.js)[https://clipboardjs.com/]直接引用： &lt;script src=&quot;dist/clipboard.min.js&quot;&gt;&lt;/script&gt; 包： npm install clipboard --save ，然后 import Clipboard from 'clipboard' html:12&lt;input id=&quot;demoInput&quot; value=&quot;hello world&quot; /&gt;&lt;button class=&quot;btn&quot; data-clipboard-target=&quot;#demoInput&quot;&gt;点我复制&lt;/button&gt; javascript:12import Clipboard from 'clipboard'const btnCopy = new Clipboard('btn') #javascript","link":"/2021/05/26/javascript/JavaScript%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4/"},{"title":"JavaScript的静态作用域链与“动态”闭包链","text":"读完本文会解答你以下疑问： 静态作用域链和动态作用域链的区别 为什么会有闭包 闭包什么时候创建的 [[scopes]] 属性是什么 闭包保存什么内容 闭包存储在哪 为什么 eval 性能不好 eval 什么情况下会创建闭包 在 JavaScript 里面，函数、块、模块都可以形成作用域（一个存放变量的独立空间），他们之间可以相互嵌套，作用域之间会形成引用关系，这条链叫做作用域链。 作用域链具体是什么样呢？ 静态作用域链比如这样一段代码 1234567891011function func() { const guang = 'guang'; function func2() { const ssh = 'ssh'; { function func3 () { const suzhe = 'suzhe'; } } }} 其中，有 guang、ssh、suzhe 3个变量，有 func、func2、func3 3个函数，还有一个块，他们之间的作用域链可以用babel查看一下。 12345678910111213141516171819202122232425const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const code = ` function func() { const guang = 'guang'; function func2() { const ssh = 'ssh'; { function func3 () { const suzhe = 'suzhe'; } } } }`;const ast = parser.parse(code);traverse(ast, { FunctionDeclaration (path) { if (path.get('id.name').node === 'func3') { console.log(path.scope.dump()); } }}) 结果是 用图可视化一下就是这样的 函数和块的作用域内的变量声明会在作用域 （scope） 内创建一个绑定（变量名绑定到具体的值，也就是 binding），然后其余地方可以引用 （refer） 这个 binding，这样就是静态作用域链的变量访问顺序。 为什么叫“静态”呢？ 因为这样的嵌套关系是分析代码就可以得出的，不需要运行，按照这种顺序访问变量的链就是静态作用域链，这种链的好处是可以直观的知道变量之间的引用关系。 相对的，还有动态作用域链，也就是作用域的引用关系与嵌套关系无关，与执行顺序有关，会在执行的时候动态创建不同函数、块的作用域的引用关系。缺点就是不直观，没法静态分析。 静态作用域链是可以做静态分析的，比如我们刚刚用 babel 分析的 scope 链就是。所以绝大多数编程语言都是作用域链设计都是选择静态的顺序。 但是，JavaScript 除了静态作用域链外，还有一个特点就是函数可以作为返回值。比如 1234567function func () { const a = 1; return function () { console.log(a); }}const f2 = func(); 这就导致了一个问题，本来按照顺序创建调用一层层函数，按顺序创建和销毁作用域挺好的，但是如果内层函数返回了或者通过别的暴露出去了，那么外层函数销毁，内层函数却没有销毁，这时候怎么处理作用域，父作用域销不销毁？ （比如这里的 func 调用结束要不要销毁作用域） 不按顺序的函数调用与闭包比如把上面的代码做下改造，返回内部函数，然后在外面调用： 12345678910111213function func() { const guang = 'guang'; function func2() { const ssh = 'ssh'; function func3 () { const suzhe = 'suzhe'; } return func3; } return func2;}const func2 = func(); 当调用 func2 的时候 func1 已经执行完了，这时候销不销毁 ？于是 JavaScript 就设计了闭包的机制。 闭包怎么设计？先不看答案，考虑一下我们解决这个静态作用域链中的父作用域先于子作用域销毁怎么解决。 首先，父作用域要不要销毁？ 是不是父作用域不销毁就行了？ 不行的，父作用域中有很多东西与子函数无关，为啥因为子函数没结束就一直常驻内存。这样肯定有性能问题，所以还是要销毁。 但是销毁了父作用域不能影响子函数，所以要再创建个对象，要把子函数内引用（refer）的父作用域的变量打包里来，给子函数打包带走。 怎么让子函数打包带走？ 设计个独特的属性，比如 [[Scopes]]，用这个来放函数打包带走的用到的环境。并且这个属性得是一个栈，因为函数有子函数、子函数可能还有子函数，每次打包都要放在这里一个包，所以就要设计成一个栈结构，就像饭盒有多层一样。 我们所考虑的这个解决方案：销毁父作用域后，把用到的变量包起来，打包给子函数，放到一个属性上。这就是闭包的机制。 我们来试验一下闭包的特性： 这个 func3 需不需要打包一些东西？ 会不会有闭包？ 其实还是有闭包的，闭包最少会包含全局作用域。 但是为啥 guang、ssh、suzhe 都没有 ？ suzhe是因为不是外部的，只有外部变量的时候才会生成，比如我们改动下代码，打印下这 3 个变量。 再次查看 [[Scopes]] （打包带走的闭包环境）： 这时候就有俩闭包了，为什么呢？ suzhe 哪去了？ 首先，我们需要打包的只是环境内没有的，也就是闭包只保存外部引用。然后是在创建函数的时候保存到函数属性上的，创建的函数返回的时候会打包给函数，但是 JS 引擎怎么知道它要用到哪些外部引用呢，需要做 AST 扫描，很多 JS 引擎会做 Lazy Parsing，这时候去 parse 函数，正好也能知道它用到了哪些外部引用，然后把这些外部用打包成 Closure 闭包，加到 [[scopes]] 中。 所以， 闭包是返回函数的时候扫描函数内的标识符引用，把用到的本作用域的变量打成 Closure 包，放到 [[Scopes]] 里。 所以上面的函数会在 func3 返回的时候扫描函数内的标识符，把 guang、ssh 扫描出来了，就顺着作用域链条查找这俩变量，过滤出来打包成两个 Closure（因为属于两个作用域，所以生成两个 Closure），再加上最外层 Global，设置给函数 func3 的 [[scopes]] 属性，让它打包带走。 调用 func3 的时候，JS 引擎 会取出 [[Scopes]] 中的打包的 Closure + Global 链，设置成新的作用域链， 这就是函数用到的所有外部环境了，有了外部环境，自然就可以运行了。 这里思考一个问题： 调试代码的时候为什么遇到过某个变量明明在作用域内能访问到，但就是没有相关信息呢？ 这个 traverse，明明能访问到的，为啥就是不显示信息呢？是 debugger 做的太烂了么？ 不是的，如果你不知道原因，那是因为你还不理解闭包，因为这个 FunctionDeclaration 的函数是一个回调函数，明显是在另一个函数内调用的，就需要在创建的时候打包带走这个环境内的东西，根据只打包必要的环境的原则（不浪费内存），traverse 没有被引用（refer），自然就不打包了。并不是 debugger 有 bug 了。 所以我们只要访问一下，就能在调试的时候访问到了。 是不是突然知道为啥调试的时候不能看一些变量的信息了，能解释清楚这个现象，就算理解闭包了。 eval再来思考一个问题： 闭包需要扫描函数内的标识符，做静态分析，那 eval 怎么办，他有可能内容是从网络记载的，从磁盘读取的等等，内容是动态的。用静态去分析动态是不可能没 bug 的。怎么办？ 没错，eval 确实没法分析外部引用，也就没法打包闭包，这种就特殊处理一下，打包整个作用域就好了。 验证一下： 这个就像上面所说的，会把外部引用的打包成闭包 这个就是 eval 的实现，因为没法静态分析动态内容所以全部打包成闭包了，本来闭包就是为了不保存全部的作用域链的内容，结果 eval 导致全部保存了，所以尽量不要用 eval。会导致闭包保存内容过多。 但是 JS 引擎只处理了直接调用，也就是说直接调用 eval 才会打包整个作用域，如果不直接调用 eval，就没法分析引用，也就没法形成闭包了。 这种特殊情况有的时候还能用来完成一些黑魔法，比如利用不直接调用 eval 不会生成闭包，会在全局上下文执行的特性。 给闭包下个定义用我们刚刚的试验来给闭包下个定义： 闭包是在函数创建的时候，让函数打包带走的根据函数内的外部引用来过滤作用域链剩下的链。它是在函数创建的时候生成的作用域链的子集，是打包的外部环境。evel 因为没法分析内容，所以直接调用会把整个作用域打包（所以尽量不要用 eval，容易在闭包保存过多的无用变量），而不直接调用则没有闭包。 过滤规则： 全局作用域不会被过滤掉，一定包含。所以在何处调用函数都能访问到。 其余作用域会根据是否内部有变量被当前函数所引用而过滤掉一些。不是每个返回的子函数都会生成闭包。 被引用的作用域也会过滤掉没有被引用的 binding （变量声明）。只把用到的变量打个包。 闭包的缺点JavaScript 是静态作用域的设计，闭包是为了解决子函数晚于父函数销毁的问题，我们会在父函数销毁时，把子函数引用到的变量打成 Closure 包放到函数的 [[Scopes]] 上，让它计算父函数销毁了也随时随地能访问外部环境。 这样设计确实解决了问题，但是有没有什么缺点呢？ 其实问题就在于这个 [[Scopes]] 属性上 我们知道 JavaScript 引擎会把内存分为函数调用栈、全局作用域和堆，其中堆用于放一些动态的对象，调用栈每一个栈帧放一个函数的执行上下文，里面有一个 local 变量环境用于放内部声明的一些变量，如果是对象，会在堆上分配空间，然后把引用保存在栈帧的 local 环境中。全局作用域也是一样，只不过一般用于放静态的一些东西，有时候也叫静态域。 每个栈帧的执行上下文包含函数执行需要访问的所有环境，包括 local 环境、作用域链、this等。 那么如果子函数返回了会发生什么呢？ 首先父函数的栈帧会销毁，子函数这个时候其实还没有被调用，所以还是一个堆中的对象，没有对应的栈帧，这时候父函数把作用域链过滤出需要用到的，形成闭包链，设置到子函数的 [[Scopes]] 属性上。 父函数销毁，栈帧对应的内存马上释放，用到的 ssh Obj 会被 gc 回收，而返回的函数会把作用域链过滤出用到的引用形成闭包链放在堆中。 这就导致了一个隐患： 如果一个很大的对象被函数引用，本来函数调用结束就能销毁，但是现在引用却被通过闭包保存到了堆里，而且还一直用不到，那这块堆内存就一直没法使用，严重到一定程度就算是内存泄漏了。所以闭包不要乱用，少打包一点东西到堆内存。 总结我们从静态作用域开始聊起，明确了什么是作用域，通过 babel 静态分析了一下作用域，了解了下静态和动态作用域，然后引入了子函数先于父函数销毁的问题，思考了下方案，然后引入了闭包的概念，分析下闭包生成的流程，保存的位置。我们还用闭包的特性分析了下为什么有时候调试的时候查看不了变量信息，之后分析了下 eval 为什么没法精确生成闭包，什么时候全部打包作用域、什么时候不生成闭包， eval 为什么会导致内存占用过多。之后分析了下带有闭包的函数在内存中的特点，解释了下为啥可能会内存泄漏。 闭包是在返回一个函数的时候，为了把环境保存下载，创建的一个快照，对作用域链做了tree shking，只留下必要的闭包链，保存在堆里，作为对象的 [[scopes]] 属性，让函数不管走到哪，随时随地可访问用到的外部环境。在执行这个函数的时候，会利用这个“快照”，恢复作用域链。 因为还没执行函数，所以要静态分析标识符引用。静态分析动态这件事情被无数个框架证明做不了，所以返回的函数有eval 只能全部打包或者不生成闭包。类似webpack 的动态import没法分析一样。 JavaScript 的静态作用域链与“动态”闭包链 #javascript/closure","link":"/2021/05/26/javascript/JavaScript%E7%9A%84%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%B8%8E%E2%80%9C%E5%8A%A8%E6%80%81%E2%80%9D%E9%97%AD%E5%8C%85%E9%93%BE/"},{"title":"Object.assign是浅拷贝还是深拷贝？实现深拷贝的方法有哪些？","text":"Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。 Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。 String类型和 Symbol 类型的属性都会被拷贝。 在出现错误的情况下，例如，如果属性不可写，会引发TypeError，如果在引发错误之前添加了任何属性，则可以更改target对象。 Object.assign 不会在那些source对象值为 null 或 undefined 的时候抛出错误。 针对 深拷贝 ，需要使用其他办法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。也就是说，如果对象的属性值为简单类型（如string， number），通过Object.assign({},srcObj);得到的新对象为 深拷贝 ；如果属性值为对象或其它引用类型，那对于这个对象而言其实是 浅拷贝 的。 用 JSON.stringify 把对象转换成字符串，再用 JSON.parse 把字符串转换成新的对象。 可以转成 JSON 格式的对象才能使用这种方法，如果对象中包含 function 或 RegExp 这些就不能用这种方法了。 123456//通过js的内置对象JSON来进行数组对象的深拷贝function deepClone(obj) { let _obj = JSON.stringify(obj); let objClone = JSON.parse(_obj); return objClone;} Object.assign()拷贝当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝，但是对象中有对象的时候，此方法，在二级属性以后就是浅拷贝。 通过jQuery的extend方法实现深拷贝1234567891011let $ = require('jquery');let obj1 = { a: 1, b: { f: { g: 1 } }, c: [1, 2, 3]};let obj2 = $.extend(true, {}, obj1); lodash.cloneDeep()实现深拷贝1234567let _ = require('lodash');let obj1 = { a: 1, b: { f: { g: 1 } }, c: [1, 2, 3]};let obj2 = _.cloneDeep(obj1); 使用递归的方式实现深拷贝123456789101112131415161718function _deepClone(source) { let target; if (typeof source === 'object') { target = Array.isArray(source) ? [] : {} for (let key in source) { if (source.hasOwnProperty(key)) { if (typeof source[key] !== 'object') { target[key] = source[key] } else { target[key] = _deepClone(source[key]) } } } } else { target = source } return target} 经典前端面试题: Object.assign 是浅拷贝还是深拷贝？实现深拷贝的方法有哪些？ #javascript","link":"/2021/05/26/javascript/Object.assign%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D%E8%BF%98%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9F%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"},{"title":"nodejs搭建本地服务器展示文件夹","text":"123456789101112131415161718192021222324252627282930313233const express = require('express')const http = require('http')const app = express()const port = 80var serveIndex = require('serve-index')app.use(express.static('../'))app.use(serveIndex('../'))function getIPAdress() { let interfaces = require('os').networkInterfaces() for (var devName in interfaces) { var iface = interfaces[devName] for (var i = 0; i &lt; iface.length; i++) { let alias = iface[i] if ( alias.family === 'IPv4' &amp;&amp; alias.address !== '127.0.0.1' &amp;&amp; !alias.internal ) { // console.log(alias.address); return alias.address } } }}var server = http.createServer(app)server.listen(port, () =&gt; { console.log(`Example app listening at http://${getIPAdress()}:${port}`)}) #javascript/nodejs","link":"/2021/05/26/javascript/nodejs%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B1%95%E7%A4%BA%E6%96%87%E4%BB%B6%E5%A4%B9/"},{"title":"偏函数","text":"偏函数是 [[函数柯里化]] 运算的一种特定应用场景。简单描述，就是把一个函数的某些参数先固化，也就是设置默认值，返回一个新的函数，在新函数中继续接收剩余参数，这样调用这个新函数会更简单。 下面是一个类型检测函数，接收两个参数，第 1 个表示类型字符串，第 2 个表示检测的数据。 123var isType = function (type, obj) { //偏函数 return Object.prototype.toString.call(obj) == '[object ' + type + ']';} 该函数包含两个设置参数，使用时比较繁琐。一般常按以下方式进行设计。 123456var isString = function (obj) { return Object.prototype.toString.call(obj) == '[object String]';};var isFunction = function (obj) { return Object.prototype.toString.call(obj) == '[object Function]';}; 函数接收的参数单一，检测的功能也单一和明确，这样更便于在表达式运算中有针对性的调用。下面对 isType() 函数进行扁平化设计，代码如下： 12345var isType = function (type) { return function (obj) { return Object.prototype.toString.call(obj) == '[object ' + type + ']'; }} 然后根据 JS 偏函数获取不同类型检测函数。 12var isString = isType(&quot;String&quot;); //专一功能检测函数，检测字符串var isFunction = isType(&quot;Function&quot;); //专一功能检测函数，检测字符串 应用代码如下： 123console.log(isString(&quot;12&quot;)); //trueconsole.log(isFunction(function () {})); //trueconsole.log(isFunction({})); //false 下面示例设计一个 wrap() 偏函数，该函数的主要功能是产生一个 HTML 包裹函数，即样式标签。 12345678910111213function wrap(tag) { var stag = '&lt;' + tag + '&gt;'; var etag = '&lt;/' + tag.replace(/s.*/, '') + '&gt;'; return function(x) { return stag + x + etag; }}var b = wrap('b');document.write(b('粗体字'));var i = wrap('i');document.write(i('斜体字'));var u = wrap('u');document.write(u('下划线字')); #javascript","link":"/2021/05/26/javascript/%E5%81%8F%E5%87%BD%E6%95%B0/"},{"title":"函数柯里化","text":"柯里化 - 维基百科，自由的百科全书把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。 柯里化有3个常见作用： 参数复用 提前确定 延迟计算/运行 基本实现12345var foo = function(a) { return function(b) { return a * a + b * b; }} 调用上述函数：(foo(3))(4)，或直接foo(3)(4) 参数复用1234567891011121314151617181920212223// 正常正则验证字符串 reg.test(txt)// 函数封装后function check(reg, txt) { return reg.test(txt)}check(/\\d+/g, 'test') //falsecheck(/[a-z]+/g, 'test') //true// Currying后function curryingCheck(reg) { return function(txt) { return reg.test(txt) }}var hasNumber = curryingCheck(/\\d+/g)var hasLetter = curryingCheck(/[a-z]+/g)hasNumber('test1') // truehasNumber('testtest') // falsehasLetter('21212') // false 上面的示例是一个正则的校验，正常来说直接调用check函数就可以了，但是如果我有很多地方都要校验是否有数字，其实就是需要将第一个参数reg进行复用，这样别的地方就能够直接调用hasNumber，hasLetter等函数，让参数能够复用，调用起来也更方便。 提前确定1234567891011function makeMap(str) { var map = Object.create(null); var list = str.split(&quot;,&quot;); for (var i = 0; i &lt; list.length; i++) { map[list[i]] = true; } return function (val) { return map[val.toLowerCase()]; };} 12345678910111213var isHTMLTag = makeMap( 'html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot' ); 这是vue源码中的一个方法，用这个方法来判断当前自定义标签跟html，这里就用了提前确认， 先将所有的标签都存入一个对象，然后每次查找只需要匹配对象里面是否存在该标签，这样就能防止多次循环遍历查找对应的标签 1isHTMLTag('div') 延迟执行12345678910111213141516const curryAdd = function(...rest) { const _args = rest return function cb(...rest) { if (rest.length === 0) { return _args.reduce((sum, single) =&gt; sum += single) } else { _args.push(...rest) return cb } }}() // 为了保存添加的数，这里要返回一个闭包curryAdd(1)curryAdd(2)curryAdd(3)curryAdd(4)curryAdd() // 最后计算输出:10 经典面试题12345678910111213141516171819202122232425262728// 实现一个add方法，使计算结果能够满足如下预期：add(1)(2)(3) = 6;add(1, 2, 3)(4) = 10;add(1)(2)(3)(4)(5) = 15;function add() { // 第一次执行时，定义一个数组专门用来存储所有的参数 var _args = Array.prototype.slice.call(arguments); // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值 var _adder = function() { _args.push(...arguments); return _adder; }; // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回 _adder.toString = function () { return _args.reduce(function (a, b) { return a + b; }); } return _adder;}add(1)(2)(3) // 6add(1, 2, 3)(4) // 10add(1)(2)(3)(4)(5) // 15add(2, 6)(1) // 9 #javascript","link":"/2021/05/26/javascript/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"},{"title":"揭开在线协作的神秘面纱–OT算法","text":"相信大家或多或少都有使用过在线文档，国内的像我们在做的 腾讯文档 还有其他家的很多类似产品。今天主要为大家揭开在线协作的神秘面纱，那就是 OT 算法。 背景在线文档，抽象一下，这些产品的模式都是富文本编辑器+后台，富文本编辑器产生内容，展示内容，然后后台负责保存。富文本编辑器现在业界已经有很多成熟的产品，像 codeMirror ，这一块本身也是很复杂的一块，也不是咱们这次关注的重点方向。不知道大家平常在用这些产品的时候有没有思考过一个问题，在线文档编辑的时候产生冲突怎么办？ 举个栗子举个很简单的例子，现在大家的文本都是 ‘aaab’，A 用户在第 3 个字符行后面插入了一个 ‘c’，B 用户在第 3 个字符行后面插入了一个 ‘d’，这个时候 A 这边看到的是 ‘aaacb’，B 这边看到的是 ‘aaadb’, 我们假设 A 用户先提交了数据，那其实最后预期的数据其实应该是 ‘aaacdb’，这样就最大的保存了每个人的输入。 那我们现在来看看正常情况下这里会发生什么： A 用户： A 本地已经是 ‘aaacb’ 了，过一会儿，后台告诉它 B 也编辑了，编辑的行为就是 第 3 个字符行后面插入了一个 ‘d’ ，那 A 这边执行了这个行为，最终变成了 ‘aaadcb’ B 用户： B 本地已经是 ‘aaadb’ 了，过一会儿，后台告诉它 A 也编辑了，编辑的行为就是 第 3 个字符行后面插入了一个 ‘c’ ，那 B 这边执行了这个行为，最终变成了 ‘aaacdb’ 从上面的模拟过程可以看到，A 用户最后的结果其实是不正确的，但是 B 是正确的。 这里先解释一下大家可能会疑惑的地方：为什么 B 是过一会儿后台告诉它 A 编辑了，不是说 A 先提交了数据吗？其实这里针对的是冲突场景，这里如果 B 在提交之前，已经收到后台告诉它 A 编辑了，那其实就是顺序编辑了，也就不是冲突了。所以这里指的是 A，B 几乎同时提交，但是 A 到达后台还是快一点的，也就是 A，B 在编辑的时候是不知道彼此的存在的。 真实的冲突场景其实不是这种简单的时序问题，这里我后面再介绍。 尝试解决这里可能有一些聪明的小伙伴有了一些想法。 解决方案一：丢了丢了这可能是最简单粗暴的方法了，我发现有冲突，就告诉用户，主子，咱这里有冲突了，臣妾解决不了啊。但是显然这会经常出现，然后主子就把你打入冷宫了。 解决方案二：锁有些小伙伴想到，上面出现问题，还不是因为大家编辑了都立即应用了，我们编辑后不立即应用不就好了，而且历史告诉我们，有冲突加锁应该可以解决。那我们看看假如不立即应用，咱有没有什么处理办法： A 用户： A 本地已经是 ‘aaab’ 了，A 编辑了，但是不应用，先发后台 B 用户： B 本地已经是 ‘aaab’ 了，B 编辑了，但是不应用，先发后台 后台： 后台先收到 A 请求，然后加了一个锁，然后收到了 B 请求，这时侯应该是加锁的状态，所以接受了 A，拒绝了 B A 用户： A 用户收到了后台的回复，告诉它你的提交我接收了 B 用户： B 用户收到了后台的回复，告诉它你的提交被我拒绝了，因为冲突了 这样虽然能继续下去，但是好像还是不太行的亚子啊，B 的提交还是丢了，所以好像和第一种简单粗暴的方法没啥区别 OT 算法顺其自然的，这个时候你会看到 OT 算法驾着七彩祥云来救你了～其实回到上面的例子，本质问题还是因为后台通知大家的 B 的编辑行为看起来不太对。现在后台通知大家的是: B 的编辑的行为就是 第 3 个字符行后面插入了一个 ‘d’ 但是在 A 已经接受的情况下，正确的通知应该是： B 的编辑的行为就是 第 4 个字符行后面插入了一个 ‘d’ 假如我们把 A 提交的行为叫做 A，B 提交的行为叫做 B，现在后台就是一个简单的转发功能，告诉 A 的是 B，告诉 B 的是 A，然后就出现问题了。所以后台应该更聪明一点，它应该学会一个招术，那就是把每个人提交的行为转变一下再告诉别人，其实这个技术就是 OT 算法。 OT 算法全名叫 Operation Transformation ，你看从名字就对应了上面我说的转变算法。 假设我们的 OT 算法的转换功能叫 transform，那 transform（A，B）= A’,B’。 也就是说你输入两个先后执行的行为，它会告诉你两个转换过后的行为，然后把 A’行为告诉 B，把 B’行为告诉 A，这样大家再应用就相安无事了。 上面的图是 OT 的经典菱形图，也就是说 A 会变成 A’在 B 这边执行，B 会变成 B’在 A 这边执行。 这里实际抽象一下，用户永远就只有两个人，一个是自己，一个是服务端，只是服务端的操作可能来自很多人，如果不这样抽象，那一个个进行冲突处理可能会让你觉得无法理解。 那我们现在再来看看后台有了 OT 这个能力之后会发生什么： A 用户： A 本地已经是 ‘aaacb’ 了，过一会儿，后台告诉它 B 也编辑了，编辑的行为就是 第 4 个字符行后面插入了一个 ‘d’ ，那 A 这边执行了这个行为，最终变成了 ‘aaacdb’ B 用户： B 本地已经是 ‘aaadb’ 了，过一会儿，后台告诉它 A 也编辑了，编辑的行为就是 第 3 个字符行后面插入了一个 ‘c’ ，那 B 这边执行了这个行为，最终变成了 ‘aaacdb’ 现在 A、B 就一致了！ OT 算法的实现现在 OT 算法对我们来说就是一个黑盒，我们知道给一定的输入，它会有正确的输出，但是它是如何做到的呢？在介绍它的实现之前，我们需要抽象一下我们的操作行为，在之前我们的描述都是 第 3 个字符行后面插入了一个 ‘d’ 这里怎么转换成程序识别或者能用代码表达的呢？其实这也是 OT 的关键。 这里我直接揭晓答案： 所有对文本的操作都可以抽象成三个原子行为： R = Retain，保持操作 I = Insert，插入操作 D = Delete，删除操作 那之前的行为 第 3 个字符行后面插入了一个 ‘d’ 就会变成 R(3), I(‘d’) 也就是保持三个字符后插入 1 个 ‘d’，其实应该也很好理解，这里的操作就像操作数组一样，不管干什么，第一步你得先找到操作的下标。有了这三个原子以后，我们就可以看到： A = R(3),I(‘c’)B = R(3), I(‘d’) 一切准备就绪，我们可以开始看 OT 了，这里 OT 算法现在已经很成熟了，这里我以一个 github 上的 repo 为例： ot.js我们可以看看它的核心代码 (有删减，理解起来可能会比较复杂，感兴趣的可以深入思考一下)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Transform takes two operations A and B that happened concurrently and // produces two operations A' and B' (in an array) such that // `apply(apply(S, A), B') = apply(apply(S, B), A')`. This function is the // heart of OT. // 上面这个公式就是OT的核心，它产生了A',B',同时保证执行结果一致，S就是我们开始的状态，可以把这个和菱形图对应起来 // 整体执行流程有点像合并排序的过程。两个下标指针分别往前走 TextOperation.transform = function (operation1, operation2) { // operation1， operation2就是我们的A，B var operation1prime = new TextOperation(); // 就是A' var operation2prime = new TextOperation(); // 就是B' var ops1 = operation1.ops, ops2 = operation2.ops; var i1 = 0, i2 = 0; var op1 = ops1[i1++], op2 = ops2[i2++]; while (true) { // At every iteration of the loop, the imaginary cursor that both // operation1 and operation2 have that operates on the input string must // have the same position in the input string. // 其实这里就是说transform的核心是保证两者的下标一致，这样操作的才是同一个位置的数据 // ... // next two cases: one or both ops are insert ops // =&gt; insert the string in the corresponding prime operation, skip it in // the other one. If both op1 and op2 are insert ops, prefer op1. // 如果A是插入操作，A'一定也是插入，但是B'就不一样了，因为A是插入，不管你B是啥，你先等等，所以retain一下，保证下标一致 // 这里实际上有三种情况，A是插入，B可能是R，I，D if (isInsert(op1)) { operation1prime.insert(op1); operation2prime.retain(op1.length); op1 = ops1[i1++]; continue; } // 如果B也是插入，那B’就是插入，但是你的A'也得retain一下，保证下标一致 // 这里可能有两者情况，A可能是R，D // 实例化思考一下，A [R(3),I('a')],B [I('b')],那对于A'来说就应该是[R(4),I('a')] if (isInsert(op2)) { operation1prime.retain(op2.length); operation2prime.insert(op2); op2 = ops2[i2++]; continue; } // ... var minl; if (isRetain(op1) &amp;&amp; isRetain(op2)) { // R和R处理 } else if (isDelete(op1) &amp;&amp; isDelete(op2)) { //D和D处理 } else if (isDelete(op1) &amp;&amp; isRetain(op2)) { // D和R处理 } else if (isRetain(op1) &amp;&amp; isDelete(op2)) { //R和D处理 } } return [operation1prime, operation2prime]; }; 这里就是 OT 的 transform 实现，本质上就是把用户的原子操作数组拿到以后，然后做 transform 操作，这里我只选了一小段来大概解析下，具体的可以看注释，其实原本的注释已经很全了。 其实上面那段代码，因为我们的原子操作只有三种，根据排列组合，最多只会有 9 种情况，只是上面把很多情况合并了，你要是不理解，也可以拆开，帮助理解。 其实上面的文件还有 compose，invert 等方法，但是其实 transform 才是我们理解的核心，其他方法大家感兴趣可以看看注释和下面贴的一些关于 OT 更详细介绍的文章。 OT 算法的时序简单的 OT 大家只要理解了，好像也并不是很难，但是其实真实情况下 OT 会比想象的还要复杂，因为之前说的菱形会无限拓展。 简单理解一下，就是 A 本地产生了两次编辑，B 产生了一次。这里就必须要和大家解释一下之前遗留的时序问题了，不然可能无法理解。 之前说的时序都是指时间先后顺序，冲突也是指同时产生编辑。但是其实这里的同时不是时间上的同时，而是 版本上的同时 。 也就是说我们需要用一个东西表示每一个版本，类似 git 的每次提交，每次提交到服务端的时候就要告诉后端，我的修改是基于哪个版本的修改。 最简单的标志位就是 递增的数字 。那基于版本的冲突，可以简单理解为我们都是基于 100 版本的提交，那就是冲突了，也许我们并不是同时， 谁先到后台决定了谁先被接受而已 。这里最夸张的就是离线编辑，可能正常版本已经到了 1000 了，某个用户因为离线了，本地的版本一直停留在 100，提交上来的版本是基于 100 的。 那有了时序的概念，我们再看上面这个菱形，它可以理解成 A 和 B 都基于 100 提交了数据，但是在 A 的提交还没被后台确认的时候，A 又编辑了，但是因为上一次提交没被确认，所以这次不会发到后台，这时服务器告诉它 B 基于 100 做了提交。 这种情况下如何处理，就有点类似于 OT 落地到实践当中，你怎么实现了，上面提到的 github 的那个 repo 的实现其实非常巧妙，你看完注释应该就能全部理解，这里给出 代码链接 精华就在于它把本地分成了几个状态： Synchronized 没有正在提交并且等待回包的 operation AwaitingConfirm 有一个 operation 提交了但是等后台确认，本地没有编辑数据 AwaitingWithBuffer 有一个 operation 提交了但是等后台确认，本地有编辑数据 剩下的就是在这三种状态下，收到了本地和服务端的数据，分别应该怎么处理 结语其实 OT 对应的只是一种思想，具体怎么实现是根据具体情况来区分的，比如我们现在讨论的就是文本的 OT，那有可能图的 OT、表格的 OT 又是其他的实现。OT 的核心就是 transform，而 transform 的核心就在于你怎么找到这样的原子操作了，然后原子操作的复杂度决定了 transform 实现的复杂度。 上面这个 repo 只是帮你实现了文本的协同处理，其实对于在线文档来说，还有样式的冲突处理，感兴趣的可以自己搜索相关资料了解一下，建议精读一下 ot.js 这个库。 最后如果读完这篇文章你对在线协作有了一定的认知，那这篇文章的使命也就达到了，最后如果有写的不正确的地方，欢迎斧正～ 参考资料understanding-and-applying-operational-transformationot.js 揭开在线协作的神秘面纱 – OT 算法 #javascript","link":"/2021/05/26/javascript/%E6%8F%AD%E5%BC%80%E5%9C%A8%E7%BA%BF%E5%8D%8F%E4%BD%9C%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%E2%80%93OT%E7%AE%97%E6%B3%95/"},{"title":"编写JavaScript的10个小技巧","text":"简化条件表达式经常碰到这种情况，要判断某个变量是否为指定的某些值，用常规的逻辑表达式会很长。我的做法是把这些值放进数组里： 12345678// 太长的逻辑表达式if (x === 'abc' || x === 'def' || x === 'ghi' || x ==='jkl') { //其他逻辑}// 简写if (['abc', 'def', 'ghi', 'jkl'].includes(x)) { //其他逻辑} 简化 if … elseif…else太常用了，以至于很多人都忘了其实还有其他方式来判断条件。比如简单的变量赋值，完全没必要用这种冗长的语句，一行表达式就搞定了： 123456789101112// 新手的写法let test= boolean;if (x &gt; 100) { test = true;} else { test = false;}// 简写表达式let test = (x &gt; 10) ? true : false;// 更直接的let test = x &gt; 10;console.log(test); 三元表达式可以做复杂的条件分支判断，不过牺牲了一些可读性： 123let x = 300,let test2 = (x &gt; 100) ? 'greater 100' : (x &lt; 50) ? 'less 50' : 'between 50 and 100';console.log(test2); // &quot;greater than 100&quot; 判空并赋默认值Code Review 的时候我经常看到这样的代码，判断变量不是null，undefined，’’的时候赋值给第二个变量，否则给个默认值： 12345if (first !== null || first !== undefined || first !== '') { let second = first;}// 简写let second = first || ''; 简写循环遍历for 循环是最基本的，但是有点繁琐。可以用 for…in、for…of 或者 forEach 代替： 12345// Longhandfor (var i = 0; i &lt; testData.length; i++)// Shorthandfor (let i in testData) or for (let i of testData) 数组遍历： 123456function testData(element, index, array) { console.log('test[' + index + '] = ' + element);}[11, 24, 32].forEach(testData);// 打印输出: test[0] = 11, test[1] = 24, test[2] = 32 简化 switch这个技巧也很常用，把switch 转换成对象的key-value形式，代码简洁多了： 123456789101112131415161718192021222324// Longhandswitch (data) { case 1: test1(); break; case 2: test2(); break; case 3: test(); break; // And so on...}// Shorthandvar data = { 1: test1, 2: test2, 3: test};data[anything] &amp;&amp; data[anything](); 简化多行字符串拼接如果一个字符串表达式过长，我们可能会拆成多行拼接的方式。不过随着 ES6 的普及，更好的做法是用模板字符串： 123456//longhandconst data = 'abc abc abc abc abc abc\\n\\t' + 'test test,test test test test\\n\\t'//shorthandconst data = `abc abc abc abc abc abc test test,test test test test` 善用箭头函数简化 returnES6 的箭头函数真是个好东西，当函数简单到只需要返回一个表达式时，用箭头函数最合适不过了，return都不用写： 123456789Longhand://longhandfunction getArea(diameter) { return Math.PI * diameter}//shorthandgetArea = diameter =&gt; ( Math.PI * diameter;) 简化分支条件语句又是你，if…else if…else！跟 switch类似，也可以用key-value形式简化： 12345678910111213141516171819202122232425// Longhandif (type === 'test1') { test1();}else if (type === 'test2') { test2();}else if (type === 'test3') { test3();}else if (type === 'test4') { test4();} else { throw new Error('Invalid value ' + type);}// Shorthandvar types = { test1: test1, test2: test2, test3: test3, test4: test4};var func = types[type];(!func) &amp;&amp; throw new Error('Invalid value ' + type); func(); 重复字符串 N 次有时候出于某种目的需要将字符串重复 N 次，最笨的方法就是用for循环拼接。其实更简单的方法是用repeat： 12345678//longhand let test = ''; for(let i = 0; i &lt; 5; i ++) { test += 'test '; } console.log(str); // test test test test test //shorthand 'test '.repeat(5); 指数运算能省则省，低碳环保。 1234//longhandMath.pow(2,3); // 8//shorthand2**3 // 8 数字分隔符这是比较新的语法，ES2021 提出来的，数字字面量可以用下划线分割，提高了大数字的可读性： 1234// 旧语法let number = 98234567// 新语法let number = 98_234_567 #javascript","link":"/2021/05/26/javascript/%E7%BC%96%E5%86%99JavaScript%E7%9A%8410%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"title":"高阶函数","text":"JavaScript的函数可以指向某个变量，变量也可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 简单的高阶函数123456789101112function add(x, y, f) { return f(x) + f(y);}//当调用add(-5, 6, Math.abs)时，参数x，y和f分别接收-5，6和函数Math.abs，根据函数定义，可以推导计算过程为：//x = -5;//y = 6;//f = Math.abs;//f(x) + f(y) ==&gt; Math.abs(-5) + Math.abs(6) ==&gt; 11;//return 11;//用代码验证一下：add(-5, 6, Math.abs); // 11 常用的高阶函数map1234567891011121314151617181920function pow(x) { return x * x;}var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]//map()传入的参数是pow，即函数对象本身。//不需要map()，写一个循环，也可以计算出结果：var f = function (x) { return x * x;};var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var result = [];for (var i=0; i&lt;arr.length; i++) { result.push(f(arr[i]));}//的确可以，但是，从上面的循环代码，我们无法一眼看明白“把f(x)作用在Array的每一个元素并把结果生成一个新的Array”。 所以，map() 作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的 f(x)=x2，还可以计算任意复杂的函数，比如，把 Array 的所有数字转为字符串： 123var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9']//只需要一行代码。 reduce再看 reduce 的用法。Array 的 reduce() 把一个函数作用在这个 Array 的 [x1, x2, x3…] 上，这个函数必须接收两个参数，reduce() 把结果继续和序列的下一个元素做累积计算，其效果就是： 1234567[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)//比方说对一个Array求和，就可以用reduce实现：var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) { return x + y;}); // 25 filterfilter 也是一个常用的操作，它用于把 Array 的某些元素过滤掉，然后返回剩下的元素。和 map() 类似，Array 的 filter() 也接收一个函数。和 map() 不同的是，filter() 把传入的函数依次作用于每个元素，然后根据返回值是 true 还是 false 决定保留还是丢弃该元素。 12345678910111213//例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：var arr = [1, 2, 4, 5, 6, 9, 10, 15];var r = arr.filter(function (x) { return x % 2 !== 0;});r; // [1, 5, 9, 15]//把一个Array中的空字符串删掉，可以这么写：var arr = ['A', '', 'B', null, undefined, 'C', ' '];var r = arr.filter(function (s) { return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法});arr; // ['A', 'B', 'C'] 回调函数：filter() 接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示 Array 的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身： 123456789101112131415161718var arr = ['A', 'B', 'C'];var r = arr.filter(function (element, index, self) { console.log(element); // 依次打印'A', 'B', 'C' console.log(index); // 依次打印0, 1, 2 console.log(self); // self就是变量arr return true;});//利用filter，可以巧妙地去除Array的重复元素：'use strict';var r, arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];r = arr.filter(function (element, index, self) { return self.indexOf(element) === index;});alert(r.toString());//去除重复元素依靠的是indexOf总是返回第一个元素的位置，后续的重复元素位置与indexOf返回的位置不相等，因此被filter滤掉了。 sort因为 Array 的 sort()方法默认把所有元素先转换为String再排序，结果’10’排在了’2’的前面，因为字符’1’比字符’2’的ASCII码小。如果不知道 sort() 方法的默认排序规则，直接对数字排序，绝对栽进坑里！ 幸运的是，sort() 方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//要按数字大小排序，我们可以这么写：var arr = [10, 20, 1, 2];arr.sort(function (x, y) { if (x &lt; y) { return -1; } if (x &gt; y) { return 1; } return 0;}); // [1, 2, 10, 20]//如果要倒序排序，我们可以把大的数放前面：var arr = [10, 20, 1, 2];arr.sort(function (x, y) { if (x &lt; y) { return 1; } if (x &gt; y) { return -1; } return 0;}); // [20, 10, 2, 1]//默认情况下，对字符串排序，是按照ASCII的大小比较的，现在，排序应该忽略大小写，按照字母序排序。//要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：var arr = ['Google', 'apple', 'Microsoft'];arr.sort(function (s1, s2) { x1 = s1.toUpperCase(); x2 = s2.toUpperCase(); if (x1 &lt; x2) { return -1; } if (x1 &gt; x2) { return 1; } return 0;}); // ['apple', 'Google', 'Microsoft']//忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。//sort()方法会直接对Array进行修改，它返回的结果仍是当前Array：var a1 = ['B', 'A', 'C'];var a2 = a1.sort();a1; // ['A', 'B', 'C']a2; // ['A', 'B', 'C']a1 === a2; // true, a1和a2是同一对象 #javascript","link":"/2021/05/26/javascript/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"title":"Mac设置环境变量path的几种方法","text":"Mac系统的环境变量，加载顺序为： 系统 /etc/profile /etc/paths /etc/profile 和 /etc/paths 是系统级别的，系统启动就会加载 用户 ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc 按照从前往后的顺序读取，如果 ~/.bash_profile 文件存在，则后面的几个文件就会被忽略不读了，如果 ~/.bash_profile 文件不存在，才会以此类推读取后面的文件。~/.bashrc 没有上述规则，它是 bash shell 打开的时候载入的 如果没特殊说明,设置PATH的语法都为： 1export PATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:------:&lt;PATH N&gt; 全局设置下面的几个文件设置是全局的，修改时需要root权限 /etc/paths （全局建议修改这个文件 ）编辑 paths，将环境变量添加到 paths 文件中 ，一行一个路径Hint：输入环境变量时，不用一个一个地输入，只要拖动文件夹到 Terminal 里就可以了。 /etc/profile （建议不修改这个文件 ）全局（公有）配置，不管是哪个用户，登录时都会读取该文件。 /etc/bashrc （一般在这个文件中添加系统级环境变量）全局（公有）配置，bash shell 执行时，不管是何种方式，都会读取此文件。 创建一个文件：1sudo touch /etc/paths.d/mysql 用 vim 打开这个文件（如果是以 open -t 的方式打开，则不允许编辑）：1sudo vim /etc/paths.d/mysql 编辑该文件，键入路径并保存（关闭该 Terminal 窗口并重新打开一个，就能使用 mysql 命令了）1/usr/local/mysql/bin 据说，这样可以自己生成新的文件，不用把变量全都放到 paths 一个文件里，方便管理。 单个用户设置 ~/.bash_profile （任意一个文件中添加用户级环境变量）（注：Linux 里面是 .bashrc 而 Mac 是 .bash_profile）若bash shell是以login方式执行时，才会读取此文件。该文件仅仅执行一次!默认情况下,他设置一些环境变量设置命令别名alias ll=’ls -la’ 设置环境变量： 1export PATH=/opt/local/bin:/opt/local/sbin:$PATH ~/.bashrc 同上 如果想立刻生效，则可执行下面的语句： 1$ source 相应的文件 一般环境变量更改后，重启后生效。 #other","link":"/2021/05/26/other/Mac%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fpath%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"ios提醒事项同步日历快捷指令脚本","text":"AppStore 安装运行脚本的软件 scriptable scriptable https://docs.scriptable.app 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115const DUR_MONTH = 1const startDate = new Date()startDate.setMonth(startDate.getMonth() - DUR_MONTH)console.log(`日历的开始时间 ${startDate.toLocaleDateString()}`)const endDate = new Date()endDate.setMonth(endDate.getMonth() + DUR_MONTH)console.log(`日历的结束时间 ${endDate.toLocaleDateString()}`)const reminders = await Reminder.allDueBetween(startDate, endDate)console.log(`获取 ${reminders.length} 条提醒事项`)var calendar = await Calendar.forEvents()//获取日历名和对应的日历var m_dict = {}for (cal of calendar) { m_dict[cal.title] = cal}const events = await CalendarEvent.between(startDate, endDate, calendar)console.log(`获取 ${events.length} 条日历`)for (const reminder of reminders) { //reminder的标识符 const id = reminder.identifier.split('-')[0] const targetNote = `🍧 ${id} 🍰` // 添加标识符存进备注 用来防止重复添加 const [targetEvent] = events.filter( (e) =&gt; e.notes != null &amp;&amp; e.notes.indexOf(targetNote) != -1 ) //过滤重复的reminder if (!m_dict[reminder.calendar.title]) { console.warn('找不到日历' + reminder.calendar.title) continue } if (targetEvent) { //console.log(`找到已经创建的事项 ${reminder.title}`) updateEvent(targetEvent, reminder) } else { console.warn(`创建事项 ${reminder.title} 到 ${reminder.calendar.title}`) const newEvent = new CalendarEvent() const notes = reminder.notes ? reminder.notes : '' newEvent.notes = targetNote + '\\n\\n' + notes //要加入备注 updateEvent(newEvent, reminder) }}Script.complete()function updateEvent(event, reminder) { event.title = `${reminder.title}` cal_name = reminder.calendar.title cal = m_dict[cal_name] event.calendar = cal //已完成事项 if (reminder.isCompleted) { event.title = `✅ ${reminder.title}` event.isAllDay = false event.startDate = reminder.completionDate var ending = new Date(reminder.completionDate) ending.setHours(ending.getHours() + 1) event.endDate = ending var period = (reminder.dueDate - reminder.completionDate) / 1000 / 3600 / 24 period = period.toFixed(1) if (period &lt; 0) { period = -period event.location = ' 延期' + period + '天完成' } else if (period == 0) { event.location = ' 准时完成' } else { event.location = ' 提前' + period + '天完成' } } //未完成事项 else { const nowtime = new Date() var period = (reminder.dueDate - nowtime) / 1000 / 3600 / 24 period = period.toFixed(1) if (period &lt; 0) { //待办顺延 event.location = ' 延期' + -period + '天' //如果不是在同一天,设置为全天事项 if (reminder.dueDate.getDate() != nowtime.getDate()) { event.title = `❌ ${reminder.title}` event.startDate = nowtime event.endDate = nowtime event.isAllDay = true } //在同一天的保持原来的时间 else { event.title = `⭕️ ${reminder.title}` event.isAllDay = false event.startDate = reminder.dueDate var ending = new Date(reminder.dueDate) ending.setHours(ending.getHours() + 1) event.endDate = ending } console.log(`【${reminder.title}】待办顺延${-period}天`) } else { event.title = `⭕️ ${reminder.title}` event.isAllDay = false event.location = '还剩' + period + '天' event.startDate = reminder.dueDate var ending = new Date(reminder.dueDate) ending.setHours(ending.getHours() + 1) event.endDate = ending } } event.save()} 提醒事项数据格式 12345678910111213141516171819202122232425{ &quot;identifier&quot;: &quot;29803A1E-6C2F-454D-B366-2C67EB1F24BD&quot;, &quot;title&quot;: &quot;Recite word&quot;, &quot;isCompleted&quot;: false, &quot;isOverdue&quot;: true, &quot;priority&quot;: 0, &quot;dueDate&quot;: &quot;2021-03-11T23:20:00.000Z&quot;, &quot;dueDateIncludesTime&quot;: true, &quot;completionDate&quot;: null, &quot;creationDate&quot;: &quot;2021-03-12T03:28:00.621Z&quot;, &quot;calendar&quot;: { &quot;identifier&quot;: &quot;282088E0-DC16-4827-BA21-9B9FD5F0A16F&quot;, &quot;title&quot;: &quot;Learn&quot;, &quot;isSubscribed&quot;: false, &quot;allowsContentModifications&quot;: true, &quot;color&quot;: { &quot;hex&quot;: &quot;FF2968&quot;, &quot;red&quot;: 1, &quot;green&quot;: 0.1607843041419983, &quot;blue&quot;: 0.40784314274787903, &quot;alpha&quot;: 1 } }} ios 提醒事项同步日历快捷指令脚本 #other","link":"/2021/05/26/other/ios%E6%8F%90%E9%86%92%E4%BA%8B%E9%A1%B9%E5%90%8C%E6%AD%A5%E6%97%A5%E5%8E%86%E5%BF%AB%E6%8D%B7%E6%8C%87%E4%BB%A4%E8%84%9A%E6%9C%AC/"},{"title":"你是哪种程序员？","text":"1.对待需求的态度 优秀程序员 ：在有需求与任务时，会不断的询问需求与任务，并且多次确认想要的结果，再动手写代码。 一般程序员 ：接到任务就闷头写代码，反正做错了也是你们要求的，不是我的锅。 2.编码习惯 优秀程序员 ：他的代码读起来是赏心悦目的，若遇到难理解的实现点时，他也会写下清晰的注释来帮助后来人理解。 一般程序员 ：我有我的代码风格，我看得懂就行了。几个月后我也看不懂了，那就重写一遍吧。 3. 善于学习 优秀程序员 ：遇到没接触过的技术时，他会主动搜索资料去学习钻研，并以此为乐趣。 一般程序员 ：疯狂地找插件，类库和框架，常常做代码搬运工，安慰自己不要造轮子。 4. 对工作精益求精 优秀程序员 ：会抽时间review自己的代码，并思考如何提高性能。 一般程序员 ：只喜欢开发新项目，不喜欢维护旧项目，万一搞崩了呢？ 5. 有钻研精神 优秀程序员 ：遇到问题，会考虑独立寻求解决办法，提升自己处理问题的能力。 一般程序员 ：喜欢把问题交给别人，把代码发给被人，让别人帮他找问题。 6. 良好的情绪管理 优秀程序员 ：理解需求是会不断变化的，不会把消极情绪表达出来，能控制好情绪，能跟产品经理和谐愉快沟通。 一般程序员 ：因为需求反复修改就索性说这个代码实现不了。 7. 态度很谦虚 优秀程序员 ：对新的技术敏感度，保持学习的热情，而且为人很谦虚，不觉得自己有多牛。 一般程序员 ：生怕别人不觉得他是大牛，到处瞎逼逼。 #other","link":"/2021/05/26/other/%E4%BD%A0%E6%98%AF%E5%93%AA%E7%A7%8D%E7%A8%8B%E5%BA%8F%E5%91%98%EF%BC%9F/"},{"title":"占位图","text":"写页面的有时候需要一些临时的占位符图片，下面是常用的几种免费占位图片网站 picsum.photos (https://picsum.photos/)支持https, 而且图片特别多, 随机图片, 模糊图片, 宽高, 唯一的缺点就是感觉请求有点慢 图片地址 说明 https://picsum.photos/list 查看所有图片 https://picsum.photos/200 正方形图片 只想要一个值 https://picsum.photos/200/300 设置宽高 https://picsum.photos/500/300/?random 随机获取图片 https://picsum.photos/id/0/200/300 指定特定图片 https://picsum.photos/g/200/300 将图片变成灰色 只需要加一个 /g/ https://picsum.photos/200/300/?blur 模糊图片 1![](/images/?random~) fakeimg.pl(https://fakeimg.pl)如果你只需要使用文字，这个就特别好用了， 支持背景颜色，文字颜色，文字样式， 他的访问速度还很快 图片地址 说明 https://fakeimg.pl/400x300 设置宽高 https://fakeimg.pl/400x300/ba8f6c/FFFFFF/ 设置背景颜色 字体颜色 https://fakeimg.pl/400x300/ba8f6c/FFFFFF/?text=text 设置显示的文字 https://fakeimg.pl/400x300/ba8f6c/FFFFFF/?text=RegExp&amp;font=noto 设置字体样式 font=lobster 1![](/images/?text=糖小米&amp;font=noto~) #other","link":"/2021/05/26/other/%E5%8D%A0%E4%BD%8D%E5%9B%BE/"},{"title":"iframe报错Refusedtodisplay&#39;URL&#39;inaframebecauseitset&#39;X-Frame-Options&#39;to&#39;DENY&#39;","text":"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options X-Frame-Options 有三个值: DENY表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。 SAMEORIGIN表示该页面可以在相同域名页面的 frame 中展示。 ALLOW-FROM uri表示该页面可以在指定来源的 frame 中展示。 换一句话说，如果设置为 DENY，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载。另一方面，如果设置为 SAMEORIGIN，那么页面就可以在同域名页面的 frame 中嵌套。 express 配置123const helmet = require('helmet');const app = express();app.use(helmet.frameguard({ action: 'SAMEORIGIN' })) 或者使用： 123const frameguard = require('frameguard')app.use(frameguard({ action: 'SAMEORIGIN' })) #question","link":"/2021/05/26/question/iframe%E6%8A%A5%E9%94%99Refusedtodisplay'URL'inaframebecauseitset'X-Frame-Options'to'DENY'/"},{"title":"element-uitabs的labelslot不能及时动态更新","text":"https://github.com/ElemeFE/element/issues/2934 问题12345678910111213141516171819202122232425262728293031323334353637var Main = { template: `&lt;el-tabs type=&quot;border-card&quot;&gt; &lt;el-tab-pane :name=&quot;index&quot; v-for=&quot;(item, index) in tabs&quot;&gt; &lt;span slot=&quot;label&quot;&gt;{{ item.name }}&lt;/span&gt; &lt;div&gt; {{ item.name }} &lt;input type=&quot;text&quot; v-model=&quot;item.name&quot; name=&quot;name&quot;/&gt; &lt;/div&gt; &lt;/el-tab-pane&gt;&lt;/el-tabs&gt; `, data() { return { tabs: [ { name: 'tab1', content: 'Content Tab1', }, { name: 'tab2', content: 'Content Tab2', }, { name: 'tab3', content: 'Content Tab3', }, ], } },}new Vue({ el: '#app', render: (h) =&gt; h(Main)}) 解决方法1&lt;el-tabs&gt;, like &lt;el-tabs ref=&quot;tabs&quot;&gt; 1this.$refs.tabs.$refs.nav.$forceUpdate(); #vue# #javascript #question","link":"/2021/05/26/vue/element-uitabs%E7%9A%84labelslot%E4%B8%8D%E8%83%BD%E5%8F%8A%E6%97%B6%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"},{"title":"你不知道的浏览器渲染原理","text":"在我们面试过程中，面试官经常会问到这么一个问题，那就是从在浏览器地址栏中输入URL到页面显示，浏览器到底发生了什么？这个问题看起来是老生常谈，但是这个问题回答的好坏，确实可以很好的反映出面试者知识的广度和深度。本文从浏览器角度来告诉你，URL后输入后按回车，浏览器内部究竟发生了什么，读完本文后，你将了解到： 浏览器内有哪些进程，这些进程都有些什么作用 浏览器地址输入URL后，内部的进程、线程都做了哪些事 我们与浏览器交互时，内部进程是怎么处理这些交互事件的 浏览器架构在讲浏览器架构之前，先理解两个概念， 进程 和 线程 。 进程（process）是程序的一次执行过程，是一个动态概念，是程序在执行过程中分配和管理资源的基本单位，线程（thread）是CPU调度和分派的基本单位，它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 简单的说呢，进程可以理解成正在执行的应用程序，而线程呢，可以理解成我们应用程序中的代码的执行器。而他们的关系可想而知，线程是跑在进程里面的，一个进程里面可能有一个或者多个线程，而一个线程，只能隶属于一个进程。 大家都知道，浏览器属于一个应用程序，而应用程序的一次执行，可以理解为计算机启动了一个 进程 ，进程启动后，CPU会给该进程分配相应的内存空间，当我们的进程得到了内存之后，就可以使用 线程 进行资源调度，进而完成我们应用程序的功能。 而在应用程序中，为了满足功能的需要，启动的进程会创建另外的新的进程来处理其他任务，这些创建出来的新的进程拥有全新的独立的内存空间，不能与原来的进程内向内存，如果这些进程之间需要通信，可以通过IPC机制f（Inter Process Communication）来进行。 很多应用程序都会采取这种多进程的方式来工作，因为进程和进程之间是互相独立的它们 互不影响 ，也就是说，当其中一个进程挂掉了之后，不会影响到其他进程的执行，只需要重启挂掉的进程就可以恢复运行。 浏览器的多进程架构假如我们去开发一个浏览器，它的架构可以是一个单进程多线程的应用程序，也可以是一个使用IPC通信的多进程应用程序。 不同的浏览器使用不同的架构，下面主要以Chrome为例，介绍浏览器的多进程架构。 在Chrome中，主要的进程有4个： 浏览器进程 (Browser Process)：负责浏览器的TAB的前进、后退、地址栏、书签栏的工作和处理浏览器的一些不可见的底层操作，比如网络请求和文件访问。 渲染进程 (Renderer Process)：负责一个Tab内的显示相关的工作，也称渲染引擎。 插件进程 (Plugin Process)：负责控制网页使用到的插件 GPU进程 (GPU Process)：负责处理整个应用程序的GPU任务 这4个进程之间的关系是什么呢？ 首先，当我们是要浏览一个网页，我们会在浏览器的地址栏里输入URL，这个时候 Browser Process 会向这个URL发送请求，获取这个URL的HTML内容，然后将HTML交给 Renderer Process ， Renderer Process 解析HTML内容，解析遇到需要请求网络的资源又返回来交给 Browser Process 进行加载，同时通知 Browser Process ，需要 Plugin Process 加载插件资源，执行插件代码。解析完成后， Renderer Process 计算得到图像帧，并将这些图像帧交给 GPU Process ， GPU Process 将其转化为图像显示屏幕。 多进程架构的好处Chrome为什么要使用多进程架构呢？ 第一，更高的容错性。当今WEB应用中，HTML，JavaScript和CSS日益复杂，这些跑在渲染引擎的代码，频繁的出现BUG，而有些BUG会直接导致渲染引擎崩溃，多进程架构使得每一个渲染引擎运行在各自的进程中，相互之间不受影响，也就是说，当其中一个页面崩溃挂掉之后，其他页面还可以正常的运行不收影响。 第二，更高的安全性和沙盒性（sanboxing）。渲染引擎会经常性的在网络上遇到不可信、甚至是恶意的代码，它们会利用这些漏洞在你的电脑上安装恶意的软件，针对这一问题，浏览器对不同进程限制了不同的权限，并为其提供沙盒运行环境，使其更安全更可靠 第三，更高的响应速度。在单进程的架构中，各个任务相互竞争抢夺CPU资源，使得浏览器响应速度变慢，而多进程架构正好规避了这一缺点。 多进程架构优化之前的我们说到， Renderer Process 的作用是负责一个Tab内的显示相关的工作，这就意味着，一个Tab，就会有一个Renderer Process，这些进程之间的内存无法进行共享，而不同进程的内存常常需要包含相同的内容。 浏览器的进程模式为了节省内存，Chrome提供了四种进程模式（Process Models），不同的进程模式会对 tab 进程做不同的处理。 Process-per-site-instance (default) - 同一个 site-instance 使用一个进程 Process-per-site - 同一个 site 使用一个进程 Process-per-tab - 每个 tab 使用一个进程 Single process - 所有 tab 共用一个进程 这里需要给出 site 和 site-instance 的定义 site 指的是相同的 registered domain name(如：google.com ，bbc.co.uk)和scheme (如：https://)。比如a.baidu.com和b.baidu.com就可以理解为同一个 site（注意这里要和 Same-origin policy 区分开来，同源策略还涉及到子域名和端口）。 site-instance 指的是一组 connected pages from the same site，这里 connected 的定义是 can obtain references to each other in script code 怎么理解这段话呢。满足下面两中情况并且打开的新页面和旧页面属于上面定义的同一个 site，就属于同一个 site-instance 用户通过 &lt;a target=&quot;_blank&quot;&gt; 这种方式点击打开的新页面 JS代码打开的新页面（比如 window.open ) 理解了概念之后，下面解释四个进程模式 首先是 Single process ，顾名思义，单进程模式，所有tab都会使用同一个进程。接下来是 Process-per-tab ，也是顾名思义，每打开一个tab，会新建一个进程。而对于 Process-per-site ，当你打开 a.baidu.com 页面，在打开 b.baidu.com 的页面，这两个页面的tab使用的是共一个进程，因为这两个页面的site相同，而如此一来，如果其中一个tab崩溃了，而另一个tab也会崩溃。 Process-per-site-instance 是最重要的，因为这个是 Chrome 默认使用的模式，也就是几乎所有的用户都在用的模式。当你打开一个 tab 访问 a.baidu.com ，然后再打开一个 tab 访问 b.baidu.com，这两个 tab 会使用两个进程。而如果你在 a.baidu.com 中，通过JS代码打开了 b.baidu.com 页面，这两个 tab 会使用同一个进程。 默认模式选择那么为什么浏览器使用 Process-per-site-instance 作为默认的进程模式呢？ Process-per-site-instance 兼容了性能与易用性，是一个比较中庸通用的模式。 相较于 Process-per-tab，能够少开很多进程，就意味着更少的内存占用 相较于 Process-per-site，能够更好的隔离相同域名下毫无关联的 tab，更加安全 导航过程都发生了什么前面我们讲了浏览器的多进程架构，讲了多进程架构的各种好处，和Chrome是怎么优化多进程架构的，下面从用户浏览网页这一简单的场景，来深入了解进程和线程是如何呈现我们的网站页面的。 网页加载过程之前我们我们提到，tab以外的大部分工作由浏览器进程 Browser Process 负责，针对工作的不同，Browser Process 划分出不同的工作线程： UI thread：控制浏览器上的按钮及输入框； network thread：处理网络请求，从网上获取数据； storage thread：控制文件等的访问； 第一步：处理输入当我们在浏览器的地址栏输入内容按下回车时， UI thread 会判断输入的内容是搜索关键词（search query）还是URL，如果是搜索关键词，跳转至默认搜索引擎对应都搜索URL，如果输入的内容是URL，则开始请求URL。 第二步：开始导航回车按下后， UI thread 将关键词搜索对应的URL或输入的URL交给网络线程 Network thread ，此时UI线程使Tab前的图标展示为加载中状态，然后网络进程进行一系列诸如DNS寻址，建立TLS连接等操作进行资源请求，如果收到服务器的301重定向响应，它就会告知UI线程进行重定向然后它会再次发起一个新的网络请求。 第三步：读取响应network thread 接收到服务器的响应后，开始解析HTTP响应报文，然后根据响应头中的 Content-Type 字段来确定响应主体的媒体类型（MIME Type），如果媒体类型是一个HTML文件，则将响应数据交给渲染进程（renderer process）来进行下一步的工作，如果是 zip 文件或者其它文件，会把相关数据传输给下载管理器。 与此同时，浏览器会进行 Safe Browsing 安全检查，如果域名或者请求内容匹配到已知的恶意站点，network thread 会展示一个警告页。除此之外，网络线程还会做 CORB（Cross Origin Read Blocking）检查来确定那些敏感的跨站数据不会被发送至渲染进程。 第四步：查找渲染进程各种检查完毕以后，network thread 确信浏览器可以导航到请求网页，network thread 会通知 UI thread 数据已经准备好，UI thread 会查找到一个 renderer process 进行网页的渲染。 浏览器为了对查找渲染进程这一步骤进行优化，考虑到网络请求获取响应需要时间，所以在第二步开始，浏览器已经预先查找和启动了一个渲染进程，如果中间步骤一切顺利，当 network thread 接收到数据时，渲染进程已经准备好了，但是如果遇到重定向，这个准备好的渲染进程也许就不可用了，这个时候会重新启动一个渲染进程。 第五步：提交导航到了这一步，数据和渲染进程都准备好了， Browser Process 会向 Renderer Process 发送IPC消息来确认导航，此时，浏览器进程将准备好的数据发送给渲染进程，渲染进程接收到数据之后，又发送IPC消息给浏览器进程，告诉浏览器进程导航已经提交了，页面开始加载。 这个时候导航栏会更新，安全指示符更新（地址前面的小锁），访问历史列表（history tab）更新，即可以通过前进后退来切换该页面。 第六步：初始化加载完成当导航提交完成后，渲染进程开始加载资源及渲染页面（详细内容下文介绍），当页面渲染完成后（页面及内部的iframe都触发了onload事件），会向浏览器进程发送IPC消息，告知浏览器进程，这个时候UI thread会停止展示tab中的加载中图标。 网页渲染原理导航过程完成之后，浏览器进程把数据交给了渲染进程，渲染进程负责tab内的所有事情，核心目的就是将HTML/CSS/JS代码，转化为用户可进行交互的web页面。那么渲染进程是如何工作的呢？ 渲染进程中，包含线程分别是： 一个主线程（main thread） 多个工作线程（work thread） 一个合成器线程（compositor thread） 多个光栅化线程（raster thread） 不同的线程，有着不同的工作职责。 构建DOM当渲染进程接受到导航的确认信息后，开始接受来自浏览器进程的数据，这个时候，主线程会解析数据转化为DOM（Document Object Model）对象。 DOM为WEB开发人员通过JavaScript与网页进行交互的数据结构及API。 资源子加载在构建DOM的过程中，会解析到图片、CSS、JavaScript脚本等资源，这些资源是需要从网络或者缓存中获取的，主线程在构建DOM过程中如果遇到了这些资源，逐一发起请求去获取，而为了提升效率，浏览器也会运行预加载扫描（preload scanner）程序，如果如果HTML中存在 img、link 等标签，预加载扫描程序会把这些请求传递给 Browser Process 的network thread进行资源下载。 JavaScript的下载与执行构建DOM过程中，如果遇到 &lt;script&gt; 标签，渲染引擎会停止对HTML的解析，而去加载执行JS代码，原因在于JS代码可能会改变DOM的结构（比如执行 document.write() 等API） 不过开发者其实也有多种方式来告知浏览器应对如何应对某个资源，比如说如果在 &lt;script&gt; 标签上添加了 async 或 defer 等属性，浏览器会异步的加载和执行JS代码，而不会阻塞渲染。 样式计算 - Style calculationDOM树只是我们页面的结构，我们要知道页面长什么样子，我们还需要知道DOM的每一个节点的样式。主线程在解析页面时，遇到 &lt;style&gt; 标签或者 &lt;link&gt; 标签的CSS资源，会加载CSS代码，根据CSS代码确定每个DOM节点的计算样式（computed style）。 计算样式是主线程根据CSS样式选择器（CSS selectors）计算出的每个DOM元素应该具备的具体样式，即使你的页面没有设置任何自定义的样式，浏览器也会提供其默认的样式。 布局 - LayoutDOM树和计算样式完成后，我们还需要知道每一个节点在页面上的位置，布局（Layout）其实就是找到所有元素的几何关系的过程。 主线程会遍历DOM 及相关元素的计算样式，构建出包含每个元素的页面坐标信息及盒子模型大小的布局树（Render Tree），遍历过程中，会跳过隐藏的元素（display: none），另外，伪元素虽然在DOM上不可见，但是在布局树上是可见的。 绘制 - Paint布局 layout 之后，我们知道了不同元素的结构，样式，几何关系，我们要绘制出一个页面，我们要需要知道每个元素的绘制先后顺序，在绘制阶段，主线程会遍历布局树（layout tree），生成一系列的绘画记录（paint records）。绘画记录可以看做是记录各元素绘制先后顺序的笔记。 合成 - Compositing文档结构、元素的样式、元素的几何关系、绘画顺序，这些信息我们都有了，这个时候如果要绘制一个页面，我们需要做的是把这些信息转化为显示器中的像素，这个转化的过程，叫做 光栅化 （rasterizing）。 那我们要绘制一个页面，最简单的做法是只光栅化视口内（viewport）的网页内容，如果用户进行了页面滚动，就移动光栅帧（rastered frame）并且光栅化更多的内容以补上页面缺失的部分，如下： Chrome第一个版本就是采用这种简单的绘制方式，这一方式唯一的缺点就是每当页面滚动，光栅线程都需要对新移进视图的内容进行光栅化，这是一定的性能损耗，为了优化这种情况，Chrome采取一种更加复杂的叫做合成（compositing）的做法。 那么，什么是合成？合成是一种将页面分成若干层，然后分别对它们进行光栅化，最后在一个单独的线程 - 合成线程（compositor thread）里面合并成一个页面的技术。当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧来展示滚动后的效果罢了。页面的动画效果实现也是类似，将页面上的层进行移动并构建出一个新的帧即可。 为了实现合成技术，我们需要对元素进行分层，确定哪些元素需要放置在哪一层，主线程需要遍历渲染树来创建一棵层次树（Layer Tree），对于添加了 will-change CSS 属性的元素，会被看做单独的一层，没有 will-change CSS属性的元素，浏览器会根据情况决定是否要把该元素放在单独的层。 你可能会想要给页面上所有的元素一个单独的层，然而当页面的层超过一定的数量后，层的合成操作要比在每个帧中光栅化页面的一小部分还要慢，因此衡量你应用的渲染性能是十分重要的一件事情。 一旦Layer Tress被创建，渲染顺序被确定，主线程会把这些信息通知给合成器线程，合成器线程开始对层次数的每一层进行光栅化。有的层的可以达到整个页面的大小，所以合成线程需要将它们切分为一块又一块的小图块（tiles），之后将这些小图块分别进行发送给一系列光栅线程（raster threads）进行光栅化，结束后光栅线程会将每个图块的光栅结果存在 GPU Process 的内存中。 为了优化显示体验，合成线程可以给不同的光栅线程赋予不同的优先级，将那些在视口中的或者视口附近的层先被光栅化。 当图层上面的图块都被栅格化后，合成线程会收集图块上面叫做绘画四边形（draw quads）的信息来构建一个合成帧（compositor frame）。 绘画四边形：包含图块在内存的位置以及图层合成后图块在页面的位置之类的信息。 合成帧：代表页面一个帧的内容的绘制四边形集合。 以上所有步骤完成后，合成线程就会通过IPC向浏览器进程（browser process）提交（commit）一个渲染帧。这个时候可能有另外一个合成帧被浏览器进程的UI线程（UI thread）提交以改变浏览器的UI。这些合成帧都会被发送给GPU从而展示在屏幕上。如果合成线程收到页面滚动的事件，合成线程会构建另外一个合成帧发送给GPU来更新页面。 合成的好处在于这个过程没有涉及到主线程，所以合成线程不需要等待样式的计算以及JavaScript完成执行。这就是为什么合成器相关的动画最流畅，如果某个动画涉及到布局或者绘制的调整，就会涉及到主线程的重新计算，自然会慢很多。 浏览器对事件的处理当页面渲染完毕以后，TAB内已经显示出了可交互的WEB页面，用户可以进行移动鼠标、点击页面等操作了，而当这些事件发生时候，浏览器是如何处理这些事件的呢？ 以点击事件（click event）为例，让鼠标点击页面时候，首先接受到事件信息的是 Browser Process ，但是Browser Process只知道事件发生的类型和发生的位置，具体怎么对这个点击事件进行处理，还是由Tab内的 Renderer Process 进行的。Browser Process接受到事件后，随后便把事件的信息传递给了渲染进程，渲染进程会找到根据事件发生的坐标，找到目标对象（target），并且运行这个目标对象的点击事件绑定的监听函数（listener）。 渲染进程中合成器线程接收事件前面我们说到，合成器线程可以独立于主线程之外通过已光栅化的层创建组合帧，例如页面滚动，如果没有对页面滚动绑定相关的事件，组合器线程可以独立于主线程创建组合帧，如果页面绑定了页面滚动事件，合成器线程会等待主线程进行事件处理后才会创建组合帧。那么，合成器线程是如何判断出这个事件是否需要路由给主线程处理的呢？ 由于执行 JS 是主线程的工作，当页面合成时，合成器线程会标记页面中绑定有事件处理器的区域为 非快速滚动区域 (non-fast scrollable region)，如果事件发生在这些存在标注的区域，合成器线程会把事件信息发送给主线程，等待主线程进行事件处理，如果事件不是发生在这些区域，合成器线程则会直接合成新的帧而不用等到主线程的响应。 而对于非快速滚动区域的标记，开发者需要注意全局事件的绑定，比如我们使用事件委托，将目标元素的事件交给根元素body进行处理，代码如下： 1document.body.addEventListener('touchstart', event =&gt; { if (event.target === area) { event.preventDefault() }}) 在开发者角度看，这一段代码没什么问题，但是从浏览器角度看，这一段代码给body元素绑定了事件监听器，也就意味着整个页面都被编辑为一个非快速滚动区域，这会使得即使你的页面的某些区域没有绑定任何事件，每次用户触发事件时，合成器线程也需要和主线程通信并等待反馈，流畅的合成器独立处理合成帧的模式就失效了。 其实这种情况也很好处理，只需要在事件监听时传递 passtive 参数为 true， passtive 会告诉浏览器你既要绑定事件，又要让组合器线程直接跳过主线程的事件处理直接合成创建组合帧。 1document.body.addEventListener('touchstart', event =&gt; { if (event.target === area) { event.preventDefault() } }, {passive: true}); 查找事件的目标对象（event target）当合成器线程接收到事件信息，判定到事件发生不在非快速滚动区域后，合成器线程会向主线程发送这个时间信息，主线程获取到事件信息的第一件事就是通过命中测试（hit test）去找到事件的目标对象。具体的命中测试流程是遍历在绘制阶段生成的绘画记录（paint records）来找到包含了事件发生坐标上的元素对象。 浏览器对事件的优化一般我们屏幕的帧率是每秒60帧，也就是60fps，但是某些事件触发的频率超过了这个数值，比如wheel，mousewheel，mousemove，pointermove，touchmove，这些连续性的事件一般每秒会触发60~120次，假如每一次触发事件都将事件发送到主线程处理，由于屏幕的刷新速率相对来说较低，这样使得主线程会触发过量的命中测试以及JS代码，使得性能有了没必要是损耗。 出于优化的目的，浏览器会合并这些连续的事件，延迟到下一帧渲染是执行，也就是 requestAnimationFrame 之前。 而对于非连续性的事件，如keydown，keyup，mousedown，mouseup，touchstart，touchend等，会直接派发给主线程去执行。 总结浏览器的多进程架构，根据不同的功能划分了不同的进程，进程内不同的使命划分了不同的线程，当用户开始浏览网页时候，浏览器进程进行处理输入、开始导航请求数据、请求响应数据，查找新建渲染进程，提交导航，之后渲染又进行了解析HTML构建DOM、构建过程加载子资源、下载并执行JS代码、样式计算、布局、绘制、合成，一步一步的构建出一个可交互的WEB页面，之后浏览器进程又接受页面的交互事件信息，并将其交给渲染进程，渲染进程内主进程进行命中测试，查找目标元素并执行绑定的事件，完成页面的交互。 #javascript","link":"/2021/05/26/javascript/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/"},{"title":"实时协同编辑的实现","text":"在最近某个项目中打算使用协同编辑来解决冲突问题，因此抽空调研了现有的实现方案，结果发现要想做完美是很难的，但我们可以低成本地做到不错的效果，本文将介绍几种实现方法，大家在项目中如果有需要可以参考。 什么是实时协同编辑这里所说的实时协同编辑，是指多人同时编辑一个文档，最典型的例子是 Google Docs，你可以实时看到别人做出的修改，不用手动刷新页面。 要实现实时编辑，我们需要解决两个技术点：实时通信问题、编辑冲突问题，其中实时通信问题比较好解决，可以使用 long pull 或 WebSocket，所以这里就不过多讨论了，重点将放在如何解决编辑冲突问题上。 可选方案接下来将从易至难的顺序来介绍几种可行的方案，分别是：「编辑锁」、「GNU diff-patch」、「Myer’s diff-patch」、「Operational Transformation」和「分布式 Operational Transformation」。 编辑锁编辑锁这是实现协同编辑最简单的方法，简单来说就是当有人在编辑某个文档时，系统会将这个文档锁定，避免其他人同时编辑，因为实现简单，所以这个方案是应用最广的，比如公司内部常用的 TWiki 系统，采用这种方式虽然可以在一定程度上避免覆盖问题，但它的使用体验不好，也做不到「实时」，所以这里就不讨论了。 GNU diff-patchGit 等版本管理软件其实也是一种协同编辑工具，因为每个人都可以并行编辑，遇到编辑同一个文件时可以自动合并，因此我们也能使用类似的原理来实现协同编辑，具体可以有两种方法：diff-patch 和 merge。 先说 diff-patch，这里的 diff 和 patch 是指两个 unix 下的命令，diff 能输出两个文本的不同之处，然后用 patch 来更新其它文件，我们只要在 JS 中实现这两个算法，就能通过如下流程来实现协同编辑： 每个用户进来时都建立长连接，保存好当前文档副本 有人编辑时，如果停顿 5 秒（具体要根据产品策略），就将现有文档和之前的副本进行 diff，将结果传给服务端，更新副本 服务端更新文档，然后通过长连接将这个 diff 结果发给同时在编辑的其它用户，这些用户使用 patch 方法来更新 ta 们文档 但 GNU diff 有个问题，因为基于行匹配的，所以很容易冲突，让我们测试一下「百度 Web」和「百度 Web 前端」这两段文本的 diff 结果 123456[nwind@fex ~]$ diff old.txt other-new.txt &gt; old-to-other-new.patch[nwind@fex ~]$ cat old-to-other-new.patch1c1&lt; 百度 Web---&gt; 百度 Web 前端 在这个 diff 结果中， 1c1 的第一个「1」代表修改前的第一行，后面的「c」代表「修改」，第二个「1」代表修改后的行，也就是说将第一行的「百度 Web」改成「百度 Web 前端」，修改后的内容放第一行。也就意味着如果两人同时修改一行就会冲突，可以通过下面的测试来确认： 123456789[nwind@fex ~]$ cat my-new.txtWeb [nwind@fex ~]$ patch my-new.txt &lt; old-to-other-new.patchpatching file b-new.txtHunk #1 FAILED at 1.1 out of 1 hunk FAILED -- saving rejects to file my-new.txt.rej [nwind@fex ~]$ cat my-new.txt.rej****************** 1- 百度 Web--- 1 -----+ 百度 Web 前端 其中 my-new.txt 是我修改的版本，我去掉了前面的「百度 」，只留下「Web」，其实这两处修改是不冲突的，它们可以合并成「Web 前端」，如下图所示 但使用 patch 命令部下，它在冲突后会生成一个新文件 my-new.txt.rej 来描述失败原因，这种展现方式不直观，需要打开两个文件比对，我们使用另一种方式来更好地展现，那就是接下来介绍的 merge 命令，它的使用方法如下： 12345[nwind@fex ~]$ merge my-new.txt old.txt other-new.txtmerge: warning: conflicts during merge [nwind@fex ~]$ cat my-new.txt&lt;&lt;&lt;&lt;&lt;&lt;&lt; my-new.txtWeb=======百度 Web 前端&gt;&gt;&gt;&gt;&gt;&gt;&gt; other-new.txt 可以看到它直接将冲突的地方写到 my-new.txt 里了，这点比 patch 看起来要方便些，对于这个结果估计大部分同学都会眼熟，因为 merge 命令和 Git 等工具 中的合并算法是一样的 。 通过使用我们可以发现 merge 命令有个缺点，那就是需要使用 3 份完整的文本来进行比较，为了避免每次传递所有文本内容，我们可以结合使用 diff 来减小传输体积，在后端 patch 成新的文本。 无论是 diff 还是 merge，由于它们的算法都是基于行进行比较，导致对同一行的编辑必然冲突，为了解决这个问题，我们可以尝试基于字符粒度的 diff 算法，那就是接下来将介绍的 Myer’s diff-patch。 Myer’s diff-patchMyer 算法 是另一种 diff-patch 算法，它有很多 语言的开源实现 ，这里我们就不介绍细节算法了，直接用之前的例子来测试它的效果，首先看一下它的 diff 结果，调用代码如下： 1234var old_text = &quot;百度 Web&quot;;var new_text = &quot;百度 Web 前端&quot;; var dmp = new diff_match_patch();var patch_list = dmp.patch_make(old_text, new_text);patch_text = dmp.patch_toText(patch_list); console.log(decodeURI(patch_text)) 输出结果为 123@@ -1,6 +1,9 @@ 百度 Web+ 前端 其中第一行的 - 和 + 两个符号没有什么意义，这句话表示修改处之前的起始位置为 1（由于数组是从 0 开始的，所以内部计算时会先减一），长度为 6，后面的 1,9 ，表示修改后的起始位置为 1，长度为 9。在接下来的两段文本代表修改的地方，注意「百度 Web」前面有空格，这代表相等，也就是直接添加这个字符串，而后面的 + 代表添加文本，具体细节可以通过它的 实现源码 了解。 因此确定它的 diff 策略是基于字符匹配的，这样能否解决我们之前遇到的冲突问题呢？接下来来测试一下，源码如下： 123//相关代码同上var patches = dmp.patch_fromText(patch_text);var results = dmp.patch_apply(patches, &quot;Web&quot;); console.log(results[0]); //Web 前端 这个输出结果是正确的，也就是说它能很好地解决之前的问题，但如果是同一个位置的修改会怎样？我继续做了几个实验： 1234567891011121314var old_text = &quot;百度 Web&quot;;var other_new_text = &quot;百度 Web 后端&quot;;var my_new_text = &quot;百度 Web 前端&quot;;...//结果为「百度 Web 前端 后端」 ===var old_text = &quot;百度 Web 前端&quot;;var other_new_text = &quot;百度 Web 后端&quot;;var my_new_text = &quot;百度 Web 全端&quot;;...//结果为「百度 Web 后端」 ===var old_text = &quot;百度 Web&quot;;var other_new_text = &quot;Web 前端&quot;;var my_new_text = &quot;百度 FE&quot;;//结果为「FE 前」 第一个例子是在后面添加不同的字符，它的结果是两个添加都生效，第二个例子是在同一处修改成不同的字符，它的结果是别人的修改生效，但最后一个例子出错了，丢失了「端」字，这里看起来还好，但如果内容是富文本就有问题了，比如 &lt;b&gt; 少了 &gt; 是不行的。 整体来看 Myer 算法可以低成本地解决大部分问题，所以有些在线编辑器选择它来实现协同编辑功能，比如 codebox ，它的客户端代码 在这 ，服务端代码 在这 。 不过 Myer 在某些情况下会丢字符，是否还有更好的方法？答案是有，那就是接下来介绍的 Operational Transformation 技术。 Operational TransformationOperational Transformation（下面简称 OT）技术正是 Google Docs 中所采用的方案，因此是经过验证的，值得研究。 最开始我一直觉得 OT 会很复杂，因为它的相关介绍文章都写得很长，比如 这篇 及维基百科上的 介绍 ，不过看了之后才后发现它的原理并不复杂，我将在这里进行简单的说明。 首先，我们可以将文本内容修改转成以下 3 种类型的操作(Operational)： retain(n)：保持 n 个字符，也就是说这 n 个字符不变 insert(str)：插入字符 str delete(str)：删除字符 str 举个例子，假设 A 用户将「百度 Web」变成「Web 前端」，相当于产生了如下 3 个操作： 123delete('百度 '), //删掉「百度 」retain(3), //跳过 3 个字符（也就是「Web」）insert(' 前端') //插入「 前端」 提取这些操作可以通过 Levenshtein distance（编辑距离）算法来实现。那它如何解决冲突问题了？比如这时如果 B 用户将「百度 Web」改成了「百度 FE」，B 所生产的操作步骤将会是如下： 123retain(3), //跳过 3 个字符（也就是「百度 」）delete('Web'),insert('FE') 如果我们先应用 A 的操作，将字符串变为「Web 前端」，然后再应用 B 的操作时就会失效，因为在执行 B 的第二个操作 delete('Web') 时并没有「Web」，这时从第四个字符开始已经变成了「 前端」。 因此我们需要转换 B 的操作来适应新的字符串，比如调成如下操作： 123delete('Web'),insert('FE'),retain(3) 这个转换算法就是 OT 的核心，实际上 OT 指的是一类技术，而不是具体的算法，这个思路就是首先将编辑转成操作(Operational)，如果多人操作同时进行，需要对这些操作进行转换(Transformation)，这就是为什么叫 Operational Transformation，而具体应该拆分成哪些操作以及转换算法都是可以自定义的，因此 OT 可以灵活地支持各种协同编辑应用，比如非文本类的编辑。 回到之前 Myer 算法导致丢字符的那个例子，我们看看 OT 是否能解决，这里我使用了一个开源库 changesets ，以下是基于它实现合并的例子： 123var Changeset = require('changesets').Changeset; var text = &quot;百度 Web&quot; , textA = &quot;Web 前端&quot; , textB = &quot;百度 FE&quot;; var csA = Changeset.fromDiff(text, textA);var csB = Changeset.fromDiff(text, textB); var csB_new = csB.transformAgainst(csA); //这里这就是操作转换 var textA_new = csA.apply(text);console.log(csB_new.apply(textA_new)); //结果是「 前端FE」 结果并不正确，正确的应该是「FE 前端」，查看一下 csB_new 的内容，发现它实际上是转换成了如下操作： 123delete(3), //注意 changesets 在这里的参数不是字符串而是数字，它会直接删掉 3 个字符，不够内容是什么retain(3),insert('FE') 需要注意这并不是 OT 技术本身的问题，而是 changesets 所实现的转换算法问题，虽然不够完美，但和之前的 Myer 算法相比，至少没丢字符，后来我又做了几个测试，发现 OT 技术的准确率比 Myer 高，因此它是最适合用于协同编辑的技术。 分布式 Operational Transformation如果看完上面的文章你觉得实现实时协同编辑似乎不难，那你就错了，因为我们之前都没有考虑分布式的问题，OT 技术在学术界都研究 20 多年了，至今也没人总结出一个最好的方法，前 Google Wave 工程师在 ShareJS 首页上这样写道： Unfortunately, implementing OT sucks. There’s a million algorithms with different tradeoffs, mostly trapped in academic papers. The algorithms are really hard and time consuming to implement correctly. I am an ex Google Wave engineer. Wave took 2 years to write and if we rewrote it today, it would take almost as long to write a second time. 所以其实要做好是很难的，这里面最麻烦的就是分布式导致的问题，接下来将介绍 3 个我能想到的问题及解决方法。 1. 顺序问题 首先第一个问题是顺序问题，因为 OT 等算法都是依赖顺序的，不同顺序会导致结果不同，我们通过下面这张图来说明： 假设 Client A 在做两次修改时发了两个异步请求，可能因为网络延迟导致第二个请求反而先到了，导致最终服务器版本和 Client A 所看到的不一致，同样在服务器发往其它客户端的请求时也会出现乱序的问题，如图中 Client B 也有问题。 这个问题的解决方法很简单，我们可以在客户端和服务器端都加上队列来保证请求顺序，等前一个请求结束后再发下一个请求。 2. 存储的原子操作 如果有多台服务器，或者有多个线程/进程在同时处理请求时就会遇到覆盖问题，因为读写数据库并不是原子操作，比如下面的例子： Web Server A 和 Web Server B 同时访问数据库，结果导致 Web Server A 的修改被覆盖了。 好在这种问题还算比较常见，解决办法可以有 3 种： 保证操作只在一个线程中执行，比如某个文档的更新只在某个固定的机器，使用 Node 这样的单线程模型提供服务，这样就不可能并行修改了 如果数据库支持事务(transaction)，可以通过事务来解决 如果数据库不支持事务，就只能用分布式锁了，如 ZooKeeper 从实现角度来看，第一和第二种方法都比较简单，而第三种方法会带来很多问题，比如可能导致文档被锁死，假如上锁后由于种种原因没有执行解锁操作，这个文档就会永远被锁住，所以还得加上超时限制等策略。 然而在解决了原子操作后，我们将发现一个新的问题，那就是版本管理问题。 3. 版本管理问题 在前面的例子中，两段新文本的修改都是基于同一个旧版本的，如果旧版本不一样，就有可能出错，具体可以通过下面这张图来解释： 在这个例子中，Web Server A 接收到操作命令是将「a」文本改成「aa」，Web Server B 接收到操作命令是将「a」文本改成「ab」，这里我们加上了锁机制来避免同时读写数据，Web Server A 首先得到了锁，然后修改并更新数据，而 Web Server B 需要先等待数据解锁，等 Web Server B 拿到数据后它已经从「a」变成了「aa」，如果还按照 retain(1), insert('b') 进行修改，数据将变成「ab」，而不是正确的「aab」，引起这个问题的原因就是旧版本不一致，Web Server B 需要根据 Web Server A 的操作进行操作转换，变成 retain(2), insert('b') ，然后才能对数据进行修改。 因此想要解决这个问题，就必须引入版本，每次修改后都需要存储下新版本，有了版本我们就能使用 diff 功能来计算不同版本的差异，得到其它人修改的内容，然后通过 OT 合并算法合并两个操作，如下所示： 在 Web Server A 操作前数据版本是 v=1 ，操作后变成了 v=2 ，等到 Web Server B 处理的时候，它通过版本比较发现不一致，所以就首先通过编辑距离算法算出 Web Server A 所做的操作，然后用这个操作来对自己的操作进行转换，得到正确的新操作，从而避免了覆盖问题。 如果保存所有版本会导致数据量大大增加，所以还需要再优化，比如每个服务器保存一个数据副本，但这里就不再展开了，可以看要支持分布式 还是挺麻烦的，不过目前出现了一些前后端整合的方案，如 ShareJS 和 OpenCoweb Framework ，可以参考。 另外之前提到的 Myer’s diff 算法也有分布式解决方案，具体细节可以参考 这篇文档 。 初步结论 如果你只是一个内部小项目，实时性要求不高，但对准确性要求比较高 推荐用 merge 或 diff3 工具，出现同一行冲突时由用户来解决，这样能避免自动合并有可能出错的问题 如果想具备一定的实时性，流量不大，不想实现太复杂，且对少量的冲突可以忍受 推荐用 Myer’s diff，后端只开一个 Node 进程 如果想具备实时性，且有多台后端服务同时处理 可以用 Operational Transformation 或 Myer’s diff，但需要注意分布式带来的问题 如果需要很精细的控制，如支持富文本编辑等非单纯文本格式 只能使用 Operational Transformation，但要自己实现操作合并算法，比如 XML 可以参考 这篇文章 后续除了文本合并，真正要做在线编辑还有很多细节处理，感兴趣的同学可以继续研究： 支持选区，看到其他人选择的文本段，当然，这也有合并问题 指针要更随文本变化移动到正确的位置 支持 undo 实时协同编辑的实现 #javascript","link":"/2021/05/26/javascript/%E5%AE%9E%E6%97%B6%E5%8D%8F%E5%90%8C%E7%BC%96%E8%BE%91%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"title":"AirbnbJavaScriptStyleGuide","text":"Types1.1 ::Primitives::: When you access a primitive type you work directly on its value. * `string` * `number` * `boolean` * `null` * `undefined` * `symbol` * `bigint` 12345const foo = 1;let bar = foo;bar = 9;console.log(foo, bar); // =&gt; 1, 9 * Symbols and BigInts cannot be faithfully polyfilled, so they should not be used when targeting browsers/environments that don’t support them natively. 1.2 ::Complex::: When you access a complex type you work on a reference to its value. object array function 123456const foo = [1, 2];const bar = foo;bar[0] = 9;console.log(foo[0], bar[0]); // =&gt; 9, 9 References 2.1 Use const for all of your references; avoid using var. eslint: prefer-const, no-const-assign Why? This ensures that you can’t reassign your references, which can lead to bugs and difficult to comprehend code. 1234567// badvar a = 1;var b = 2;// goodconst a = 1;const b = 2; 2.2 If you must reassign references, use let instead of var. eslint: no-var Why? let is block-scoped rather than function-scoped like var. 1234567891011// badvar count = 1;if (true) { count += 1;}// good, use the let.let count = 1;if (true) { count += 1;} 2.3 Note that both let and const are block-scoped, whereas var is function-scoped. 123456789// const and let only exist in the blocks they are defined in.{ let a = 1; const b = 1; var c = 1;}console.log(a); // ReferenceErrorconsole.log(b); // ReferenceErrorconsole.log(c); // Prints 1 In the above code, you can see that referencing a and b will produce a ReferenceError, while c contains the number. This is because a and b are block scoped, while c is scoped to the containing function. Objects 3.1 Use the literal syntax for object creation. eslint: no-new-object 12345// badconst item = new Object();// goodconst item = {}; 3.2 Use computed property names when creating objects with dynamic property names. Why? They allow you to define all the properties of an object in one place. 123456789101112131415161718function getKey(k) { return `a key named ${k}`;}// badconst obj = { id: 5, name: 'San Francisco',};obj[getKey('enabled')] = true;// goodconst obj = { id: 5, name: 'San Francisco', [getKey('enabled')]: true,}; 3.3 Use object method shorthand. eslint: object-shorthand 1234567891011121314151617// badconst atom = { value: 1, addValue: function (value) { return atom.value + value; },};// goodconst atom = { value: 1, addValue(value) { return atom.value + value; },}; 3.4 Use property value shorthand. eslint: object-shorthand Why? It is shorter and descriptive. 1234567891011const lukeSkywalker = 'Luke Skywalker';// badconst obj = { lukeSkywalker: lukeSkywalker,};// goodconst obj = { lukeSkywalker,}; 3.5 Group your shorthand properties at the beginning of your object declaration. Why? It’s easier to tell which properties are using the shorthand. 12345678910111213141516171819202122const anakinSkywalker = 'Anakin Skywalker';const lukeSkywalker = 'Luke Skywalker';// badconst obj = { episodeOne: 1, twoJediWalkIntoACantina: 2, lukeSkywalker, episodeThree: 3, mayTheFourth: 4, anakinSkywalker,};// goodconst obj = { lukeSkywalker, anakinSkywalker, episodeOne: 1, twoJediWalkIntoACantina: 2, episodeThree: 3, mayTheFourth: 4,}; 3.6 Only quote properties that are invalid identifiers. eslint: quote-props Why? In general we consider it subjectively easier to read. It improves syntax highlighting, and is also more easily optimized by many JS engines. 12345678910111213// badconst bad = { 'foo': 3, 'bar': 4, 'data-blah': 5,};// goodconst good = { foo: 3, bar: 4, 'data-blah': 5,}; 3.7 Do not call Object.prototype methods directly, such as hasOwnProperty, propertyIsEnumerable, and isPrototypeOf. eslint: no-prototype-builtins Why? These methods may be shadowed by properties on the object in question - consider { hasOwnProperty: false } - or, the object may be a null object (Object.create(null)). 123456789101112// badconsole.log(object.hasOwnProperty(key));// goodconsole.log(Object.prototype.hasOwnProperty.call(object, key));// bestconst has = Object.prototype.hasOwnProperty; // cache the lookup once, in module scope.console.log(has.call(object, key));/* or */import has from 'has'; // https://www.npmjs.com/package/hasconsole.log(has(object, key)); 3.8 Prefer the object spread syntax over Object.assign to shallow-copy objects. Use the object rest operator to get a new object with certain properties omitted. eslint: prefer-object-spread 1234567891011121314// very badconst original = { a: 1, b: 2 };const copy = Object.assign(original, { c: 3 }); // this mutates `original` ಠ_ಠdelete copy.a; // so does this// badconst original = { a: 1, b: 2 };const copy = Object.assign({}, original, { c: 3 }); // copy =&gt; { a: 1, b: 2, c: 3 }// goodconst original = { a: 1, b: 2 };const copy = { ...original, c: 3 }; // copy =&gt; { a: 1, b: 2, c: 3 }const { a, ...noA } = copy; // noA =&gt; { b: 2, c: 3 } Arrays 4.1 Use the literal syntax for array creation. eslint: no-array-constructor 12345// badconst items = new Array();// goodconst items = []; 4.2 Use Array#push instead of direct assignment to add items to an array. 1234567const someStack = [];// badsomeStack[someStack.length] = 'abracadabra';// goodsomeStack.push('abracadabra'); 4.3 Use array spreads ... to copy arrays. 1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i += 1) { itemsCopy[i] = items[i];}// goodconst itemsCopy = [...items]; 4.4 To convert an iterable object to an array, use spreads ... instead of Array.from. 1234567const foo = document.querySelectorAll('.foo');// goodconst nodes = Array.from(foo);// bestconst nodes = [...foo]; 4.5 Use Array.from for converting an array-like object to an array. 1234567const arrLike = { 0: 'foo', 1: 'bar', 2: 'baz', length: 3 };// badconst arr = Array.prototype.slice.call(arrLike);// goodconst arr = Array.from(arrLike); 4.6 Use Array.from instead of spread ... for mapping over iterables, because it avoids creating an intermediate array. 12345// badconst baz = [...foo].map(bar);// goodconst baz = Array.from(foo, bar); 4.7 Use return statements in array method callbacks. It’s ok to omit the return if the function body consists of a single statement returning an expression without side effects, following 8.2. eslint: array-callback-return 123456789101112131415161718192021222324252627282930313233343536373839// good[1, 2, 3].map((x) =&gt; { const y = x + 1; return x * y;});// good[1, 2, 3].map((x) =&gt; x + 1);// bad - no returned value means `acc` becomes undefined after the first iteration[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) =&gt; { const flatten = acc.concat(item);});// good[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) =&gt; { const flatten = acc.concat(item); return flatten;});// badinbox.filter((msg) =&gt; { const { subject, author } = msg; if (subject === 'Mockingbird') { return author === 'Harper Lee'; } else { return false; }});// goodinbox.filter((msg) =&gt; { const { subject, author } = msg; if (subject === 'Mockingbird') { return author === 'Harper Lee'; } return false;}); 4.8 Use line breaks after open and before close array brackets if an array has multiple lines 12345678910111213141516171819202122232425262728293031// badconst arr = [ [0, 1], [2, 3], [4, 5],];const objectInArray = [{ id: 1,}, { id: 2,}];const numberInArray = [ 1, 2,];// goodconst arr = [[0, 1], [2, 3], [4, 5]];const objectInArray = [ { id: 1, }, { id: 2, },];const numberInArray = [ 1, 2,]; Destructuring 5.1 Use object destructuring when accessing and using multiple properties of an object. eslint: prefer-destructuring Why? Destructuring saves you from creating temporary references for those properties, and from repetitive access of the object. Repeating object access creates more repetitive code, requires more reading, and creates more opportunities for mistakes. Destructuring objects also provides a single site of definition of the object structure that is used in the block, rather than requiring reading the entire block to determine what is used. 123456789101112131415161718// badfunction getFullName(user) { const firstName = user.firstName; const lastName = user.lastName; return `${firstName} ${lastName}`;}// goodfunction getFullName(user) { const { firstName, lastName } = user; return `${firstName} ${lastName}`;}// bestfunction getFullName({ firstName, lastName }) { return `${firstName} ${lastName}`;} 5.2 Use array destructuring. eslint: prefer-destructuring 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 5.3 Use object destructuring for multiple return values, not array destructuring. Why? You can add new properties over time or change the order of things without breaking call sites. 1234567891011121314151617// badfunction processInput(input) { // then a miracle occurs return [left, right, top, bottom];}// the caller needs to think about the order of return dataconst [left, __, top] = processInput(input);// goodfunction processInput(input) { // then a miracle occurs return { left, right, top, bottom };}// the caller selects only the data they needconst { left, top } = processInput(input); Strings 6.1 Use single quotes '' for strings. eslint: quotes 12345678// badconst name = &quot;Capt. Janeway&quot;;// bad - template literals should contain interpolation or newlinesconst name = `Capt. Janeway`;// goodconst name = 'Capt. Janeway'; 6.2 Strings that cause the line to go over 100 characters should not be written across multiple lines using string concatenation. Why? Broken strings are painful to work with and make code less searchable. 12345678910111213// badconst errorMessage = 'This is a super long error that was thrown because \\of Batman. When you stop to think about how Batman had anything to do \\with this, you would get nowhere \\fast.';// badconst errorMessage = 'This is a super long error that was thrown because ' + 'of Batman. When you stop to think about how Batman had anything to do ' + 'with this, you would get nowhere fast.';// goodconst errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.'; 6.3 When programmatically building up strings, use template strings instead of concatenation. eslint: prefer-template template-curly-spacing Why? Template strings give you a readable, concise syntax with proper newlines and string interpolation features. 12345678910111213141516171819// badfunction sayHi(name) { return 'How are you, ' + name + '?';}// badfunction sayHi(name) { return ['How are you, ', name, '?'].join();}// badfunction sayHi(name) { return `How are you, ${ name }?`;}// goodfunction sayHi(name) { return `How are you, ${name}?`;} 6.4 Never use eval() on a string, it opens too many vulnerabilities. eslint: no-eval 6.5 Do not unnecessarily escape characters in strings. eslint: no-useless-escape Why? Backslashes harm readability, thus they should only be present when necessary. 123456// badconst foo = '\\'this\\' \\i\\s \\&quot;quoted\\&quot;';// goodconst foo = '\\'this\\' is &quot;quoted&quot;';const foo = `my name is '${name}'`; Functions 7.1 Use named function expressions instead of function declarations. eslint: func-style Why? Function declarations are hoisted, which means that it’s easy - too easy - to reference the function before it is defined in the file. This harms readability and maintainability. If you find that a function’s definition is large or complex enough that it is interfering with understanding the rest of the file, then perhaps it’s time to extract it to its own module! Don’t forget to explicitly name the expression, regardless of whether or not the name is inferred from the containing variable (which is often the case in modern browsers or when using compilers such as Babel). This eliminates any assumptions made about the Error’s call stack. (Discussion) 123456789101112131415// badfunction foo() { // ...}// badconst foo = function () { // ...};// good// lexical name distinguished from the variable-referenced invocation(s)const short = function longUniqueMoreDescriptiveLexicalFoo() { // ...}; 7.2 Wrap immediately invoked function expressions in parentheses. eslint: wrap-iife Why? An immediately invoked function expression is a single unit - wrapping both it, and its invocation parens, in parens, cleanly expresses this. Note that in a world with modules everywhere, you almost never need an IIFE. 1234// immediately-invoked function expression (IIFE)(function () { console.log('Welcome to the Internet. Please follow me.');}()); 7.3 Never declare a function in a non-function block (if, while, etc). Assign the function to a variable instead. Browsers will allow you to do it, but they all interpret it differently, which is bad news bears. eslint: no-loop-func 7.4 Note: ECMA-262 defines a block as a list of statements. A function declaration is not a statement. 1234567891011121314// badif (currentUser) { function test() { console.log('Nope.'); }}// goodlet test;if (currentUser) { test = () =&gt; { console.log('Yup.'); };} 7.5 Never name a parameter arguments. This will take precedence over the arguments object that is given to every function scope. 123456789// badfunction foo(name, options, arguments) { // ...}// goodfunction foo(name, options, args) { // ...} 7.6 Never use arguments, opt to use rest syntax ... instead. eslint: prefer-rest-params Why? ... is explicit about which arguments you want pulled. Plus, rest arguments are a real Array, and not merely Array-like like arguments. 12345678910// badfunction concatenateAll() { const args = Array.prototype.slice.call(arguments); return args.join('');}// goodfunction concatenateAll(...args) { return args.join('');} 7.7 Use default parameter syntax rather than mutating function arguments. 123456789101112131415161718192021// really badfunction handleThings(opts) { // No! We shouldn’t mutate function arguments. // Double bad: if opts is falsy it'll be set to an object which may // be what you want but it can introduce subtle bugs. opts = opts || {}; // ...}// still badfunction handleThings(opts) { if (opts === void 0) { opts = {}; } // ...}// goodfunction handleThings(opts = {}) { // ...} 7.8 Avoid side effects with default parameters. Why? They are confusing to reason about. 123456789var b = 1;// badfunction count(a = b++) { console.log(a);}count(); // 1count(); // 2count(3); // 3count(); // 3 7.9 Always put default parameters last. eslint: default-param-last 123456789// badfunction handleThings(opts = {}, name) { // ...}// goodfunction handleThings(name, opts = {}) { // ...} 7.10 Never use the Function constructor to create a new function. eslint: no-new-func Why? Creating a function in this way evaluates a string similarly to eval(), which opens vulnerabilities. 12345// badvar add = new Function('a', 'b', 'return a + b');// still badvar subtract = Function('a', 'b', 'return a - b'); 7.11 Spacing in a function signature. eslint: space-before-function-paren space-before-blocks Why? Consistency is good, and you shouldn’t have to add or remove a space when adding or removing a name. 12345678// badconst f = function(){};const g = function (){};const h = function() {};// goodconst x = function () {};const y = function a() {}; 7.12 Never mutate parameters. eslint: no-param-reassign Why? Manipulating objects passed in as parameters can cause unwanted variable side effects in the original caller. 123456789// badfunction f1(obj) { obj.key = 1;}// goodfunction f2(obj) { const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1;} 7.13 Never reassign parameters. eslint: no-param-reassign Why? Reassigning parameters can lead to unexpected behavior, especially when accessing the arguments object. It can also cause optimization issues, especially in V8. 1234567891011121314151617181920// badfunction f1(a) { a = 1; // ...}function f2(a) { if (!a) { a = 1; } // ...}// goodfunction f3(a) { const b = a || 1; // ...}function f4(a = 1) { // ...} 7.14 Prefer the use of the spread syntax ... to call variadic functions. eslint: prefer-spread Why? It’s cleaner, you don’t need to supply a context, and you can not easily compose new with apply. 12345678910111213// badconst x = [1, 2, 3, 4, 5];console.log.apply(console, x);// goodconst x = [1, 2, 3, 4, 5];console.log(...x);// badnew (Function.prototype.bind.apply(Date, [null, 2016, 8, 5]));// goodnew Date(...[2016, 8, 5]); 7.15 Functions with multiline signatures, or invocations, should be indented just like every other multiline list in this guide: with each item on a line by itself, with a trailing comma on the last item. eslint: function-paren-newline 123456789101112131415161718192021222324252627// badfunction foo(bar, baz, quux) { // ...}// goodfunction foo( bar, baz, quux,) { // ...}// badconsole.log(foo, bar, baz);// goodconsole.log( foo, bar, baz,); Arrow Functions 8.1 When you must use an anonymous function (as when passing an inline callback), use arrow function notation. eslint: prefer-arrow-callback, arrow-spacing Why? It creates a version of the function that executes in the context of this, which is usually what you want, and is a more concise syntax. Why not? If you have a fairly complicated function, you might move that logic out into its own named function expression. 1234567891011// bad[1, 2, 3].map(function (x) { const y = x + 1; return x * y;});// good[1, 2, 3].map((x) =&gt; { const y = x + 1; return x * y;}); 8.2 If the function body consists of a single statement returning an expression without side effects, omit the braces and use the implicit return. Otherwise, keep the braces and use a return statement. eslint: arrow-parens, arrow-body-style Why? Syntactic sugar. It reads well when multiple functions are chained together. 12345678910111213141516171819202122232425262728293031323334353637// bad[1, 2, 3].map((number) =&gt; { const nextNumber = number + 1; `A string containing the ${nextNumber}.`;});// good[1, 2, 3].map((number) =&gt; `A string containing the ${number + 1}.`);// good[1, 2, 3].map((number) =&gt; { const nextNumber = number + 1; return `A string containing the ${nextNumber}.`;});// good[1, 2, 3].map((number, index) =&gt; ({ [index]: number,}));// No implicit return with side effectsfunction foo(callback) { const val = callback(); if (val === true) { // Do something if callback returns true }}let bool = false;// badfoo(() =&gt; bool = true);// goodfoo(() =&gt; { bool = true;}); 8.3 In case the expression spans over multiple lines, wrap it in parentheses for better readability. Why? It shows clearly where the function starts and ends. 1234567891011121314// bad['get', 'post', 'put'].map((httpMethod) =&gt; Object.prototype.hasOwnProperty.call( httpMagicObjectWithAVeryLongName, httpMethod, ));// good['get', 'post', 'put'].map((httpMethod) =&gt; ( Object.prototype.hasOwnProperty.call( httpMagicObjectWithAVeryLongName, httpMethod, ))); 8.4 Always include parentheses around arguments for clarity and consistency. eslint: arrow-parens Why? Minimizes diff churn when adding or removing arguments. 123456789101112131415161718192021222324252627// bad[1, 2, 3].map(x =&gt; x * x);// good[1, 2, 3].map((x) =&gt; x * x);// bad[1, 2, 3].map(number =&gt; ( `A long string with the ${number}. It’s so long that we don’t want it to take up space on the .map line!`));// good[1, 2, 3].map((number) =&gt; ( `A long string with the ${number}. It’s so long that we don’t want it to take up space on the .map line!`));// bad[1, 2, 3].map(x =&gt; { const y = x + 1; return x * y;});// good[1, 2, 3].map((x) =&gt; { const y = x + 1; return x * y;}); 8.5 Avoid confusing arrow function syntax (=&gt;) with comparison operators (&lt;=, &gt;=). eslint: no-confusing-arrow 1234567891011121314// badconst itemHeight = (item) =&gt; item.height &lt;= 256 ? item.largeSize : item.smallSize;// badconst itemHeight = (item) =&gt; item.height &gt;= 256 ? item.largeSize : item.smallSize;// goodconst itemHeight = (item) =&gt; (item.height &lt;= 256 ? item.largeSize : item.smallSize);// goodconst itemHeight = (item) =&gt; { const { height, largeSize, smallSize } = item; return height &lt;= 256 ? largeSize : smallSize;}; 8.6 Enforce the location of arrow function bodies with implicit returns. eslint: implicit-arrow-linebreak 12345678910111213// bad(foo) =&gt; bar;(foo) =&gt; (bar);// good(foo) =&gt; bar;(foo) =&gt; (bar);(foo) =&gt; ( bar) Classes &amp; Constructors 9.1 Always use class. Avoid manipulating prototype directly. Why? class syntax is more concise and easier to reason about. 123456789101112131415161718192021// badfunction Queue(contents = []) { this.queue = [...contents];}Queue.prototype.pop = function () { const value = this.queue[0]; this.queue.splice(0, 1); return value;};// goodclass Queue { constructor(contents = []) { this.queue = [...contents]; } pop() { const value = this.queue[0]; this.queue.splice(0, 1); return value; }} 9.2 Use extends for inheritance. Why? It is a built-in way to inherit prototype functionality without breaking instanceof. 12345678910111213141516// badconst inherits = require('inherits');function PeekableQueue(contents) { Queue.apply(this, contents);}inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function () { return this.queue[0];};// goodclass PeekableQueue extends Queue { peek() { return this.queue[0]; }} 9.3 Methods can return this to help with method chaining. 12345678910111213141516171819202122232425262728293031// badJedi.prototype.jump = function () { this.jumping = true; return true;};Jedi.prototype.setHeight = function (height) { this.height = height;};const luke = new Jedi();luke.jump(); // =&gt; trueluke.setHeight(20); // =&gt; undefined// goodclass Jedi { jump() { this.jumping = true; return this; } setHeight(height) { this.height = height; return this; }}const luke = new Jedi();luke.jump() .setHeight(20); 9.4 It’s okay to write a custom toString() method, just make sure it works successfully and causes no side effects. 12345678910111213class Jedi { constructor(options = {}) { this.name = options.name || 'no name'; } getName() { return this.name; } toString() { return `Jedi - ${this.getName()}`; }} 9.5 Classes have a default constructor if one is not specified. An empty constructor function or one that just delegates to a parent class is unnecessary. eslint: no-useless-constructor 1234567891011121314151617181920212223// badclass Jedi { constructor() {} getName() { return this.name; }}// badclass Rey extends Jedi { constructor(...args) { super(...args); }}// goodclass Rey extends Jedi { constructor(...args) { super(...args); this.name = 'Rey'; }} 9.6 Avoid duplicate class members. eslint: no-dupe-class-members Why? Duplicate class member declarations will silently prefer the last one - having duplicates is almost certainly a bug. 123456789101112131415// badclass Foo { bar() { return 1; } bar() { return 2; }}// goodclass Foo { bar() { return 1; }}// goodclass Foo { bar() { return 2; }} 9.7 Class methods should use this or be made into a static method unless an external library or framework requires to use specific non-static methods. Being an instance method should indicate that it behaves differently based on properties of the receiver. eslint: class-methods-use-this 123456789101112131415161718192021222324252627// badclass Foo { bar() { console.log('bar'); }}// good - this is usedclass Foo { bar() { console.log(this.bar); }}// good - constructor is exemptclass Foo { constructor() { // ... }}// good - static methods aren't expected to use thisclass Foo { static bar() { console.log('bar'); }} Modules 10.1 Always use modules (import/export) over a non-standard module system. You can always transpile to your preferred module system. Why? Modules are the future, let’s start using the future now. 1234567891011// badconst AirbnbStyleGuide = require('./AirbnbStyleGuide');module.exports = AirbnbStyleGuide.es6;// okimport AirbnbStyleGuide from './AirbnbStyleGuide';export default AirbnbStyleGuide.es6;// bestimport { es6 } from './AirbnbStyleGuide';export default es6; 10.2 Do not use wildcard imports. Why? This makes sure you have a single default export. 12345// badimport * as AirbnbStyleGuide from './AirbnbStyleGuide';// goodimport AirbnbStyleGuide from './AirbnbStyleGuide'; 10.3 And do not export directly from an import. Why? Although the one-liner is concise, having one clear way to import and one clear way to export makes things consistent. 12345678// bad// filename es6.jsexport { es6 as default } from './AirbnbStyleGuide';// good// filename es6.jsimport { es6 } from './AirbnbStyleGuide';export default es6; 10.4 Only import from a path in one place.eslint: no-duplicate-imports Why? Having multiple lines that import from the same path can make code harder to maintain. 12345678910111213// badimport foo from 'foo';// … some other imports … //import { named1, named2 } from 'foo';// goodimport foo, { named1, named2 } from 'foo';// goodimport foo, { named1, named2,} from 'foo'; 10.5 Do not export mutable bindings.eslint: import/no-mutable-exports Why? Mutation should be avoided in general, but in particular when exporting mutable bindings. While this technique may be needed for some special cases, in general, only constant references should be exported. 1234567// badlet foo = 3;export { foo };// goodconst foo = 3;export { foo }; 10.6 In modules with a single export, prefer default export over named export.eslint: import/prefer-default-export Why? To encourage more files that only ever export one thing, which is better for readability and maintainability. 12345// badexport function foo() {}// goodexport default function foo() {} 10.7 Put all imports above non-import statements.eslint: import/first Why? Since imports are hoisted, keeping them all at the top prevents surprising behavior. 1234567891011// badimport foo from 'foo';foo.init();import bar from 'bar';// goodimport foo from 'foo';import bar from 'bar';foo.init(); 10.8 Multiline imports should be indented just like multiline array and object literals.eslint: object-curly-newline Why? The curly braces follow the same indentation rules as every other curly brace block in the style guide, as do the trailing commas. 1234567891011// badimport {longNameA, longNameB, longNameC, longNameD, longNameE} from 'path';// goodimport { longNameA, longNameB, longNameC, longNameD, longNameE,} from 'path'; 10.9 Disallow Webpack loader syntax in module import statements.eslint: import/no-webpack-loader-syntax Why? Since using Webpack syntax in the imports couples the code to a module bundler. Prefer using the loader syntax in webpack.config.js. 1234567// badimport fooSass from 'css!sass!foo.scss';import barCss from 'style!css!bar.css';// goodimport fooSass from 'foo.scss';import barCss from 'bar.css'; 10.10 Do not include JavaScript filename extensionseslint: import/extensions Why? Including extensions inhibits refactoring, and inappropriately hardcodes implementation details of the module you’re importing in every consumer. 123456789// badimport foo from './foo.js';import bar from './bar.jsx';import baz from './baz/index.jsx';// goodimport foo from './foo';import bar from './bar';import baz from './baz'; Iterators and Generators 11.1 Don’t use iterators. Prefer JavaScript’s higher-order functions instead of loops like for-in or for-of. eslint: no-iterator no-restricted-syntax Why? This enforces our immutable rule. Dealing with pure functions that return values is easier to reason about than side effects. Use map() / every() / filter() / find() / findIndex() / reduce() / some() / … to iterate over arrays, and Object.keys() / Object.values() / Object.entries() to produce arrays so you can iterate over objects. 12345678910111213141516171819202122232425262728293031323334const numbers = [1, 2, 3, 4, 5];// badlet sum = 0;for (let num of numbers) { sum += num;}sum === 15;// goodlet sum = 0;numbers.forEach((num) =&gt; { sum += num;});sum === 15;// best (use the functional force)const sum = numbers.reduce((total, num) =&gt; total + num, 0);sum === 15;// badconst increasedByOne = [];for (let i = 0; i &lt; numbers.length; i++) { increasedByOne.push(numbers[i] + 1);}// goodconst increasedByOne = [];numbers.forEach((num) =&gt; { increasedByOne.push(num + 1);});// best (keeping it functional)const increasedByOne = numbers.map((num) =&gt; num + 1); 11.2 Don’t use generators for now. Why? They don’t transpile well to ES5. 11.3 If you must use generators, or if you disregard our advice, make sure their function signature is spaced properly. eslint: generator-star-spacing Why? function and * are part of the same conceptual keyword - * is not a modifier for function, function* is a unique construct, different from function. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// badfunction * foo() { // ...}// badconst bar = function * () { // ...};// badconst baz = function *() { // ...};// badconst quux = function*() { // ...};// badfunction*foo() { // ...}// badfunction *foo() { // ...}// very badfunction*foo() { // ...}// very badconst wat = function*() { // ...};// goodfunction* foo() { // ...}// goodconst foo = function* () { // ...}; Properties 12.1 Use dot notation when accessing properties. eslint: dot-notation 12345678910const luke = { jedi: true, age: 28,};// badconst isJedi = luke['jedi'];// goodconst isJedi = luke.jedi; 12.2 Use bracket notation [] when accessing properties with a variable. 12345678910const luke = { jedi: true, age: 28,};function getProp(prop) { return luke[prop];}const isJedi = getProp('jedi'); 12.3 Use exponentiation operator ** when calculating exponentiations. eslint: no-restricted-properties. 12345// badconst binary = Math.pow(2, 10);// goodconst binary = 2 ** 10; Variables 13.1 Always use const or let to declare variables. Not doing so will result in global variables. We want to avoid polluting the global namespace. Captain Planet warned us of that. eslint: no-undef prefer-const 12345// badsuperPower = new SuperPower();// goodconst superPower = new SuperPower(); 13.2 Use one const or let declaration per variable or assignment. eslint: one-var Why? It’s easier to add new variable declarations this way, and you never have to worry about swapping out a ; for a , or introducing punctuation-only diffs. You can also step through each declaration with the debugger, instead of jumping through all of them at once. 123456789101112131415// badconst items = getItems(), goSportsTeam = true, dragonball = 'z';// bad// (compare to above, and try to spot the mistake)const items = getItems(), goSportsTeam = true; dragonball = 'z';// goodconst items = getItems();const goSportsTeam = true;const dragonball = 'z'; 13.3 Group all your consts and then group all your lets. Why? This is helpful when later on you might need to assign a variable depending on one of the previously assigned variables. 123456789101112131415161718// badlet i, len, dragonball, items = getItems(), goSportsTeam = true;// badlet i;const items = getItems();let dragonball;const goSportsTeam = true;let len;// goodconst goSportsTeam = true;const items = getItems();let dragonball;let i;let length; 13.4 Assign variables where you need them, but place them in a reasonable place. Why? let and const are block scoped and not function scoped. 12345678910111213141516171819202122232425262728293031// bad - unnecessary function callfunction checkName(hasName) { const name = getName(); if (hasName === 'test') { return false; } if (name === 'test') { this.setName(''); return false; } return name;}// goodfunction checkName(hasName) { if (hasName === 'test') { return false; } const name = getName(); if (name === 'test') { this.setName(''); return false; } return name;} 13.5 Don’t chain variable assignments. eslint: no-multi-assign Why? Chaining variable assignments creates implicit global variables. 12345678910111213141516171819202122232425// bad(function example() { // JavaScript interprets this as // let a = ( b = ( c = 1 ) ); // The let keyword only applies to variable a; variables b and c become // global variables. let a = b = c = 1;}());console.log(a); // throws ReferenceErrorconsole.log(b); // 1console.log(c); // 1// good(function example() { let a = 1; let b = a; let c = a;}());console.log(a); // throws ReferenceErrorconsole.log(b); // throws ReferenceErrorconsole.log(c); // throws ReferenceError// the same applies for `const` 13.6 Avoid using unary increments and decrements (++, --). eslint no-plusplus Why? Per the eslint documentation, unary increment and decrement statements are subject to automatic semicolon insertion and can cause silent errors with incrementing or decrementing values within an application. It is also more expressive to mutate your values with statements like num += 1 instead of num++ or num ++. Disallowing unary increment and decrement statements also prevents you from pre-incrementing/pre-decrementing values unintentionally which can also cause unexpected behavior in your programs. 1234567891011121314151617181920212223242526// badconst array = [1, 2, 3];let num = 1;num++;--num;let sum = 0;let truthyCount = 0;for (let i = 0; i &lt; array.length; i++) { let value = array[i]; sum += value; if (value) { truthyCount++; }}// goodconst array = [1, 2, 3];let num = 1;num += 1;num -= 1;const sum = array.reduce((a, b) =&gt; a + b, 0);const truthyCount = array.filter(Boolean).length; 13.7 Avoid linebreaks before or after = in an assignment. If your assignment violates max-len, surround the value in parens. eslint operator-linebreak. Why? Linebreaks surrounding = can obfuscate the value of an assignment. 123456789101112131415// badconst foo = superLongLongLongLongLongLongLongLongFunctionName();// badconst foo = 'superLongLongLongLongLongLongLongLongString';// goodconst foo = ( superLongLongLongLongLongLongLongLongFunctionName());// goodconst foo = 'superLongLongLongLongLongLongLongLongString'; 13.8 Disallow unused variables. eslint: no-unused-vars Why? Variables that are declared and not used anywhere in the code are most likely an error due to incomplete refactoring. Such variables take up space in the code and can lead to confusion by readers. 1234567891011121314151617181920212223242526272829303132// badvar some_unused_var = 42;// Write-only variables are not considered as used.var y = 10;y = 5;// A read for a modification of itself is not considered as used.var z = 0;z = z + 1;// Unused function arguments.function getX(x, y) { return x;}// goodfunction getXPlusY(x, y) { return x + y;}var x = 1;var y = a + 2;alert(getXPlusY(x, y));// 'type' is ignored even if unused because it has a rest property sibling.// This is a form of extracting an object that omits the specified keys.var { type, ...coords } = data;// 'coords' is now the 'data' object without its 'type' property. Hoisting 14.1 var declarations get hoisted to the top of their closest enclosing function scope, their assignment does not. const and let declarations are blessed with a new concept called Temporal Dead Zones (TDZ). It’s important to know why typeof is no longer safe. 123456789101112131415161718192021222324252627282930// we know this wouldn’t work (assuming there// is no notDefined global variable)function example() { console.log(notDefined); // =&gt; throws a ReferenceError}// creating a variable declaration after you// reference the variable will work due to// variable hoisting. Note: the assignment// value of `true` is not hoisted.function example() { console.log(declaredButNotAssigned); // =&gt; undefined var declaredButNotAssigned = true;}// the interpreter is hoisting the variable// declaration to the top of the scope,// which means our example could be rewritten as:function example() { let declaredButNotAssigned; console.log(declaredButNotAssigned); // =&gt; undefined declaredButNotAssigned = true;}// using const and letfunction example() { console.log(declaredButNotAssigned); // =&gt; throws a ReferenceError console.log(typeof declaredButNotAssigned); // =&gt; throws a ReferenceError const declaredButNotAssigned = true;} 14.2 Anonymous function expressions hoist their variable name, but not the function assignment. 123456789function example() { console.log(anonymous); // =&gt; undefined anonymous(); // =&gt; TypeError anonymous is not a function var anonymous = function () { console.log('anonymous function expression'); };} 14.3 Named function expressions hoist the variable name, not the function name or the function body. 1234567891011121314151617181920212223function example() { console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function superPower(); // =&gt; ReferenceError superPower is not defined var named = function superPower() { console.log('Flying'); };}// the same is true when the function name// is the same as the variable name.function example() { console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function var named = function named() { console.log('named'); };} 14.4 Function declarations hoist their name and the function body. 1234567function example() { superPower(); // =&gt; Flying function superPower() { console.log('Flying'); }} For more information refer to JavaScript Scoping &amp; Hoisting by Ben Cherry. Comparison Operators &amp; Equality 15.1 Use === and !== over == and !=. eslint: eqeqeq 15.2 Conditional statements such as the if statement evaluate their expression using coercion with the ToBoolean abstract method and always follow these simple rules: Objects evaluate to true Undefined evaluates to false Null evaluates to false Booleans evaluate to the value of the boolean Numbers evaluate to false if +0, -0, or NaN, otherwise true Strings evaluate to false if an empty string '', otherwise true 1234if ([0] &amp;&amp; []) { // true // an array (even an empty one) is an object, objects will evaluate to true} 15.3 Use shortcuts for booleans, but explicit comparisons for strings and numbers. 1234567891011121314151617181920212223242526272829// badif (isValid === true) { // ...}// goodif (isValid) { // ...}// badif (name) { // ...}// goodif (name !== '') { // ...}// badif (collection.length) { // ...}// goodif (collection.length &gt; 0) { // ...} 15.4 For more information see Truth Equality and JavaScript by Angus Croll. 15.5 Use braces to create blocks in case and default clauses that contain lexical declarations (e.g. let, const, function, and class). eslint: no-case-declarations Why? Lexical declarations are visible in the entire switch block but only get initialized when assigned, which only happens when its case is reached. This causes problems when multiple case clauses attempt to define the same thing. 12345678910111213141516171819202122232425262728293031323334353637383940// badswitch (foo) { case 1: let x = 1; break; case 2: const y = 2; break; case 3: function f() { // ... } break; default: class C {}}// goodswitch (foo) { case 1: { let x = 1; break; } case 2: { const y = 2; break; } case 3: { function f() { // ... } break; } case 4: bar(); break; default: { class C {} }} 15.6 Ternaries should not be nested and generally be single line expressions. eslint: no-nested-ternary 123456789101112131415// badconst foo = maybe1 &gt; maybe2 ? &quot;bar&quot; : value1 &gt; value2 ? &quot;baz&quot; : null;// split into 2 separated ternary expressionsconst maybeNull = value1 &gt; value2 ? 'baz' : null;// betterconst foo = maybe1 &gt; maybe2 ? 'bar' : maybeNull;// bestconst foo = maybe1 &gt; maybe2 ? 'bar' : maybeNull; 15.7 Avoid unneeded ternary statements. eslint: no-unneeded-ternary 123456789// badconst foo = a ? a : b;const bar = c ? true : false;const baz = c ? false : true;// goodconst foo = a || b;const bar = !!c;const baz = !c; 15.8 When mixing operators, enclose them in parentheses. The only exception is the standard arithmetic operators: +, -, and ** since their precedence is broadly understood. We recommend enclosing / and * in parentheses because their precedence can be ambiguous when they are mixed.eslint: no-mixed-operators Why? This improves readability and clarifies the developer’s intention. 12345678910111213141516171819202122232425262728// badconst foo = a &amp;&amp; b &lt; 0 || c &gt; 0 || d + 1 === 0;// badconst bar = a ** b - 5 % d;// bad// one may be confused into thinking (a || b) &amp;&amp; cif (a || b &amp;&amp; c) { return d;}// badconst bar = a + b / c * d;// goodconst foo = (a &amp;&amp; b &lt; 0) || c &gt; 0 || (d + 1 === 0);// goodconst bar = a ** b - (5 % d);// goodif (a || (b &amp;&amp; c)) { return d;}// goodconst bar = a + (b / c) * d; Blocks 16.1 Use braces with all multiline blocks. eslint: nonblock-statement-body-position 12345678910111213141516171819// badif (test) return false;// goodif (test) return false;// goodif (test) { return false;}// badfunction foo() { return false; }// goodfunction bar() { return false;} 16.2 If you’re using multiline blocks with if and else, put else on the same line as your if block’s closing brace. eslint: brace-style 12345678910111213141516// badif (test) { thing1(); thing2();}else { thing3();}// goodif (test) { thing1(); thing2();} else { thing3();} 16.3 If an if block always executes a return statement, the subsequent else block is unnecessary. A return in an else if block following an if block that contains a return can be separated into multiple if blocks. eslint: no-else-return 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// badfunction foo() { if (x) { return x; } else { return y; }}// badfunction cats() { if (x) { return x; } else if (y) { return y; }}// badfunction dogs() { if (x) { return x; } else { if (y) { return y; } }}// goodfunction foo() { if (x) { return x; } return y;}// goodfunction cats() { if (x) { return x; } if (y) { return y; }}// goodfunction dogs(x) { if (x) { if (z) { return y; } } else { return z; }} Control Statements 17.1 In case your control statement (if, while etc.) gets too long or exceeds the maximum line length, each (grouped) condition could be put into a new line. The logical operator should begin the line. Why? Requiring operators at the beginning of the line keeps the operators aligned and follows a pattern similar to method chaining. This also improves readability by making it easier to visually follow complex logic. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// badif ((foo === 123 || bar === 'abc') &amp;&amp; doesItLookGoodWhenItBecomesThatLong() &amp;&amp; isThisReallyHappening()) { thing1();}// badif (foo === 123 &amp;&amp; bar === 'abc') { thing1();}// badif (foo === 123 &amp;&amp; bar === 'abc') { thing1();}// badif ( foo === 123 &amp;&amp; bar === 'abc') { thing1();}// goodif ( foo === 123 &amp;&amp; bar === 'abc') { thing1();}// goodif ( (foo === 123 || bar === 'abc') &amp;&amp; doesItLookGoodWhenItBecomesThatLong() &amp;&amp; isThisReallyHappening()) { thing1();}// goodif (foo === 123 &amp;&amp; bar === 'abc') { thing1();} 17.2 Don’t use selection operators in place of control statements. 1234567// bad!isRunning &amp;&amp; startRunning();// goodif (!isRunning) { startRunning();} Comments 18.1 Use /** ... */ for multiline comments. 123456789101112131415161718192021222324// bad// make() returns a new element// based on the passed in tag name//// @param {String} tag// @return {Element} elementfunction make(tag) { // ... return element;}// good/** * make() returns a new element * based on the passed-in tag name */function make(tag) { // ... return element;} 18.2 Use // for single line comments. Place single line comments on a newline above the subject of the comment. Put an empty line before the comment unless it’s on the first line of a block. 123456789101112131415161718192021222324252627282930313233// badconst active = true; // is current tab// good// is current tabconst active = true;// badfunction getType() { console.log('fetching type...'); // set the default type to 'no type' const type = this.type || 'no type'; return type;}// goodfunction getType() { console.log('fetching type...'); // set the default type to 'no type' const type = this.type || 'no type'; return type;}// also goodfunction getType() { // set the default type to 'no type' const type = this.type || 'no type'; return type;} 18.3 Start all comments with a space to make it easier to read. eslint: spaced-comment 12345678910111213141516171819202122232425262728293031// bad//is current tabconst active = true;// good// is current tabconst active = true;// bad/** *make() returns a new element *based on the passed-in tag name */function make(tag) { // ... return element;}// good/** * make() returns a new element * based on the passed-in tag name */function make(tag) { // ... return element;} 18.4 Prefixing your comments with FIXME or TODO helps other developers quickly understand if you’re pointing out a problem that needs to be revisited, or if you’re suggesting a solution to the problem that needs to be implemented. These are different than regular comments because they are actionable. The actions are FIXME: -- need to figure this out or TODO: -- need to implement. 18.5 Use // FIXME: to annotate problems. 12345678class Calculator extends Abacus { constructor() { super(); // FIXME: shouldn’t use a global here total = 0; }} 18.6 Use // TODO: to annotate solutions to problems. 12345678class Calculator extends Abacus { constructor() { super(); // TODO: total should be configurable by an options param this.total = 0; }} Whitespace 19.1 Use soft tabs (space character) set to 2 spaces. eslint: indent 1234567891011121314// badfunction foo() {∙∙∙∙let name;}// badfunction bar() {∙let name;}// goodfunction baz() {∙∙let name;} 19.2 Place 1 space before the leading brace. eslint: space-before-blocks 123456789101112131415161718192021// badfunction test(){ console.log('test');}// goodfunction test() { console.log('test');}// baddog.set('attr',{ age: '1 year', breed: 'Bernese Mountain Dog',});// gooddog.set('attr', { age: '1 year', breed: 'Bernese Mountain Dog',}); 19.3 Place 1 space before the opening parenthesis in control statements (if, while etc.). Place no space between the argument list and the function name in function calls and declarations. eslint: keyword-spacing 12345678910111213141516171819// badif(isJedi) { fight ();}// goodif (isJedi) { fight();}// badfunction fight () { console.log ('Swooosh!');}// goodfunction fight() { console.log('Swooosh!');} 19.4 Set off operators with spaces. eslint: space-infix-ops 12345// badconst x=y+5;// goodconst x = y + 5; 19.5 End files with a single newline character. eslint: eol-last 1234// badimport { es6 } from './AirbnbStyleGuide'; // ...export default es6; 12345// badimport { es6 } from './AirbnbStyleGuide'; // ...export default es6;↵↵ 1234// goodimport { es6 } from './AirbnbStyleGuide'; // ...export default es6;↵ 19.6 Use indentation when making long method chains (more than 2 method chains). Use a leading dot, whichemphasizes that the line is a method call, not a new statement. eslint: newline-per-chained-call no-whitespace-before-property 1234567891011121314151617181920212223242526272829303132333435363738394041// bad$('#items').find('.selected').highlight().end().find('.open').updateCount();// bad$('#items'). find('.selected'). highlight(). end(). find('.open'). updateCount();// good$('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount();// badconst leds = stage.selectAll('.led').data(data).enter().append('svg:svg').classed('led', true) .attr('width', (radius + margin) * 2).append('svg:g') .attr('transform', `translate(${radius + margin},${radius + margin})`) .call(tron.led);// goodconst leds = stage.selectAll('.led') .data(data) .enter().append('svg:svg') .classed('led', true) .attr('width', (radius + margin) * 2) .append('svg:g') .attr('transform', `translate(${radius + margin},${radius + margin})`) .call(tron.led);// goodconst leds = stage.selectAll('.led').data(data);const svg = leds.enter().append('svg:svg');svg.classed('led', true).attr('width', (radius + margin) * 2);const g = svg.append('svg:g');g.attr('transform', `translate(${radius + margin},${radius + margin})`).call(tron.led); 19.7 Leave a blank line after blocks and before the next statement. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// badif (foo) { return bar;}return baz;// goodif (foo) { return bar;}return baz;// badconst obj = { foo() { }, bar() { },};return obj;// goodconst obj = { foo() { }, bar() { },};return obj;// badconst arr = [ function foo() { }, function bar() { },];return arr;// goodconst arr = [ function foo() { }, function bar() { },];return arr; 19.8 Do not pad your blocks with blank lines. eslint: padded-blocks 1234567891011121314151617181920212223242526272829303132333435// badfunction bar() { console.log(foo);}// badif (baz) { console.log(qux);} else { console.log(foo);}// badclass Foo { constructor(bar) { this.bar = bar; }}// goodfunction bar() { console.log(foo);}// goodif (baz) { console.log(qux);} else { console.log(foo);} 19.9 Do not use multiple blank lines to pad your code. eslint: no-multiple-empty-lines 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// badclass Person { constructor(fullName, email, birthday) { this.fullName = fullName; this.email = email; this.setAge(birthday); } setAge(birthday) { const today = new Date(); const age = this.getAge(today, birthday); this.age = age; } getAge(today, birthday) { // .. }}// goodclass Person { constructor(fullName, email, birthday) { this.fullName = fullName; this.email = email; this.setAge(birthday); } setAge(birthday) { const today = new Date(); const age = getAge(today, birthday); this.age = age; } getAge(today, birthday) { // .. }} 19.10 Do not add spaces inside parentheses. eslint: space-in-parens 12345678910111213141516171819// badfunction bar( foo ) { return foo;}// goodfunction bar(foo) { return foo;}// badif ( foo ) { console.log(foo);}// goodif (foo) { console.log(foo);} 19.11 Do not add spaces inside brackets. eslint: array-bracket-spacing 1234567// badconst foo = [ 1, 2, 3 ];console.log(foo[ 0 ]);// goodconst foo = [1, 2, 3];console.log(foo[0]); 19.12 Add spaces inside curly braces. eslint: object-curly-spacing 12345// badconst foo = {clark: 'kent'};// goodconst foo = { clark: 'kent' }; 19.13 Avoid having lines of code that are longer than 100 characters (including whitespace). Note: per above, long strings are exempt from this rule, and should not be broken up. eslint: max-len Why? This ensures readability and maintainability. 12345678910111213141516171819202122// badconst foo = jsonData &amp;&amp; jsonData.foo &amp;&amp; jsonData.foo.bar &amp;&amp; jsonData.foo.bar.baz &amp;&amp; jsonData.foo.bar.baz.quux &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy;// bad$.ajax({ method: 'POST', url: 'https://airbnb.com/', data: { name: 'John' } }).done(() =&gt; console.log('Congratulations!')).fail(() =&gt; console.log('You have failed this city.'));// goodconst foo = jsonData &amp;&amp; jsonData.foo &amp;&amp; jsonData.foo.bar &amp;&amp; jsonData.foo.bar.baz &amp;&amp; jsonData.foo.bar.baz.quux &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy;// good$.ajax({ method: 'POST', url: 'https://airbnb.com/', data: { name: 'John' },}) .done(() =&gt; console.log('Congratulations!')) .fail(() =&gt; console.log('You have failed this city.')); 19.14 Require consistent spacing inside an open block token and the next token on the same line. This rule also enforces consistent spacing inside a close block token and previous token on the same line. eslint: block-spacing 1234567// badfunction foo() {return true;}if (foo) { bar = 0;}// goodfunction foo() { return true; }if (foo) { bar = 0; } 19.15 Avoid spaces before commas and require a space after commas. eslint: comma-spacing 1234567// badvar foo = 1,bar = 2;var arr = [1 , 2];// goodvar foo = 1, bar = 2;var arr = [1, 2]; 19.16 Enforce spacing inside of computed property brackets. eslint: computed-property-spacing 1234567891011// badobj[foo ]obj[ 'foo']var x = {[ b ]: a}obj[foo[ bar ]]// goodobj[foo]obj['foo']var x = { [b]: a }obj[foo[bar]] 19.17 Avoid spaces between functions and their invocations. eslint: func-call-spacing 12345678// badfunc ();func();// goodfunc(); 19.18 Enforce spacing between keys and values in object literal properties. eslint: key-spacing 123456// badvar obj = { foo : 42 };var obj2 = { foo:42 };// goodvar obj = { foo: 42 }; 19.19 Avoid trailing spaces at the end of lines. eslint: no-trailing-spaces 19.20 Avoid multiple empty lines, only allow one newline at the end of files, and avoid a newline at the beginning of files. eslint: no-multiple-empty-lines 1234567891011121314151617181920// bad - multiple empty linesvar x = 1;var y = 2;// bad - 2+ newlines at end of filevar x = 1;var y = 2;// bad - 1+ newline(s) at beginning of filevar x = 1;var y = 2;// goodvar x = 1;var y = 2; Commas 20.1 Leading commas: Nope. eslint: comma-style 1234567891011121314151617181920212223242526272829// badconst story = [ once , upon , aTime];// goodconst story = [ once, upon, aTime,];// badconst hero = { firstName: 'Ada' , lastName: 'Lovelace' , birthYear: 1815 , superPower: 'computers'};// goodconst hero = { firstName: 'Ada', lastName: 'Lovelace', birthYear: 1815, superPower: 'computers',}; 20.2 Additional trailing comma: Yup. eslint: comma-dangle Why? This leads to cleaner git diffs. Also, transpilers like Babel will remove the additional trailing comma in the transpiled code which means you don’t have to worry about the trailing comma problem in legacy browsers. 1234567891011121314// bad - git diff without trailing commaconst hero = { firstName: 'Florence',- lastName: 'Nightingale'+ lastName: 'Nightingale',+ inventorOf: ['coxcomb chart', 'modern nursing']};// good - git diff with trailing commaconst hero = { firstName: 'Florence', lastName: 'Nightingale',+ inventorOf: ['coxcomb chart', 'modern nursing'],}; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// badconst hero = { firstName: 'Dana', lastName: 'Scully'};const heroes = [ 'Batman', 'Superman'];// goodconst hero = { firstName: 'Dana', lastName: 'Scully',};const heroes = [ 'Batman', 'Superman',];// badfunction createHero( firstName, lastName, inventorOf) { // does nothing}// goodfunction createHero( firstName, lastName, inventorOf,) { // does nothing}// good (note that a comma must not appear after a &quot;rest&quot; element)function createHero( firstName, lastName, inventorOf, ...heroArgs) { // does nothing}// badcreateHero( firstName, lastName, inventorOf);// goodcreateHero( firstName, lastName, inventorOf,);// good (note that a comma must not appear after a &quot;rest&quot; element)createHero( firstName, lastName, inventorOf, ...heroArgs); Semicolons 21.1 Yup. eslint: semi Why? When JavaScript encounters a line break without a semicolon, it uses a set of rules called Automatic Semicolon Insertion to determine whether or not it should regard that line break as the end of a statement, and (as the name implies) place a semicolon into your code before the line break if it thinks so. ASI contains a few eccentric behaviors, though, and your code will break if JavaScript misinterprets your line break. These rules will become more complicated as new features become a part of JavaScript. Explicitly terminating your statements and configuring your linter to catch missing semicolons will help prevent you from encountering issues. 123456789101112131415161718192021222324252627282930313233343536// bad - raises exceptionconst luke = {}const leia = {}[luke, leia].forEach((jedi) =&gt; jedi.father = 'vader')// bad - raises exceptionconst reaction = &quot;No! That’s impossible!&quot;(async function meanwhileOnTheFalcon() { // handle `leia`, `lando`, `chewie`, `r2`, `c3p0` // ...}())// bad - returns `undefined` instead of the value on the next line - always happens when `return` is on a line by itself because of ASI!function foo() { return 'search your feelings, you know it to be foo'}// goodconst luke = {};const leia = {};[luke, leia].forEach((jedi) =&gt; { jedi.father = 'vader';});// goodconst reaction = &quot;No! That’s impossible!&quot;;(async function meanwhileOnTheFalcon() { // handle `leia`, `lando`, `chewie`, `r2`, `c3p0` // ...}());// goodfunction foo() { return 'search your feelings, you know it to be foo';} Read more. Type Casting &amp; Coercion 22.1 Perform type coercion at the beginning of the statement. 22.2 Strings: eslint: no-new-wrappers 12345678910111213// =&gt; this.reviewScore = 9;// badconst totalScore = new String(this.reviewScore); // typeof totalScore is &quot;object&quot; not &quot;string&quot;// badconst totalScore = this.reviewScore + ''; // invokes this.reviewScore.valueOf()// badconst totalScore = this.reviewScore.toString(); // isn’t guaranteed to return a string// goodconst totalScore = String(this.reviewScore); 22.3 Numbers: Use Number for type casting and parseInt always with a radix for parsing strings. eslint: radix no-new-wrappers Why? The parseInt function produces an integer value dictated by interpretation of the contents of the string argument according to the specified radix. Leading whitespace in string is ignored. If radix is undefined or 0, it is assumed to be 10 except when the number begins with the character pairs 0x or 0X, in which case a radix of 16 is assumed. This differs from ECMAScript 3, which merely discouraged (but allowed) octal interpretation. Many implementations have not adopted this behavior as of 2013. And, because older browsers must be supported, always specify a radix. 12345678910111213141516171819const inputValue = '4';// badconst val = new Number(inputValue);// badconst val = +inputValue;// badconst val = inputValue &gt;&gt; 0;// badconst val = parseInt(inputValue);// goodconst val = Number(inputValue);// goodconst val = parseInt(inputValue, 10); 22.4 If for whatever reason you are doing something wild and parseInt is your bottleneck and need to use Bitshift for performance reasons, leave a comment explaining why and what you’re doing. 1234567// good/** * parseInt was the reason my code was slow. * Bitshifting the String to coerce it to a * Number made it a lot faster. */const val = inputValue &gt;&gt; 0; 22.5 Note: Be careful when using bitshift operations. Numbers are represented as 64-bit values, but bitshift operations always return a 32-bit integer (source). Bitshift can lead to unexpected behavior for integer values larger than 32 bits. Discussion. Largest signed 32-bit Int is 2,147,483,647: 1232147483647 &gt;&gt; 0; // =&gt; 21474836472147483648 &gt;&gt; 0; // =&gt; -21474836482147483649 &gt;&gt; 0; // =&gt; -2147483647 22.6 Booleans: eslint: no-new-wrappers 12345678910const age = 0;// badconst hasAge = new Boolean(age);// goodconst hasAge = Boolean(age);// bestconst hasAge = !!age; Naming Conventions 23.1 Avoid single letter names. Be descriptive with your naming. eslint: id-length 123456789// badfunction q() { // ...}// goodfunction query() { // ...} 23.2 Use camelCase when naming objects, functions, and instances. eslint: camelcase 12345678// badconst OBJEcttsssss = {};const this_is_my_object = {};function c() {}// goodconst thisIsMyObject = {};function thisIsMyFunction() {} 23.3 Use PascalCase only when naming constructors or classes. eslint: new-cap 12345678910111213141516171819// badfunction user(options) { this.name = options.name;}const bad = new user({ name: 'nope',});// goodclass User { constructor(options) { this.name = options.name; }}const good = new User({ name: 'yup',}); 23.4 Do not use trailing or leading underscores. eslint: no-underscore-dangle Why? JavaScript does not have the concept of privacy in terms of properties or methods. Although a leading underscore is a common convention to mean “private”, in fact, these properties are fully public, and as such, are part of your public API contract. This convention might lead developers to wrongly think that a change won’t count as breaking, or that tests aren’t needed. tl;dr: if you want something to be “private”, it must not be observably present. 123456789101112// badthis.__firstName__ = 'Panda';this.firstName_ = 'Panda';this._firstName = 'Panda';// goodthis.firstName = 'Panda';// good, in environments where WeakMaps are available// see https://kangax.github.io/compat-table/es6/#test-WeakMapconst firstNames = new WeakMap();firstNames.set(this, 'Panda'); 23.5 Don’t save references to this. Use arrow functions or Function#bind. 12345678910111213141516171819202122// badfunction foo() { const self = this; return function () { console.log(self); };}// badfunction foo() { const that = this; return function () { console.log(that); };}// goodfunction foo() { return () =&gt; { console.log(this); };} 23.6 A base filename should exactly match the name of its default export. 123456789101112131415161718192021222324252627282930// file 1 contentsclass CheckBox { // ...}export default CheckBox;// file 2 contentsexport default function fortyTwo() { return 42; }// file 3 contentsexport default function insideDirectory() {}// in some other file// badimport CheckBox from './checkBox'; // PascalCase import/export, camelCase filenameimport FortyTwo from './FortyTwo'; // PascalCase import/filename, camelCase exportimport InsideDirectory from './InsideDirectory'; // PascalCase import/filename, camelCase export// badimport CheckBox from './check_box'; // PascalCase import/export, snake_case filenameimport forty_two from './forty_two'; // snake_case import/filename, camelCase exportimport inside_directory from './inside_directory'; // snake_case import, camelCase exportimport index from './inside_directory/index'; // requiring the index file explicitlyimport insideDirectory from './insideDirectory/index'; // requiring the index file explicitly// goodimport CheckBox from './CheckBox'; // PascalCase export/import/filenameimport fortyTwo from './fortyTwo'; // camelCase export/import/filenameimport insideDirectory from './insideDirectory'; // camelCase export/import/directory name/implicit &quot;index&quot;// ^ supports both insideDirectory.js and insideDirectory/index.js 23.7 Use camelCase when you export-default a function. Your filename should be identical to your function’s name. 12345function makeStyleGuide() { // ...}export default makeStyleGuide; 23.8 Use PascalCase when you export a constructor / class / singleton / function library / bare object. 123456const AirbnbStyleGuide = { es6: { },};export default AirbnbStyleGuide; 23.9 Acronyms and initialisms should always be all uppercased, or all lowercased. Why? Names are for readability, not to appease a computer algorithm. 12345678910111213141516171819202122232425262728// badimport SmsContainer from './containers/SmsContainer';// badconst HttpRequests = [ // ...];// goodimport SMSContainer from './containers/SMSContainer';// goodconst HTTPRequests = [ // ...];// also goodconst httpRequests = [ // ...];// bestimport TextMessageContainer from './containers/TextMessageContainer';// bestconst requests = [ // ...]; 23.10 You may optionally uppercase a constant only if it (1) is exported, (2) is a const (it can not be reassigned), and (3) the programmer can trust it (and its nested properties) to never change. Why? This is an additional tool to assist in situations where the programmer would be unsure if a variable might ever change. UPPERCASE_VARIABLES are letting the programmer know that they can trust the variable (and its properties) not to change.* What about all const variables? - This is unnecessary, so uppercasing should not be used for constants within a file. It should be used for exported constants however. What about exported objects? - Uppercase at the top level of export (e.g. EXPORTED_OBJECT.key) and maintain that all nested properties do not change. 12345678910111213141516171819202122232425262728// badconst PRIVATE_VARIABLE = 'should not be unnecessarily uppercased within a file';// badexport const THING_TO_BE_CHANGED = 'should obviously not be uppercased';// badexport let REASSIGNABLE_VARIABLE = 'do not use let with uppercase variables';// ---// allowed but does not supply semantic valueexport const apiKey = 'SOMEKEY';// better in most casesexport const API_KEY = 'SOMEKEY';// ---// bad - unnecessarily uppercases key while adding no semantic valueexport const MAPPING = { KEY: 'value'};// goodexport const MAPPING = { key: 'value'}; Accessors 24.1 Accessor functions for properties are not required. 24.2 Do not use JavaScript getters/setters as they cause unexpected side effects and are harder to test, maintain, and reason about. Instead, if you do make accessor functions, use getVal() and setVal('hello'). 123456789101112131415161718192021// badclass Dragon { get age() { // ... } set age(value) { // ... }}// goodclass Dragon { getAge() { // ... } setAge(value) { // ... }} 24.3 If the property/method is a boolean, use isVal() or hasVal(). 123456789// badif (!dragon.age()) { return false;}// goodif (!dragon.hasAge()) { return false;} 24.4 It’s okay to create get() and set() functions, but be consistent. 1234567891011121314class Jedi { constructor(options = {}) { const lightsaber = options.lightsaber || 'blue'; this.set('lightsaber', lightsaber); } set(key, val) { this[key] = val; } get(key) { return this[key]; }} Events 25.1 When attaching data payloads to events (whether DOM events or something more proprietary like Backbone events), pass an object literal (also known as a “hash”) instead of a raw value. This allows a subsequent contributor to add more data to the event payload without finding and updating every handler for the event. For example, instead of: 12345678// bad$(this).trigger('listingUpdated', listing.id);// ...$(this).on('listingUpdated', (e, listingID) =&gt; { // do something with listingID}); prefer: 12345678// good$(this).trigger('listingUpdated', { listingID: listing.id });// ...$(this).on('listingUpdated', (e, data) =&gt; { // do something with data.listingID}); jQuery 26.1 Prefix jQuery object variables with a $. 12345678// badconst sidebar = $('.sidebar');// goodconst $sidebar = $('.sidebar');// goodconst $sidebarBtn = $('.sidebar-btn'); 26.2 Cache jQuery lookups. 12345678910111213141516171819202122// badfunction setSidebar() { $('.sidebar').hide(); // ... $('.sidebar').css({ 'background-color': 'pink', });}// goodfunction setSidebar() { const $sidebar = $('.sidebar'); $sidebar.hide(); // ... $sidebar.css({ 'background-color': 'pink', });} 26.3 For DOM queries use Cascading $('.sidebar ul') or parent &gt; child $('.sidebar &gt; ul'). jsPerf 26.4 Use find with scoped jQuery object queries. 1234567891011121314// bad$('ul', '.sidebar').hide();// bad$('.sidebar').find('ul').hide();// good$('.sidebar ul').hide();// good$('.sidebar &gt; ul').hide();// good$sidebar.find('ul').hide(); ECMAScript 5 Compatibility 27.1 Refer to Kangax’s ES5 compatibility table. ECMAScript 6+ (ES 2015+) Styles 28.1 This is a collection of links to the various ES6+ features. Arrow Functions Classes Object Shorthand Object Concise Object Computed Properties Template Strings Destructuring Default Parameters Rest Array Spreads Let and Const Exponentiation Operator Iterators and Generators Modules 28.2 Do not use TC39 proposals that have not reached stage 3. Why? They are not finalized, and they are subject to change or to be withdrawn entirely. We want to use JavaScript, and proposals are not JavaScript yet. Standard LibraryThe Standard Librarycontains utilities that are functionally broken but remain for legacy reasons. 29.1 Use Number.isNaN instead of global isNaN.eslint: no-restricted-globals Why? The global isNaN coerces non-numbers to numbers, returning true for anything that coerces to NaN.If this behavior is desired, make it explicit. 1234567// badisNaN('1.2'); // falseisNaN('1.2.3'); // true// goodNumber.isNaN('1.2.3'); // falseNumber.isNaN(Number('1.2.3')); // true 29.2 Use Number.isFinite instead of global isFinite.eslint: no-restricted-globals Why? The global isFinite coerces non-numbers to numbers, returning true for anything that coerces to a finite number.If this behavior is desired, make it explicit. 123456// badisFinite('2e3'); // true// goodNumber.isFinite('2e3'); // falseNumber.isFinite(parseInt('2e3', 10)); // true Testing 30.1 Yup. 123function foo() { return true;} #javascript","link":"/2021/05/26/javascript/AirbnbJavaScriptStyleGuide/"}],"tags":[{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"interview","slug":"interview","link":"/tags/interview/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"closure","slug":"closure","link":"/tags/closure/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"other","slug":"other","link":"/tags/other/"},{"name":"question","slug":"question","link":"/tags/question/"},{"name":"vue","slug":"vue","link":"/tags/vue/"}],"categories":[{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"css","slug":"css","link":"/categories/css/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"interview","slug":"interview","link":"/categories/interview/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"other","slug":"other","link":"/categories/other/"},{"name":"question","slug":"question","link":"/categories/question/"},{"name":"vue","slug":"vue","link":"/categories/vue/"}]}
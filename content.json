{"pages":[{"title":"links","text":"将纯色背景的图片转换为背景透明的图片 https://www.aigei.com/bgremover/ ui组件 https://bulma.io/documentation/","link":"/links/index.html"},{"title":"search","text":"","link":"/search/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Windows下如何查看某个端口被谁占用","text":"开始—-&gt;运行—-&gt; cmd ，或者是 window+R 组合键，调出命令窗口。 查找所有运行的端口1netstat -ano 查看被占用端口对应的 PID1netstat -aon|findstr &quot;8081&quot; 查看指定 PID 的进程1tasklist|findstr &quot;9088&quot; 结束进程强制（/F参数）杀死 pid 为 9088 的所有进程包括子进程（/T参数）： 1taskkill /T /F /PID 9088 #Windows#","link":"/2020/09/12/Windows/5925b1aea9/"},{"title":"Flex 布局教程：实例篇","text":"[[Flex 布局教程：语法篇]] 介绍了Flex布局的语法，今天介绍常见布局的Flex写法。 你会看到，不管是什么布局，Flex往往都可以几行命令搞定。 我只列出代码，详细的语法解释请查阅 [[Flex 布局教程：语法篇]]。我的主要参考资料是 Landon Schropp 的文章和 Solved by Flexbox 。 一、骰子的布局骰子的一面，最多可以放置9个点。 下面，就来看看Flex如何实现，从1个点到9个点的布局。你可以到 codepen 查看Demo。 如果不加说明，本节的HTML模板一律如下。 123&lt;div class=&quot;box&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt;&lt;/div&gt; 上面代码中，div元素（代表骰子的一个面）是Flex容器，span元素（代表一个点）是Flex项目。如果有多个项目，就要添加多个span元素，以此类推。 1.1 单项目首先，只有左上角1个点的情况。Flex布局默认就是首行左对齐，所以一行代码就够了。 123.box { display: flex;} 设置项目的对齐方式，就能实现居中对齐和右对齐。 1234.box { display: flex; justify-content: center;} 1234.box { display: flex; justify-content: flex-end;} 设置交叉轴对齐方式，可以垂直移动主轴。 1234.box { display: flex; align-items: center;} 12345.box { display: flex; justify-content: center; align-items: center;} 12345.box { display: flex; justify-content: center; align-items: flex-end;} 12345.box { display: flex; justify-content: flex-end; align-items: flex-end;} 1.2 双项目 1234.box { display: flex; justify-content: space-between;} 12345.box { display: flex; flex-direction: column; justify-content: space-between;} 123456.box { display: flex; flex-direction: column; justify-content: space-between; align-items: center;} 123456.box { display: flex; flex-direction: column; justify-content: space-between; align-items: flex-end;} 1234567.box { display: flex;}.item:nth-child(2) { align-self: center;} 12345678.box { display: flex; justify-content: space-between;}.item:nth-child(2) { align-self: flex-end;} 1.3 三项目 1234567891011.box { display: flex;}.item:nth-child(2) { align-self: center;}.item:nth-child(3) { align-self: flex-end;} 1.4 四项目 123456.box { display: flex; flex-wrap: wrap; justify-content: flex-end; align-content: space-between;} HTML代码如下。 12345678910&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; CSS代码如下。 1234567891011.box { display: flex; flex-wrap: wrap; align-content: space-between;}.column { flex-basis: 100%; display: flex; justify-content: space-between;} 1.5 六项目 12345.box { display: flex; flex-wrap: wrap; align-content: space-between;} 123456.box { display: flex; flex-direction: column; flex-wrap: wrap; align-content: space-between;} HTML代码如下。 1234567891011121314&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; CSS代码如下。 1234567891011121314151617.box { display: flex; flex-wrap: wrap;}.row{ flex-basis: 100%; display:flex;}.row:nth-child(2){ justify-content: center;}.row:nth-child(3){ justify-content: space-between;} 1.6 九项目 1234.box { display: flex; flex-wrap: wrap;} 二、网格布局2.1 基本网格布局最简单的网格布局，就是平均分布。在容器里面平均分配空间，跟上面的骰子布局很像，但是需要设置项目的自动缩放。 HTML代码如下。 12345&lt;div class=&quot;Grid&quot;&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt;&lt;/div&gt; CSS代码如下。 1234567.Grid { display: flex;}.Grid-cell { flex: 1;} 2.2 百分比布局某个网格的宽度为固定的百分比，其余网格平均分配剩余的空间。 HTML代码如下。 12345&lt;div class=&quot;Grid&quot;&gt; &lt;div class=&quot;Grid-cell u-1of4&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell u-1of3&quot;&gt;...&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223.Grid { display: flex;}.Grid-cell { flex: 1;}.Grid-cell.u-full { flex: 0 0 100%;}.Grid-cell.u-1of2 { flex: 0 0 50%;}.Grid-cell.u-1of3 { flex: 0 0 33.3333%;}.Grid-cell.u-1of4 { flex: 0 0 25%;} 三、圣杯布局圣杯布局 （Holy Grail Layout）指的是一种最常见的网站布局。页面从上到下，分成三个部分：头部（header），躯干（body），尾部（footer）。其中躯干又水平分成三栏，从左到右为：导航、主栏、副栏。 HTML代码如下。 123456789&lt;body class=&quot;HolyGrail&quot;&gt; &lt;header&gt;...&lt;/header&gt; &lt;div class=&quot;HolyGrail-body&quot;&gt; &lt;main class=&quot;HolyGrail-content&quot;&gt;...&lt;/main&gt; &lt;nav class=&quot;HolyGrail-nav&quot;&gt;...&lt;/nav&gt; &lt;aside class=&quot;HolyGrail-ads&quot;&gt;...&lt;/aside&gt; &lt;/div&gt; &lt;footer&gt;...&lt;/footer&gt;&lt;/body&gt; CSS代码如下。 1234567891011121314151617181920212223242526272829.HolyGrail { display: flex; min-height: 100vh; flex-direction: column;}header,footer { flex: 1;}.HolyGrail-body { display: flex; flex: 1;}.HolyGrail-content { flex: 1;}.HolyGrail-nav, .HolyGrail-ads { /* 两个边栏的宽度设为12em */ flex: 0 0 12em;}.HolyGrail-nav { /* 导航放到最左边 */ order: -1;} 如果是小屏幕，躯干的三栏自动变为垂直叠加。 1234567891011@media (max-width: 768px) { .HolyGrail-body { flex-direction: column; flex: 1; } .HolyGrail-nav, .HolyGrail-ads, .HolyGrail-content { flex: auto; }} 四、输入框的布局我们常常需要在输入框的前方添加提示，后方添加按钮。 HTML代码如下。 12345&lt;div class=&quot;InputAddOn&quot;&gt; &lt;span class=&quot;InputAddOn-item&quot;&gt;...&lt;/span&gt; &lt;input class=&quot;InputAddOn-field&quot;&gt; &lt;button class=&quot;InputAddOn-item&quot;&gt;...&lt;/button&gt;&lt;/div&gt; CSS代码如下。 1234567.InputAddOn { display: flex;}.InputAddOn-field { flex: 1;} 五、悬挂式布局有时，主栏的左侧或右侧，需要添加一个图片栏。 HTML代码如下。 1234&lt;div class=&quot;Media&quot;&gt; &lt;img class=&quot;Media-figure&quot; src=&quot;&quot; alt=&quot;&quot;&gt; &lt;p class=&quot;Media-body&quot;&gt;...&lt;/p&gt;&lt;/div&gt; CSS代码如下。 123456789101112.Media { display: flex; align-items: flex-start;}.Media-figure { margin-right: 1em;}.Media-body { flex: 1;} 六、固定的底栏有时，页面内容太少，无法占满一屏的高度，底栏就会抬高到页面的中间。这时可以采用Flex布局，让底栏总是出现在页面的底部。 HTML代码如下。 12345&lt;body class=&quot;Site&quot;&gt; &lt;header&gt;...&lt;/header&gt; &lt;main class=&quot;Site-content&quot;&gt;...&lt;/main&gt; &lt;footer&gt;...&lt;/footer&gt;&lt;/body&gt; CSS代码如下。 123456789.Site { display: flex; min-height: 100vh; flex-direction: column;}.Site-content { flex: 1;} 七，流式布局每行的项目数固定，会自动分行。 CSS的写法。 12345678910111213141516.parent { width: 200px; height: 150px; background-color: black; display: flex; flex-flow: row wrap; align-content: flex-start;}.child { box-sizing: border-box; background-color: white; flex: 0 0 25%; height: 50px; border: 1px solid red;} （完） Flex 布局教程：实例篇 #css","link":"/2021/05/28/css/0721b17a21/"},{"title":"Flex 布局教程：语法篇","text":"网页布局（layout）是 CSS 的一个重点应用。 布局的传统解决方案，基于 盒状模型 ，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如， 垂直居中 就不容易实现。 2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex 布局将成为未来布局的首选方案。本文介绍它的语法， 下一篇文章 给出常见布局的 Flex 写法。网友 JailBreak 为本文的所有示例制作了 Demo ，也可以参考。 以下内容主要参考了下面两篇文章： A Complete Guide to Flexbox 和 A Visual Guide to CSS3 Flexbox Properties 。 一、Flex 布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 123.box{ display: flex;} 行内元素也可以使用 Flex 布局。 123.box{ display: inline-flex;} Webkit 内核的浏览器，必须加上 -webkit 前缀。 1234.box{ display: -webkit-flex; /* Safari */ display: flex;} 注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。 二、基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start ，结束位置叫做 main end ；交叉轴的开始位置叫做 cross start ，结束位置叫做 cross end 。 项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size ，占据的交叉轴空间叫做 cross size 。 三、容器的属性以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 3.1 flex-direction属性flex-direction 属性决定主轴的方向（即项目的排列方向）。 123.box { flex-direction: row | row-reverse | column | column-reverse;} 它可能有4个值。 row （默认值）：主轴为水平方向，起点在左端。 row-reverse ：主轴为水平方向，起点在右端。 column ：主轴为垂直方向，起点在上沿。 column-reverse ：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。 flex-wrap 属性定义，如果一条轴线排不下，如何换行。 123.box{ flex-wrap: nowrap | wrap | wrap-reverse;} 它可能取三个值。 （1） nowrap （默认）：不换行。 （2） wrap ：换行，第一行在上方。 （3） wrap-reverse ：换行，第一行在下方。 3.3 flex-flowflex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap 。 123.box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;} 3.4 justify-content属性justify-content 属性定义了项目在主轴上的对齐方式。 123.box { justify-content: flex-start | flex-end | center | space-between | space-around;} 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start （默认值）：左对齐 flex-end ：右对齐 center ： 居中 space-between ：两端对齐，项目之间的间隔都相等。 space-around ：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性align-items 属性定义项目在交叉轴上如何对齐。 123.box { align-items: flex-start | flex-end | center | baseline | stretch;} 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start ：交叉轴的起点对齐。 flex-end ：交叉轴的终点对齐。 center ：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch （默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.box { align-content: flex-start | flex-end | center | space-between | space-around | stretch;} 该属性可能取6个值。 flex-start ：与交叉轴的起点对齐。 flex-end ：与交叉轴的终点对齐。 center ：与交叉轴的中点对齐。 space-between ：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around ：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch （默认值）：轴线占满整个交叉轴。 四、项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 4.1 order属性order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.item { order: &lt;integer&gt;;} 4.2 flex-grow属性flex-grow 属性定义项目的放大比例，默认为 0 ，即如果存在剩余空间，也不放大。 123.item { flex-grow: &lt;number&gt;; /* default 0 */} 如果所有项目的 flex-grow 属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的 flex-grow 属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item { flex-shrink: &lt;number&gt;; /* default 1 */} 如果所有项目的 flex-shrink 属性都为1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4.4 flex-basis属性flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto ，即项目的本来大小。 123.item { flex-basis: &lt;length&gt; | auto; /* default auto */} 它可以设为跟 width 或 height 属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto 。后两个属性可选。 123.item { flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]} 该属性有两个快捷值： auto ( 1 1 auto ) 和 none ( 0 0 auto )。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto ，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch 。 123.item { align-self: auto | flex-start | flex-end | center | baseline | stretch;} 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 （完） Flex 布局教程：语法篇 #css","link":"/2021/05/09/css/5e06940b3b/"},{"title":"css 中的 bfc（Block Formatting Contexts）","text":"常见定位方案在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案: 普通流 (normal flow) 在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。 浮动 (float) 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。 绝对定位 (absolute positioning) 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。 BFC 概念Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 那么 BFC 是什么呢？ BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。 具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。 通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 触发 BFC只要元素满足下面任一条件即可触发 BFC 特性： body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) BFC 特性及应用同一个 BFC 下外边距会发生折叠从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。 See the Pen BFC边距重叠1 by 糖小米 . (@tangxiaomi) on CodePen. 首先这不是 CSS 的 bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 See the Pen BFC边距重叠2 by 糖小米 . (@tangxiaomi) on CodePen. ### BFC 可以包含浮动的元素（清除浮动） 我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子 See the Pen BFC浮动1 by 糖小米 . (@tangxiaomi) on CodePen. 由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。 See the Pen BFC浮动2 by 糖小米 . (@tangxiaomi) on CodePen. ### BFC 可以阻止元素被浮动元素覆盖 先来看一个文字环绕效果： See the Pen BFC浮动覆盖1 by 糖小米 . (@tangxiaomi) on CodePen. 这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden，就会变成： See the Pen BFC浮动覆盖2 by 糖小米 . (@tangxiaomi) on CodePen. 这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。 #css","link":"/2020/08/18/css/96ae68ae0b/"},{"title":"git 常用命令","text":"恢复修改过的文件1git checkout file_name 获取远程分支1git checkout --track origin/branch_name 本地分支关联远程分支1git branch --set-upstream-to=origin/[branch_name] [branch_name] 合并某一次提交1git cherry-pick commit_id 查看最近3条更新日志，并且简单显示修改的文件12# 查看最近3条更新日志，并且简单显示修改的文件 git log -3 -—stat 命令行看提交记录图形1git log --oneline --graph 查看指定提交的内容1git show [commit_id] -—stat 恢复修改过的文件1git chekout [file_name] 本地分支推送到远程分支1git push -—set-upstream origin [branch_nam] 将远程分支拉到本地1git checkout —track origin/branch_name 合并某一次提交到指定分支* 获取此次提交的commit_id * 切换到需要合并的分支 1git cherry-pick [commit_id] 远程分支覆盖本地分支123git fetch -—all // fetch所有分支上的内容，也可以选择只备份一部分内容 git reset -—hard origin/master // 重置本地分支（这里master要修改为对应的分支名） git pull clone 远程仓库1git clone ssh://git@github.com:im/im.github.io.git 初始化本地 git 仓库（新建仓库）1git init 查看当前版本状态（是否修改）1git status 显示所有未添加至 index 的变更1git diff 比较与上一个版本的差异1git diff HEAD^ / HEAD -- ./lib 增加更改过的文件至 index1git add . / add * ... 提交1git commit -m ‘xxx’ 合并上一次提交（用于反复修改）12345git commit -amend -m ‘xxx’add 和 commit 合为一步git commit -am ‘xxx’ 显示日志1git log 显示某个提交的详细内容1git show &lt;commit&gt; 在每一行显示 commit 号,提交者,最早提交日期1git blame &lt;file&gt; 显示本地分支1git branch 切换分支1git checkout &lt;branch&gt; 新建分支1git branch &lt;new-branch&gt; 创建新分支跟踪远程分支1git branch --track &lt;new&gt; &lt;remote&gt; 删除本地分支1git branch -d &lt;branch&gt; 给当前分支打标签1git tag &lt;tag-name&gt; 列出远程分支详细信息1git remote -v 显示某个分支信息1git remote show &lt;remote&gt; 添加一个新的远程仓库1git remote add &lt;remote&gt; &lt;url&gt; 获取远程分支，但不更新本地分支，另需 merge1git fetch &lt;remote&gt; 获取远程分支，并更新本地分支1git pull &lt;remote&gt; &lt;branch&gt; 推送本地更新到远程分支1git push &lt;remote&gt; &lt;branch&gt; 删除一个远程分支1git push &lt;remote&gt; --delete &lt;branch&gt; 推送本地标签1git push --tags 合并分支到当前分支，存在两个1git merge &lt;branch&gt; 合并分支到当前分支，存在一个1git rebase &lt;branch&gt; 回到执行 rebase 之前123git rebase --abort 解决矛盾后继续执行 rebase git rebase --continue 使用 mergetool 解决冲突git mergetool 使用冲突文件解决冲突123git add &lt;resolve-file&gt;git rm &lt;resolved-file&gt; 将当前版本重置为 HEAD（用于 merge 失败）1git reset --hard HEAD 将当前版本重置至某一个提交状态（慎用！）1git reset --hard &lt;commit&gt; 将当前版本重置至某一个提交状态，代码不变1git reset &lt;commit&gt; 重置至某一状态，保留版本库中不同的文件1git reset --merge &lt;commit&gt; 重置至某一状态，重置变化的文件，代码改变1git reset --keep &lt;commit&gt; 丢弃本地更改信息并将其存入特定文件1git checkout HEAD &lt;file&gt; 撤销提交1git revert &lt;commit&gt; #git","link":"/2021/06/02/git/02dec3f669/"},{"title":"git submodule","text":"添加12345git submodule add -b [指定分支] [仓库地址] [路径]example:git submodule add -b icarus https://github.com/im/hexo-theme.git themes/icarus 命令执行完成，会在当前工程根路径下生成一个名为 .gitmodules 的文件，其中记录了子模块的信息。 .gitmodules1234[submodule &quot;themes/icarus&quot;] path = themes/icarus url = https://github.com/im/hexo-theme.git branch = icarus 更新1git submodule update 删除submodule 的删除稍微麻烦点：首先，要在 .gitmodules 文件中删除相应配置信息。然后，执行 git rm –cached 命令将子模块所在的文件从 git 中删除。 下载的工程带有submodule1git submodule update --init --recursive 查看sumodule状态1git submodule foreach git status 不能更新1git submodule update --remote #git","link":"/2021/06/02/git/51140d0575/"},{"title":"git 修改远程仓库地址","text":"命令直接修改1git remote set-url origin [url] 先删后加12git remote rm origingit remote add origin [url] 直接修改配置文件12cd .gitvim config 12345678910111213141516171819[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true[remote &quot;origin&quot;] url = https://github.com/im/im.github.io.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;main&quot;] remote = origin merge = refs/heads/main[submodule &quot;themes/icarus&quot;] active = true url = https://github.com/im/hexo-theme.git[submodule &quot;themes/cactus&quot;] url = https://github.com/im/hexo-theme.git active = true 查看远程地址1git remote -v #git","link":"/2019/05/28/git/5486e0a270/"},{"title":"git 修改远程仓库地址","text":"命令直接修改1git remote set-url origin [url] 先删后加1git remote rm origingit remote add origin [url] 直接修改配置文件1234567891011121314151617181920[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true[remote &quot;origin&quot;] url = https://github.com/im/im.github.io.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;main&quot;] remote = origin merge = refs/heads/main[submodule &quot;themes/icarus&quot;] active = true url = https://github.com/im/hexo-theme.git[submodule &quot;themes/cactus&quot;] url = https://github.com/im/hexo-theme.git active = true 查看远程地址1git remote -v git 修改远程仓库地址 #git","link":"/2019/04/21/git/5cac99d1ff/"},{"title":"git rebase -i","text":"变基时有六个命令可用： pickpick只是意味着包括提交。重新进行命令时，重新安排pick命令的顺序会更改提交的顺序。如果选择不包括提交，则应删除整行。 reword该reword命令与相似pick，但是使用后，重新设置过程将暂停并为您提供更改提交消息的机会。提交所做的任何更改均不受影响。 edit如果您选择edit提交，则将有机会修改提交，这意味着您可以完全添加或更改提交。您还可以进行更多提交，然后再继续进行变基。这使您可以将大型提交拆分为较小的提交，或者删除在提交中所做的错误更改。 squash该命令使您可以将两个或多个提交合并为一个提交。提交被压缩到其上方的提交中。Git使您有机会编写描述这两个更改的新提交消息。 fixup这类似于squash，但是要合并的提交已丢弃其消息。提交仅合并到其上方的提交中，并且较早提交的消息用于描述这两个更改。 exec这使您可以对提交运行任意的Shell命令。 准备123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 我们初始化一个项目git init# 制造一些提交touch base.txtgit add .git commit -m &quot;add base&quot;touch 1.txtgit add .git commit -m &quot;add 1&quot;touch 2.txtgit add .git commit -m &quot;add 2&quot;touch 3.txtgit add .git commit -m &quot;add 3&quot;touch 4.txtgit add .git commit -m &quot;add 4&quot;touch 5.txtgit add .git commit -m &quot;add 5&quot;## 查看现在的提交git logcommit a75ed742838ebc1ef1073502623478f73e1ec21fAuthor: Date: Wed Mar 4 10:02:51 2020 +0800 add 5commit 8b485bb4768b2abf8f6400dcba069f1a650ed5ecAuthor: Date: Wed Mar 4 09:59:27 2020 +0800 add 4commit 63ce9fb010da550c668aca66758c45fbfad46e2bAuthor:Date: Wed Mar 4 09:59:04 2020 +0800 add 3commit 9cd34c4d42f52cfb40026dae613c8ad29d7cbc66Author: Date: Wed Mar 4 09:58:45 2020 +0800 add 2commit 77bd0eb1a97e1676367ea236c1c47c155eaa8430Author: Date: Wed Mar 4 09:58:23 2020 +0800 add 1 现在我们已经有了一些，提交了，接下来开始练习 pick 更改提交顺序、删除提交pick只是意味着包括提交。重新进行命令时，重新安排pick`命令的顺序会更改提交的顺序。如果选择不包括提交，则应删除整行。 ::假定，我们现在要改变提交 5.txt 和 4.txt 的顺序，该怎么操作:: 更改涉及到了两次提交，最早提交次数为2（4.txt是倒数第二次提交） 告诉git 我要改变倒数第2次后的提交 1git rebase -i HEAD~2 接着，git给你一个文本，告诉你我知道了，你说的这些可以有以下操作 下面是执行命令后的样子 123456789101112131415161718192021222324pick 8b485bb add 4pick a75ed74 add 5# Rebase 63ce9fb..a75ed74 onto 63ce9fb (2 command(s))## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like &quot;squash&quot;, but discard this commit's log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out~~~ 解释：我们刚刚执行的命令中 HEAD~2代表选择离HEAD最近的两条提交下面注释的是提示，我们不需要管，只要专注前两行就ok 把 第一行 和 第二行 交换顺序 小技巧：这个是vi编辑器，首先Esc ，进入命令模式，移动到第一行 按dd,本行就被剪切，pick a75ed74 add 5就变成了第一行，接着按 p刚刚剪切的就成了第二行，快速交换顺序 不会用vi建议百度篇教程学习一哈 变成下面的样子 12pick a75ed74 add 5pick 8b485bb add 4 接着 Esc,:wq 保存退出成功！ git log查看，4 和 5 的顺序改变了 假定，我们现在要删除 某一个提交，该怎么操作我们来删除 add 4 的那条提交 1git rebase -i HEAD~2 出现如下 12345pick a75ed74 add 5pick 8b485bb add 4# Rebase 575fd8b..bb2a77d onto 575fd8b (1 command(s))# .....略 我们删除 第二行 接着 Esc,:wq 保存退出 git log查看，4 和 5 的顺序改变了 record 修改提交消息(提交内容不变)该reword命令与相似pick，但是使用后，重新设置过程将暂停并为您提供更改提交消息的机会。提交所做的任何更改均不受影响。 假定，我们现在要 修改某个提交的消息，该怎么操作修改一下 add 2 的提交消息 git log 查看 add 2 距离 HEAD 有多少的距离，得：3 1git rebase -i HEAD~3 出现如下 123456pick 9cd34c4 add 2pick 63ce9fb add 3pick 575fd8b add 5# Rebase 77bd0eb..575fd8b onto 77bd0eb (3 command(s))# .... 略 我们只需要修改 第一行 add 2 ，其余保持不变 123456r 9cd34c4 add 2pick 63ce9fb add 3pick 575fd8b add 5# Rebase 77bd0eb..575fd8b onto 77bd0eb (3 command(s))# .... 略 r 是 record简写 接着 Esc,:wq 保存退出 git会说 开始执行，接着弹出一个编辑窗口 123456789101112131415161718add 2# Please enter the commit message for your changes. Lines starting# with '#' will be ignored, and an empty message aborts the commit.## Date: Wed Mar 4 09:58:45 2020 +0800## interactive rebase in progress; onto 77bd0eb# Last command done (1 command done):# r 9cd34c4 add 2# Next commands to do (2 remaining commands):# pick 63ce9fb add 3# pick 575fd8b add 5# You are currently editing a commit while rebasing branch 'master' on '77bd0eb'.## Changes to be committed:# new file: 2.txt# 我们就可以修改 add 2 了 下面的注释是对当前状态的一些说明 大致是说，上一次执行的命令 是 r 9cd34c4 add 2 下面还有两条命令 当前命令改变的committed的文件 是 2.txt 等等 修改 add 2 1add 2 ~ new comment 接着 Esc,:wq 保存退出 成功 git log查看, 消息 “add 2” 变为了 “add 2 ~ new comment” ::只要不动pick的 顺序，就代表什么都不做:: edit修改提交如果您选择edit提交，则将有机会修改提交，这意味着您可以完全添加或更改提交。您还可以进行更多提交，然后再继续进行变基。这使您可以将大型提交拆分为较小的提交，或者删除在提交中所做的错误更改。 假定 我想要在两个提交之间 再加提交，怎么办假定，我们要在 add 3 和 add 5 之间 添加一条提交 1git rebase -i HEAD~2 12345pick 6934312 add 3pick 5ce6dde add 5# Rebase 7f9d45d..5ce6dde onto 7f9d45d (2 command(s))# .... 修改为 12e 6934312 add 3pick 5ce6dde add 5 接着 Esc,:wq 保存退出 有如下 123456789101112$ git rebase -i HEAD~2Stopped at 6934312135c150bf74bead26e371df1443273ca4... add 3You can amend the commit now, with git commit --amendOnce you are satisfied with your changes, run git rebase --continuexxxxxx MINGW32 ~/Desktop/git-demo (master|REBASE-i 1/2) 可以看到，我们的master分支多了REBASE-i 1/2 我们尝试做一些修改，给3.txt 增加一些内容，然后提交 12345git add 3.txtgit commit -m &quot;edit 3.txt&quot;[detached HEAD 7262a57] edit 3.txt 1 file changed, 1 insertion(+) 接着，我们继续 rebase 12git rebase --continueSuccessfully rebased and updated refs/heads/master. git log 查看，在 add 5 和 add 3 中间 增加了我们刚刚的修改 假定 我想要单纯的修改这次提交内容和消息，怎么办 参照上面的做到这一步，我们选择提交的方式 加一个参数 git commit –amend修改 123456git add 3.txtgit commit --amend# 这样 就不会在多出一次提交# 本次对 3.txt的修改会记录 到 add 3 这次提交记录中 接着结束这次 rebase 12git rebase --continueSuccessfully rebased and updated refs/heads/master. squash合并提交squash 该命令使您可以将两个或多个提交合并为一个提交。提交被压缩到其上方的提交中。Git使您有机会编写描述这两个更改的新提交消息。 假定，我想合并某几个提交，怎么办 如下 我们合并 add 5 和 add 3 1git rebase - i HEAD~2 1234pick 6934312 add 3pick 6fa47e4 add 5# Rebase 7f9d45d..6fa47e4 onto 7f9d45d (2 command(s)) 修改为 12pick 6934312 add 3s 6fa47e4 add 5 接着 Esc,:wq 保存退出 开始执行变更 然后 在弹出来的编辑框里 写提交信息 123456789101112131415161718192021222324# This is a combination of 2 commits.# The first commit's message is:add 3# This is the 2nd commit message:add 5# Please enter the commit message for your changes. Lines starting# with '#' will be ignored, and an empty message aborts the commit.## Date: Wed Mar 4 09:59:04 2020 +0800## interactive rebase in progress; onto 7f9d45d# Last commands done (2 commands done):# pick 6934312 add 3# s 6fa47e4 add 5# No commands remaining.# You are currently editing a commit while rebasing branch 'master' on '7f9d45d'.## Changes to be committed:# new file: 3.txt# new file: 5.txt 我们可以修改提交消息，默认是把两个消息都合并 接着 Esc,:wq 保存退出 git log查看，合并成功 fixup合并提交，只保留较早的提交信息这类似于squash，但是要合并的提交已丢弃其消息。提交仅合并到其上方的提交中，并且较早提交的消息用于描述这两个更改。 最后两次提交 1git rebase -i HEAD~2 123456789101112pick 7f9d45d add 2 ~ new commentpick 311adc9 add 3# Rebase 77bd0eb..311adc9 onto 77bd0eb (2 command(s))# ----------------------# 变更为# -----------------------pick 7f9d45d add 2 ~ new commentf 311adc9 add 3# 保存 exec 执行任意shell命令1234567891011121314151617181920212223242526git rebase -i HEAD~3# 弹出编辑框#----------------------------pick 81fe4d0 添加test2.txt和test3.txtpick 77bd0eb add 1pick e7c68b8 add 2 ~ new comment# Rebase 258a059..e7c68b8 onto 258a059 (3 command(s))#....# ----------------# 加一行 命令# ---------------x echo &quot;Hello is echo do .......&quot;pick 81fe4d0 添加test2.txt和test3.txtpick 77bd0eb add 1pick e7c68b8 add 2 ~ new comment## 执行了我们刚刚键入的命令Executing: echo &quot;Hello is echo do .......&quot;Hello is echo do .......Successfully rebased and updated refs/heads/master. 其他 12345678# Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like &quot;squash&quot;, but discard this commit's log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit drop删除提交用法与 p,r,e,s,f,x 一致 命令写错了怎么办看提示 12You can fix this with 'git rebase --edit-todo'.# 用 git rebase --edit--todo 来重新编辑命令 #git","link":"/2021/06/02/git/8a00b72c59/"},{"title":"git 添加 ssh key","text":"创建 SSH Key123ssh-keygen -t rsa -C &quot;tangxiaomiemail@gmail.com&quot;cd ~/.sshcat id_rsa.pub 如果一切顺利的话，可以在用户主目录里找到 .ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人. 全局配置12git config --global user.name &quot;tangxiaomi&quot;git config --global user.email &quot;tangxiaomiemail@gmail.com&quot; 非全局配置 删除 --global12git config user.name &quot;tangxiaomi&quot;git config user.email &quot;tangxiaomiemail@gmail.com&quot; 查看配置12git config --global user.namegit config --global user.email 取消全局配置12345git config --global --unset user.namegit config --global --unset user.emailgit config --global user.name #(查看)全局配置账户是否已经移除git config --global user.email #(查看)全局配置邮箱是否已经移除 #git","link":"/2019/02/19/git/8ddec14d68/"},{"title":"7. HTML全局属性(global attribute)有哪些（包含H5）？","text":"accesskey 设置快捷键class 为元素设置类标识contenteditable 指定元素内容是否可编辑contextmenu 自定义鼠标右键弹出上下文菜单内容（仅firefox支持）data-* 为元素增加自定义属性dir：设置元素文本方向（默认ltr；rtl）draggable 设置元素是否可拖拽dropzone 设置元素拖放类型（copy|move|link,H5新属性，主流均不支持）hidden 规定元素仍未或不在相关id 元素id，文档内唯一lang 元素内容的语言spellcheck 是否启动拼写和语法检查style 行内css样式tabindex 设置元素可以获得焦点，通过tab导航title 规定元素有关的额外信息 相关链接：Global attributes #interview/html","link":"/2019/02/05/interview/06cf8f2028/"},{"title":"1. 页面导入样式时，使用link和@import有什么区别？","text":"描述 页面导入样式时，使用link和@import有什么区别？ 解答 link 是HTML标签，@import 是 css 提供的。 link 引入的样式页面加载时同时加载，@import 引入的样式需等页面加载完成后再加载。 link 没有兼容性问题，@import 不兼容 ie5 以下。 link 可以通过 js 操作 DOM 动态引入样式表改变样式，而 @import 不可以。 #interview/html","link":"/2021/04/01/interview/081fe6e927/"},{"title":"6 . 写一个方法去掉字符串中的空格","text":"描述写一个方法去掉字符串中的空格，要求传入不同的类型分别能去掉前、后、前后、中间的空格 解答12345678910111213141516171819202122232425262728293031323334353637383940const str = &quot; s t r &quot;;const POSITION = Object.freeze({ left: Symbol(), right: Symbol(), both: Symbol(), center: Symbol(), all: Symbol()});function trim(str, position = POSITION.both) { if (!!POSITION[position]) throw new Error(&quot;unexpected position value&quot;); switch (position) { case POSITION.left: str = str.replace(/^\\s+/, &quot;&quot;); break; case POSITION.right: str = str.replace(/\\s+$/, &quot;&quot;); break; case POSITION.both: str = str.replace(/^\\s+/, &quot;&quot;).replace(/\\s+$/, &quot;&quot;); break; case POSITION.center: while (str.match(/\\w\\s+\\w/)) { str = str.replace(/(\\w)(\\s+)(\\w)/, `$1$3`); } break; case POSITION.all: str = str.replace(/\\s/g, &quot;&quot;); break; default: } return str;}const result = trim(str);console.log(`|${result}|`); // |s t r| #interview/javascript","link":"/2020/01/04/interview/3445bf38ad/"},{"title":"8. 在页面上隐藏元素的方法有哪些？","text":"描述在页面上隐藏元素的方法有哪些？ 并简述出第一种方法的应用场景和优劣势 解答 占位: visibility: hidden; 看不见但是会占据空间margin-left: -100%;opacity: 0; 看不见但是会占据空间transform: scale(0);filter: opacity(0); 不占位: display: none; 页面不会渲染width: 0;height: 0;overflow: hidden; 页面会渲染但是不显示position 配合 z-index; 或者 left/top/bottom/right ： -100%；transform: scale(0);translateX(+-100%);translateY(+-100%);rotateX(90deg); 仅对块内文本元素: text-indent: -9999px;font-size: 0; #interview/css","link":"/2021/03/06/interview/40cd97a1c4/"},{"title":"2. 圣杯布局和双飞翼布局的理解和区别，并用代码实现","text":"理解圣杯布局和双飞翼布局都是为了解决两边定宽，中间自适应且优先渲染的布局需求，那么为了自适应且优先渲染，必须要把中间的 dom 放在最顶端，以保证主要内容能最先被浏览器解析 圣杯布局为了中间 div 内容不被遮挡，将中间 div 设置了左右 padding-left 和 padding-right 后，将左右两个 div 用相对布局 position: relative 并分别配合 right 和 left 属性，以便左右两栏 div 移动后不遮挡中间 div html123456789&lt;body&gt; &lt;div id=&quot;hd&quot;&gt;header&lt;/div&gt; &lt;div id=&quot;bd&quot;&gt; &lt;div id=&quot;middle&quot;&gt;middle&lt;/div&gt; &lt;div id=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt;&lt;/body&gt; css12345678910111213141516171819202122232425262728293031323334353637383940#hd height: 50px background:666 text-align: center#bd /* 左右栏通过添加负的margin放到正确的位置了，此段代码是为了摆正中间栏的位置 */ padding: 0 200px 0 180px height: 100px#middle float: left width: 100% /* 左栏上去到第一行 */ height: 100px background: blue#left float: left width: 180px height: 100px margin-left: -100% background:#0c9 /* 中间栏的位置摆正之后，左栏的位置也相应右移，通过相对定位的left恢复到正确位置 */ position: relative left: -180px#right float: left width: 200px height: 100px margin-left: -200px background:#0c9 /* 中间栏的位置摆正之后，右栏的位置也相应左移，通过相对定位的right恢复到正确位置 */ position: relative right: -200px#footer height: 50px background:#666 text-align: center 双飞翼布局为了中间 div 内容不被遮挡，直接在中间 div 内部创建子 div 用于放置内容，在该子 div 里用 margin-left 和 margin-right 为左右两栏 div 留出位置。多了1个 div ，少用大致4个 css 属性（圣杯布局中间 div padding-left 和 padding-right 这2个属性，加上左右两个 div 用相对布局 position: relative 及对应的 right 和 left 共4个属性，一共6个；而双飞翼布局子div里用 margin-left 和 margin-right 共2个属性，6-2=4），个人感觉比圣杯布局思路更直接和简洁一点。 hrml123456789&lt;body&gt; &lt;div id=&quot;hd&quot;&gt;header&lt;/div&gt; &lt;div id=&quot;middle&quot;&gt; &lt;div id=&quot;inside&quot;&gt;middle&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;right&lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt;&lt;/body&gt; css1234567891011121314151617181920212223242526272829303132333435#hd height: 50px background:#666 text-align: center#middle float: left width: 100% /* 左栏上去到第一行 */ height: 100px background: blue#left float: left width: 180px height: 100px margin-left: -100% background:#0c9#right float: left width: 200px height: 100px margin-left: -200px background:#0c9/* 给内部div添加margin，把内容放到中间栏，其实整个背景还是100% */#inside margin: 0 200px 0 180px height: 100px#footer clear: both /* 记得清楚浮动 */ height: 50px background:#666 text-align: center flex 实现圣杯布局html12345&lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;center&quot;&gt;center&lt;/div&gt; &lt;div id=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;right&lt;/div&gt;&lt;/div&gt; css123456789101112131415161718#container display: flex#center flex: 1 height 50px background blue#left flex: 0 0 200px order: -1 height 50px background yellow#right flex: 0 0 150px height 50px background green 参考文章： 圣杯布局和双飞翼布局的理解与思考 #interview/css","link":"/2021/03/02/interview/795066e848/"},{"title":"4. html的元素有哪些（包含H5）？","text":"描述区分出行内元素、块级元素、空元素并在后面简要标注下作用 行内元素 a b span strong i em button input label br textarea select 块元素 div p h1-h6 ol ul li table tbody td tr thead dl dt dd H5新增元素 section 标签定义文档中的节 article 标签的内容独立于文档的其余部分 audio 标签定义声音，比如音乐或其他音频流 video 标签定义视频，比如电影片段或其他视频流 hearder 标签定义文档的页眉（介绍信息） footer 标签定义文档或节的页脚 small 标签呈现小号字体效果 canvas 定义画布 #interview/html","link":"/2021/01/03/interview/8c857369da/"},{"title":"3. 用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值","text":"描述这是一道大题目，把考点拆成了4个小项；需要侯选人用递归算法实现（限制15行代码以内实现；限制时间10分钟内完成）： 生成一个长度为5的空数组 arr 。 生成一个（2－32）之间的随机整数 rand。 把随机数 rand 插入到数组 arr 内，如果数组arr内已存在与 rand 相同的数字，则重新生成随机数rand并插入到arr内[需要使用递归实现，不能使用 for/while 等循环] 最终输出一个长度为5，且内容不重复的数组 arr 。 解答1234567891011const arr = new Array(5);const randomNum = () =&gt; (Math.floor(Math.random() * 31 + 2))const randomArr = (n) =&gt; { if (n === 0) return arr; const num = randomNum(); if (arr.includes(num)) return randomArr(n) arr[n -1] = num; return randomArr(n - 1)};randomArr(arr.length) #interview/javascript","link":"/2021/02/28/interview/c8d8f66081/"},{"title":"JavaScript 实现前端下载图片","text":"实现思路 将图片装换成 Data URLs 下载图片 Data URLs Data URLs，即前缀为 data: 协议的的 URL，其允许内容创建者向文档中嵌入小文件。Data URLs 由四个部分组成：前缀(data:)、指示数据类型的 MIME 类型、如果非文本则为可选的 base64 标记、数据本身：data:[][;base64],mediative 是个 MIME 类型的字符串，例如 “image/jpeg” 表示 JPEG 图像文件。如果被省略，则默认值为 text/plain;charset=US-ASCII如果数据是文本类型，你可以直接将文本嵌入 (根据文档类型，使用合适的实体字符或转义字符)。如果是二进制数据，你可以将数据进行 base64 编码之后再进行嵌入。 详细请看 MDN 对 Data URLs 的解释。 代码实现以下是获取图片 DataURL 的示例代码： 123456789101112131415161718/*** 获取图片的 base64 编码 DataURL* @param image JS 图像对象* @return {string} 已编码的 DataURL*/getImageDataURL(image) { // 创建画布 const canvas = document.createElement('canvas'); canvas.width = image.width; canvas.height = image.height; const ctx = canvas.getContext('2d'); // 以图片为背景剪裁画布 ctx.drawImage(image, 0, 0, image.width, image.height); // 获取图片后缀名 const extension = image.src.substring(image.src.lastIndexOf('.') + 1).toLowerCase(); // 某些图片 url 可能没有后缀名，默认是 png return canvas.toDataURL('image/' + extension, 1);} 执行上面的函数后会返回如下面的格式一样的字符串 1data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAgAElEQVR4Xu1dB3hUxfb/bc3uppOeQOgIAioKCiqWJ/bysFd89vcXe0WfvSJ2wY6gPhX1WZ... 注意：图片越大，转换后的 base64 编码越长，尽量避免对大图进行 DataURL 转换，防止转换后的长度超出浏览器限制 以下是下载图片的示例代码： 12345678910111213141516downLoad(downloadName, url) { const tag = document.createElement('a'); // 此属性的值就是下载时图片的名称，注意，名称中不能有半角点，否则下载时后缀名会错误 tag.setAttribute('download', downloadName.replace(/\\./g, '。')); const image = new Image(); // 设置 image 的 url, 添加时间戳，防止浏览器缓存图片 image.src = url + '?time=' + new Date().getTime(); //重要，设置 crossOrigin 属性，否则图片跨域会报错 image.setAttribute('crossOrigin', 'Anonymous'); // 图片未加载完成时操作会报错 image.onload = () =&gt; { tag.href = getImageDataURL(image); tag.click(); };} #javascript","link":"/2020/03/13/javascript/04b07e4bb0/"},{"title":"Object.assign 是浅拷贝还是深拷贝？实现深拷贝的方法有哪些？","text":"Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。 Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。 String类型和 Symbol 类型的属性都会被拷贝。 在出现错误的情况下，例如，如果属性不可写，会引发TypeError，如果在引发错误之前添加了任何属性，则可以更改target对象。 Object.assign 不会在那些source对象值为 null 或 undefined 的时候抛出错误。 针对 深拷贝 ，需要使用其他办法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。也就是说，如果对象的属性值为简单类型（如string， number），通过Object.assign({},srcObj);得到的新对象为 深拷贝 ；如果属性值为对象或其它引用类型，那对于这个对象而言其实是 浅拷贝 的。 用 JSON.stringify 把对象转换成字符串，再用 JSON.parse 把字符串转换成新的对象。 可以转成 JSON 格式的对象才能使用这种方法，如果对象中包含 function 或 RegExp 这些就不能用这种方法了。 123456//通过js的内置对象JSON来进行数组对象的深拷贝function deepClone(obj) { let _obj = JSON.stringify(obj); let objClone = JSON.parse(_obj); return objClone;} Object.assign()拷贝当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝，但是对象中有对象的时候，此方法，在二级属性以后就是浅拷贝。 通过jQuery的extend方法实现深拷贝1234567891011let $ = require('jquery');let obj1 = { a: 1, b: { f: { g: 1 } }, c: [1, 2, 3]};let obj2 = $.extend(true, {}, obj1); lodash.cloneDeep()实现深拷贝1234567let _ = require('lodash');let obj1 = { a: 1, b: { f: { g: 1 } }, c: [1, 2, 3]};let obj2 = _.cloneDeep(obj1); 使用递归的方式实现深拷贝123456789101112131415161718function _deepClone(source) { let target; if (typeof source === 'object') { target = Array.isArray(source) ? [] : {} for (let key in source) { if (source.hasOwnProperty(key)) { if (typeof source[key] !== 'object') { target[key] = source[key] } else { target[key] = _deepClone(source[key]) } } } } else { target = source } return target} 经典前端面试题: Object.assign 是浅拷贝还是深拷贝？实现深拷贝的方法有哪些？ #javascript","link":"/2020/11/09/javascript/0ea8125a14/"},{"title":"编写JavaScript的10个小技巧","text":"简化条件表达式经常碰到这种情况，要判断某个变量是否为指定的某些值，用常规的逻辑表达式会很长。我的做法是把这些值放进数组里： 12345678// 太长的逻辑表达式if (x === 'abc' || x === 'def' || x === 'ghi' || x ==='jkl') { //其他逻辑}// 简写if (['abc', 'def', 'ghi', 'jkl'].includes(x)) { //其他逻辑} 简化 if … elseif…else太常用了，以至于很多人都忘了其实还有其他方式来判断条件。比如简单的变量赋值，完全没必要用这种冗长的语句，一行表达式就搞定了： 123456789101112// 新手的写法let test= boolean;if (x &gt; 100) { test = true;} else { test = false;}// 简写表达式let test = (x &gt; 10) ? true : false;// 更直接的let test = x &gt; 10;console.log(test); 三元表达式可以做复杂的条件分支判断，不过牺牲了一些可读性： 123let x = 300,let test2 = (x &gt; 100) ? 'greater 100' : (x &lt; 50) ? 'less 50' : 'between 50 and 100';console.log(test2); // &quot;greater than 100&quot; 判空并赋默认值Code Review 的时候我经常看到这样的代码，判断变量不是null，undefined，’’的时候赋值给第二个变量，否则给个默认值： 12345if (first !== null || first !== undefined || first !== '') { let second = first;}// 简写let second = first || ''; 简写循环遍历for 循环是最基本的，但是有点繁琐。可以用 for…in、for…of 或者 forEach 代替： 12345// Longhandfor (var i = 0; i &lt; testData.length; i++)// Shorthandfor (let i in testData) or for (let i of testData) 数组遍历： 123456function testData(element, index, array) { console.log('test[' + index + '] = ' + element);}[11, 24, 32].forEach(testData);// 打印输出: test[0] = 11, test[1] = 24, test[2] = 32 简化 switch这个技巧也很常用，把switch 转换成对象的key-value形式，代码简洁多了： 123456789101112131415161718192021222324// Longhandswitch (data) { case 1: test1(); break; case 2: test2(); break; case 3: test(); break; // And so on...}// Shorthandvar data = { 1: test1, 2: test2, 3: test};data[anything] &amp;&amp; data[anything](); 简化多行字符串拼接如果一个字符串表达式过长，我们可能会拆成多行拼接的方式。不过随着 ES6 的普及，更好的做法是用模板字符串： 123456//longhandconst data = 'abc abc abc abc abc abc\\n\\t' + 'test test,test test test test\\n\\t'//shorthandconst data = `abc abc abc abc abc abc test test,test test test test` 善用箭头函数简化 returnES6 的箭头函数真是个好东西，当函数简单到只需要返回一个表达式时，用箭头函数最合适不过了，return都不用写： 123456789Longhand://longhandfunction getArea(diameter) { return Math.PI * diameter}//shorthandgetArea = diameter =&gt; ( Math.PI * diameter;) 简化分支条件语句又是你，if…else if…else！跟 switch类似，也可以用key-value形式简化： 12345678910111213141516171819202122232425// Longhandif (type === 'test1') { test1();}else if (type === 'test2') { test2();}else if (type === 'test3') { test3();}else if (type === 'test4') { test4();} else { throw new Error('Invalid value ' + type);}// Shorthandvar types = { test1: test1, test2: test2, test3: test3, test4: test4};var func = types[type];(!func) &amp;&amp; throw new Error('Invalid value ' + type); func(); 重复字符串 N 次有时候出于某种目的需要将字符串重复 N 次，最笨的方法就是用for循环拼接。其实更简单的方法是用repeat： 12345678//longhand let test = ''; for(let i = 0; i &lt; 5; i ++) { test += 'test '; } console.log(str); // test test test test test //shorthand 'test '.repeat(5); 指数运算能省则省，低碳环保。 1234//longhandMath.pow(2,3); // 8//shorthand2**3 // 8 数字分隔符这是比较新的语法，ES2021 提出来的，数字字面量可以用下划线分割，提高了大数字的可读性： 1234// 旧语法let number = 98234567// 新语法let number = 98_234_567 #javascript","link":"/2016/02/10/javascript/46166f597a/"},{"title":"nodejs 搭建本地服务器 展示文件夹","text":"123456789101112131415161718192021222324252627282930313233const express = require('express')const http = require('http')const app = express()const port = 80var serveIndex = require('serve-index')app.use(express.static('../'))app.use(serveIndex('../'))function getIPAdress() { let interfaces = require('os').networkInterfaces() for (var devName in interfaces) { var iface = interfaces[devName] for (var i = 0; i &lt; iface.length; i++) { let alias = iface[i] if ( alias.family === 'IPv4' &amp;&amp; alias.address !== '127.0.0.1' &amp;&amp; !alias.internal ) { // console.log(alias.address); return alias.address } } }}var server = http.createServer(app)server.listen(port, () =&gt; { console.log(`Example app listening at http://${getIPAdress()}:${port}`)}) #javascript/nodejs","link":"/2018/07/16/javascript/485291d435/"},{"title":"偏函数","text":"偏函数是 [[函数柯里化]] 运算的一种特定应用场景。简单描述，就是把一个函数的某些参数先固化，也就是设置默认值，返回一个新的函数，在新函数中继续接收剩余参数，这样调用这个新函数会更简单。 下面是一个类型检测函数，接收两个参数，第 1 个表示类型字符串，第 2 个表示检测的数据。 123var isType = function (type, obj) { //偏函数 return Object.prototype.toString.call(obj) == '[object ' + type + ']';} 该函数包含两个设置参数，使用时比较繁琐。一般常按以下方式进行设计。 123456var isString = function (obj) { return Object.prototype.toString.call(obj) == '[object String]';};var isFunction = function (obj) { return Object.prototype.toString.call(obj) == '[object Function]';}; 函数接收的参数单一，检测的功能也单一和明确，这样更便于在表达式运算中有针对性的调用。下面对 isType() 函数进行扁平化设计，代码如下： 12345var isType = function (type) { return function (obj) { return Object.prototype.toString.call(obj) == '[object ' + type + ']'; }} 然后根据 JS 偏函数获取不同类型检测函数。 12var isString = isType(&quot;String&quot;); //专一功能检测函数，检测字符串var isFunction = isType(&quot;Function&quot;); //专一功能检测函数，检测字符串 应用代码如下： 123console.log(isString(&quot;12&quot;)); //trueconsole.log(isFunction(function () {})); //trueconsole.log(isFunction({})); //false 下面示例设计一个 wrap() 偏函数，该函数的主要功能是产生一个 HTML 包裹函数，即样式标签。 12345678910111213function wrap(tag) { var stag = '&lt;' + tag + '&gt;'; var etag = '&lt;/' + tag.replace(/s.*/, '') + '&gt;'; return function(x) { return stag + x + etag; }}var b = wrap('b');document.write(b('粗体字'));var i = wrap('i');document.write(i('斜体字'));var u = wrap('u');document.write(u('下划线字')); #javascript","link":"/2018/04/13/javascript/59144493da/"},{"title":"JS - CommonJS、ES2015、AMD、CMD模块规范对比与介绍","text":"CommonJS 基本介绍 CommonJS 是一种思想，它是为 JS 的表现来制定规范。由于 JS 没有模块系统、标准库较少、缺乏包管理工具，因此 CommonJS 应运而生。 CommonJS 的目标是希望 JS 可以在任何地方运行，不只是浏览器中。只要我们的 JavaScript 是根据 CommonJS API 编写的，那么就可以在与 CommonJS 兼容的系统上运行。 根据 CommonJS API 编写的 JavaScript 可以做下面这些事情： 编写服务端应用 编写命令行工具 编写基于 GUI 的桌面应用 CommonJS 规范有很多实现，最有名要数 NodeJS 了。 CommonJS 的模块规范一个文件就是一个模块，拥有单独的作用域。普通方式定义的变量、函数、对象都属于该模块内。 * 通过 require 来加载模块。 * 通过 exports 和 modul.exports 来暴露模块中的内容。 使用 exports 暴露模块接口 下面我们在 Node.js 中创建一个模块，文件名为：hangge.js 123exports.hello = function() { console.log('Hello hangge.com');} 创建一个 main.js 文件，引入这个模块并调用。 12var hangge = require('./hangge');hangge.hello(); 运行结果如下： 使用 modul.exports 暴露模块对象 下面我们把一个对象封装到模块中，文件名为：hangge.js 123456789101112131415//私有变量var test = 110; //公开方法function Hangge() { var name; this.setName = function(thyName) { name = thyName; }; this.hello = function() { console.log('Hello ' + name); };}; module.exports = Hangge; 创建一个 main.js 文件，引入这个模块并调用。 1234var Hangge = require('./hangge');var hello = new Hangge();hello.setName('hangge.com');hello.hello(); 运行结果如下： ES2015 基本介绍2015 年 6 月， ES2015（即 ECMAScript 6、ES6） 正式发布。ES2015 是该语言的一个显著更新，也是自 2009 年 ES5 标准确定后的第一个重大更新。虽然 ES2015 提出了许多令人激动的新特性，但由于目前 JavaScript 的运行环境众多，对 ECMAScript 标准的支持程度也不一样。 ES2015 的模块规范 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。 export 命令用于规定模块的对外接口。 import 命令用于输入其他模块提供的功能。 ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。 使用 export 命令规定对外接口 下面我们在 Node.js 中创建一个模块，文件名为：hangge.js 123456789//圆面积计算export function area(radius) { return Math.PI * radius * radius;} //圆周长计算export function circumference(radius) { return 2 * Math.PI * radius;} 创建一个 main.js 文件，引入这个模块并调用。这里 import 命令使用大括号的形式加载模块对外的接口。 123import {area,circumference} from './hangge';console.log('圆面积：' + area(10));console.log('圆周长：' + circumference(11)); 当然也可以使用星号（*）指定一个对象，实现模块的整体加载。 123import * as circle from './hangge';console.log('圆面积：' + circle.area(10));console.log('圆周长：' + circle.circumference(11)); 由于 NodeJS 目前还不支持 ES2015 的 Module，这里我们借助 babel-node 来执行，运行结果如下： 使用 export default 命令来输出模块 下面我们使用 export default 命令用于指定模块的默认输出。模块文件名为：hangge.js 123456789//圆面积计算（作为默认接口）export default function(radius) { return Math.PI * radius * radius;} //圆周长计算export function circumference(radius) { return 2 * Math.PI * radius;} 创建一个 main.js 文件，引入这个模块并调用。注意：对于 export default 指定模块的默认输出，import 语句不需要使用大括号。 123import area, {circumference} from './hangge';console.log('圆面积：' + area(10));console.log('圆周长：' + circumference(11)); 同样借助 babel-node 来执行，运行结果如下： 1，AMD 基本介绍 AMD 全称为 Asynchromous Module Definition（异步模块定义） AMD 是 RequireJS 在推广过程中对模块定义的规范化产出，它是一个在浏览器端模块化开发的规范。 AMD 模式可以用于浏览器环境并且允许非同步加载模块，也可以按需动态加载模块。 2，AMD 的模块规范 AMD 通过异步加载模块。模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。 AMD 规范只定义了一个函数 define，通过 define 方法定义模块。该函数的描述如下： define(id?, dependencies?, factory)* id：指定义中模块的名字（可选）。如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。 * dependencies：当前模块依赖的，已被模块定义的模块标识的数组字面量（可选）。 * factory：一个需要进行实例化的函数或者一个对象。 * AMD 规范允许输出模块兼容 CommonJS 规范，这时 define 方法如下： 12345678define(function (require, exports, module) { var reqModule = require(&quot;./someModule&quot;); requModule.test(); exports.asplode = function () { //someing }}); 独立模块 我们使用 RequireJS 定义一个不依赖其他模块得独立模块，文件名：hangge.js 12345678define(function(){ var add = function(x,y) { return x + y; }; return { add : add }}); 接着创建一个 html 页面，其内部加载并调用这个模块。 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;require.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; require(['hangge'], function (m){ console.log(m.add(2,3)); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 控制台输出如下： 使用样例2：存在依赖的函数式定义下面定义的模块又依赖于 cart 和 inventory 这两个模块（它们都处在同一个文件夹下） 123456789101112define([&quot;./cart&quot;, &quot;./inventory&quot;], function(cart, inventory) { //return an object to define the &quot;my/shirt&quot; module. return { color: &quot;blue&quot;, size: &quot;large&quot;, addToCart: function() { inventory.decrement(this); cart.add(this); } } }); CMD 基本介绍 CMD 全称为 Common Module Definition，它是国内玉伯大神在开发 SeaJS 的时候提出来的。 CMD 与 AMD 挺相近，二者区别如下： 对于依赖的模块 CMD 是延迟执行，而 AMD 是提前执行（不过 RequireJS 从 2.0 开始，也改成可以延迟执行。 ） CMD 推崇依赖就近，AMD 推崇依赖前置。 AMD 的 api 默认是一个当多个用，CMD 严格的区分推崇职责单一，其每个 API 都简单纯粹。例如：AMD 里 require 分全局的和局部的。CMD 里面没有全局的 require，提供 seajs.use() 来实现模块系统的加载启动。 使用 exports 暴露模块接口 下面使用 sea.js 创建一个模块，文件名为：hangge.js 12345678define(function(require, exports) { // 对外提供name属性 exports.name = 'hangge'; // 对外提供hello方法 exports.hello = function() { console.log('Hello hangge.com'); };}); 接着创建一个 html 页面，其内部加载并调用这个模块。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;sea.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; //加载一个模块，在加载完成时，执行回调 seajs.use('hangge', function(a) { a.hello(); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 控制台输出如下： 使用 modul.exports 暴露模块对象 下面我们把一个对象封装到模块中，文件名为：hangge.js 123456789define(function(require, exports, module) { // 对外提供接口 module.exports = { name: 'hangge', hello: function() { console.log('Hello hangge.com'); } };}); 接着创建一个 html 页面，其内部加载并调用这个模块。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;sea.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; //加载一个模块，在加载完成时，执行回调 seajs.use('hangge', function(a) { a.hello(); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 控制台输出如下： #javascript","link":"/2021/06/01/javascript/639b3d5fc8/"},{"title":"HTML5 Canvas生成粒子效果","text":"Installbreathing-halftone.pkgd.min.js Usage12345678910// get the image// jqueryvar img = $('#hero img')[0]// or vanilla JSvar img = document.querySelector('#hero img')// init halftonenew BreathingHalftone(img, { // options...}) Options1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556{ &quot;dotSize&quot;: 1 / 150, //点的大小 //作为图像对角线的一小部分 //较小的点=较多的点=性能较差 &quot;dotSizeThreshold&quot;: 0.05, //隐藏小于百分比的点 &quot;initVelocity&quot;: 0.1, //点开始增长的速度 &quot;oscPeriod&quot;: 3, //点大小振荡或“呼吸”周期的持续时间（以秒为单位） &quot;oscAmplitude&quot;: 0.2, //振荡变化百分比 &quot;isAdditive&quot;: false, //添加剂是带有RGB点的黑色， //减法为带有CMK点的白色 &quot;isRadial&quot;: false, //启用径向网格布局 &quot;channels&quot;: [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;], //点层 //'lum'是另一个受支持的通道，以实现亮度 &quot;isChannelLens&quot;: true, //禁用位移时更改点的大小 &quot;friction&quot;: 0.06, //较低的点使点更容易移动，较高的点使点更难 &quot;hoverDiameter&quot;: 0.2, //悬停效果的大小 //作为图像对角线的一小部分 &quot;hoverForce&quot;: 0.01, //悬停效果的力量 //负值会拉入点，正值会拉出 &quot;activeDiameter&quot;: 0.6, //点击/点击效果的大小 //作为图像对角线的一小部分 &quot;activeForce&quot;: 0.01 //悬停效果的力量 //负值会拉入点，正值会拉出} Dome12345678910&lt;script src=&quot;https://cdn.jsdelivr.net/gh/im/oss@master/js/breathing-halftone.pkgd.min.js&quot;&gt;&lt;/script&gt;&lt;img width=&quot;400&quot; height=&quot;400&quot; id=&quot;html5-canvas-particle-effect-dome&quot; src=&quot;/images/header/avatar.jpg&quot; /&gt;&lt;script&gt;window.onload = function () { var img = document.getElementById('html5-canvas-particle-effect-dome') new BreathingHalftone(img, { &quot;dotSize&quot;: 1 / 150 })}&lt;/script&gt; Quote http://breathing-halftone.desandro.com/ #javascript","link":"/2020/05/11/javascript/682be36b42/"},{"title":"JavaScript 实现复制粘贴","text":"实现思路html:1&lt;button onclick=&quot;copyToClip('内容')&quot;&gt;Copy&lt;/button&gt; javascript:123456789101112131415161718/** * 复制内容到粘贴板 * content : 需要复制的内容 * message : 复制完后的提示，不传则默认提示&quot;复制成功&quot; */function copyToClip(content, message) { var aux = document.createElement('input') aux.setAttribute('value', content) document.body.appendChild(aux) aux.select() document.execCommand('copy') document.body.removeChild(aux) if (message == null) { alert('复制成功') } else { alert(mesage) }} (clipboard.js)[https://clipboardjs.com/]直接引用： &lt;script src=&quot;dist/clipboard.min.js&quot;&gt;&lt;/script&gt; 包： npm install clipboard --save ，然后 import Clipboard from 'clipboard' html:12&lt;input id=&quot;demoInput&quot; value=&quot;hello world&quot; /&gt;&lt;button class=&quot;btn&quot; data-clipboard-target=&quot;#demoInput&quot;&gt;点我复制&lt;/button&gt; javascript:12import Clipboard from 'clipboard'const btnCopy = new Clipboard('btn') #javascript","link":"/2020/02/14/javascript/6ad8e8b409/"},{"title":"JavaScript 内存泄漏教程","text":"程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。 对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。 有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。 123456char * buffer;buffer = (char*) malloc(42);// Do something with bufferfree(buffer); 上面是 C 语言代码， malloc 方法用来申请内存，使用完毕之后，必须自己用 free 方法释放内存。 这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”（garbage collector）。 二、垃圾回收机制垃圾回收机制怎么知道，哪些内存不再需要呢？ 最常使用的方法叫做 “引用计数” （reference counting）：语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是 0 ，就表示这个值不再用到了，因此可以将这块内存释放。 上图中，左下角的两个值，没有任何引用，所以可以释放。 如果一个值不再需要了，引用数却不为 0 ，垃圾回收机制无法释放这块内存，从而导致内存泄漏。 12const arr = [1, 2, 3, 4];console.log('hello world'); 上面代码中，数组 [1, 2, 3, 4] 是一个值，会占用内存。变量 arr 是仅有的对这个值的引用，因此引用次数为 1 。尽管后面的代码没有用到 arr ，它还是会持续占用内存。 如果增加一行代码，解除 arr 对 [1, 2, 3, 4] 引用，这块内存就可以被垃圾回收机制释放了。 123let arr = [1, 2, 3, 4];console.log('hello world');arr = null; 上面代码中， arr 重置为 null ，就解除了对 [1, 2, 3, 4] 的引用，引用次数变成了 0 ，内存就可以释放出来了。 因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。 三、内存泄漏的识别方法怎样可以观察到内存泄漏呢？ 经验法则 是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。 3.1 浏览器Chrome 浏览器查看内存占用，按照以下步骤操作。 打开开发者工具，选择 Timeline 面板 在顶部的 Capture 字段里面勾选 Memory 点击左上角的录制按钮。 在页面上进行各种操作，模拟用户的使用情况。 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。 如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。 反之，就是内存泄漏了。 3.2 命令行命令行可以使用 Node 提供的 process.memoryUsage 方法。 12345console.log(process.memoryUsage());// { rss: 27709440,// heapTotal: 5685248,// heapUsed: 3449392,// external: 8772 } process.memoryUsage 返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，单位是字节， 含义 如下。 rss（resident set size）：所有内存占用，包括指令区和堆栈。 heapTotal：”堆”占用的内存，包括用到的和没用到的。 heapUsed：用到的堆的部分。 external： V8 引擎内部的 C++ 对象占用的内存。 判断内存泄漏，以 heapUsed 字段为准。 四、WeakMap前面说过，及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄漏。 最好能有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。 ES6 考虑到了这一点，推出了两种新的数据结构： WeakSet 和 WeakMap 。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个”Weak”，表示这是弱引用。 下面以 WeakMap 为例，看看它是怎么解决内存泄漏的。 123456const wm = new WeakMap();const element = document.getElementById('example');wm.set(element, 'some information');wm.get(element) // &quot;some information&quot; 上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对 element 的引用就是弱引用，不会被计入垃圾回收机制。 也就是说，DOM 节点对象的引用计数是 1 ，而不是 2 。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。 五、WeakMap 示例WeakMap 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 WeakMap 的键名了，导致无法证实那个键名是不是存在。 我一直想不出办法，直到有一天贺师俊老师 提示 ，如果引用所指向的值占用特别多的内存，就可以通过 process.memoryUsage 方法看出来。 根据这个思路，网友 vtxf 补充了下面的 例子 。 首先，打开 Node 命令行。 1$ node --expose-gc 上面代码中， --expose-gc 参数表示允许手动执行垃圾回收机制。 然后，执行下面的代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 手动执行一次垃圾回收，保证获取的内存使用状态准确&gt; global.gc(); undefined// 查看内存占用的初始状态，heapUsed 为 4M 左右&gt; process.memoryUsage(); { rss: 21106688, heapTotal: 7376896, heapUsed: 4153936, external: 9059 }&gt; let wm = new WeakMap();undefined&gt; let b = new Object();undefined&gt; global.gc();undefined// 此时，heapUsed 仍然为 4M 左右&gt; process.memoryUsage(); { rss: 20537344, heapTotal: 9474048, heapUsed: 3967272, external: 8993 }// 在 WeakMap 中添加一个键值对，// 键名为对象 b，键值为一个 5*1024*1024 的数组 &gt; wm.set(b, new Array(5*1024*1024));WeakMap {}// 手动执行一次垃圾回收&gt; global.gc();undefined// 此时，heapUsed 为 45M 左右&gt; process.memoryUsage(); { rss: 62652416, heapTotal: 51437568, heapUsed: 45911664, external: 8951 }// 解除对象 b 的引用 &gt; b = null;null// 再次执行垃圾回收&gt; global.gc();undefined// 解除 b 的引用以后，heapUsed 变回 4M 左右// 说明 WeakMap 中的那个长度为 5*1024*1024 的数组被销毁了&gt; process.memoryUsage(); { rss: 20639744, heapTotal: 8425472, heapUsed: 3979792, external: 8956 } 上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了它的帮助，解决内存泄漏就会简单很多。 JavaScript 内存泄漏教程 #javascript","link":"/2020/04/12/javascript/6ddb35e87f/"},{"title":"揭开在线协作的神秘面纱 – OT 算法","text":"相信大家或多或少都有使用过在线文档，国内的像我们在做的 腾讯文档 还有其他家的很多类似产品。今天主要为大家揭开在线协作的神秘面纱，那就是 OT 算法。 背景在线文档，抽象一下，这些产品的模式都是富文本编辑器+后台，富文本编辑器产生内容，展示内容，然后后台负责保存。富文本编辑器现在业界已经有很多成熟的产品，像 codeMirror ，这一块本身也是很复杂的一块，也不是咱们这次关注的重点方向。不知道大家平常在用这些产品的时候有没有思考过一个问题，在线文档编辑的时候产生冲突怎么办？ 举个栗子举个很简单的例子，现在大家的文本都是 ‘aaab’，A 用户在第 3 个字符行后面插入了一个 ‘c’，B 用户在第 3 个字符行后面插入了一个 ‘d’，这个时候 A 这边看到的是 ‘aaacb’，B 这边看到的是 ‘aaadb’, 我们假设 A 用户先提交了数据，那其实最后预期的数据其实应该是 ‘aaacdb’，这样就最大的保存了每个人的输入。 那我们现在来看看正常情况下这里会发生什么： A 用户： A 本地已经是 ‘aaacb’ 了，过一会儿，后台告诉它 B 也编辑了，编辑的行为就是 第 3 个字符行后面插入了一个 ‘d’ ，那 A 这边执行了这个行为，最终变成了 ‘aaadcb’ B 用户： B 本地已经是 ‘aaadb’ 了，过一会儿，后台告诉它 A 也编辑了，编辑的行为就是 第 3 个字符行后面插入了一个 ‘c’ ，那 B 这边执行了这个行为，最终变成了 ‘aaacdb’ 从上面的模拟过程可以看到，A 用户最后的结果其实是不正确的，但是 B 是正确的。 这里先解释一下大家可能会疑惑的地方：为什么 B 是过一会儿后台告诉它 A 编辑了，不是说 A 先提交了数据吗？其实这里针对的是冲突场景，这里如果 B 在提交之前，已经收到后台告诉它 A 编辑了，那其实就是顺序编辑了，也就不是冲突了。所以这里指的是 A，B 几乎同时提交，但是 A 到达后台还是快一点的，也就是 A，B 在编辑的时候是不知道彼此的存在的。 真实的冲突场景其实不是这种简单的时序问题，这里我后面再介绍。 尝试解决这里可能有一些聪明的小伙伴有了一些想法。 解决方案一：丢了丢了这可能是最简单粗暴的方法了，我发现有冲突，就告诉用户，主子，咱这里有冲突了，臣妾解决不了啊。但是显然这会经常出现，然后主子就把你打入冷宫了。 解决方案二：锁有些小伙伴想到，上面出现问题，还不是因为大家编辑了都立即应用了，我们编辑后不立即应用不就好了，而且历史告诉我们，有冲突加锁应该可以解决。那我们看看假如不立即应用，咱有没有什么处理办法： A 用户： A 本地已经是 ‘aaab’ 了，A 编辑了，但是不应用，先发后台 B 用户： B 本地已经是 ‘aaab’ 了，B 编辑了，但是不应用，先发后台 后台： 后台先收到 A 请求，然后加了一个锁，然后收到了 B 请求，这时侯应该是加锁的状态，所以接受了 A，拒绝了 B A 用户： A 用户收到了后台的回复，告诉它你的提交我接收了 B 用户： B 用户收到了后台的回复，告诉它你的提交被我拒绝了，因为冲突了 这样虽然能继续下去，但是好像还是不太行的亚子啊，B 的提交还是丢了，所以好像和第一种简单粗暴的方法没啥区别 OT 算法顺其自然的，这个时候你会看到 OT 算法驾着七彩祥云来救你了～其实回到上面的例子，本质问题还是因为后台通知大家的 B 的编辑行为看起来不太对。现在后台通知大家的是: B 的编辑的行为就是 第 3 个字符行后面插入了一个 ‘d’ 但是在 A 已经接受的情况下，正确的通知应该是： B 的编辑的行为就是 第 4 个字符行后面插入了一个 ‘d’ 假如我们把 A 提交的行为叫做 A，B 提交的行为叫做 B，现在后台就是一个简单的转发功能，告诉 A 的是 B，告诉 B 的是 A，然后就出现问题了。所以后台应该更聪明一点，它应该学会一个招术，那就是把每个人提交的行为转变一下再告诉别人，其实这个技术就是 OT 算法。 OT 算法全名叫 Operation Transformation ，你看从名字就对应了上面我说的转变算法。 假设我们的 OT 算法的转换功能叫 transform，那 transform（A，B）= A’,B’。 也就是说你输入两个先后执行的行为，它会告诉你两个转换过后的行为，然后把 A’行为告诉 B，把 B’行为告诉 A，这样大家再应用就相安无事了。 上面的图是 OT 的经典菱形图，也就是说 A 会变成 A’在 B 这边执行，B 会变成 B’在 A 这边执行。 这里实际抽象一下，用户永远就只有两个人，一个是自己，一个是服务端，只是服务端的操作可能来自很多人，如果不这样抽象，那一个个进行冲突处理可能会让你觉得无法理解。 那我们现在再来看看后台有了 OT 这个能力之后会发生什么： A 用户： A 本地已经是 ‘aaacb’ 了，过一会儿，后台告诉它 B 也编辑了，编辑的行为就是 第 4 个字符行后面插入了一个 ‘d’ ，那 A 这边执行了这个行为，最终变成了 ‘aaacdb’ B 用户： B 本地已经是 ‘aaadb’ 了，过一会儿，后台告诉它 A 也编辑了，编辑的行为就是 第 3 个字符行后面插入了一个 ‘c’ ，那 B 这边执行了这个行为，最终变成了 ‘aaacdb’ 现在 A、B 就一致了！ OT 算法的实现现在 OT 算法对我们来说就是一个黑盒，我们知道给一定的输入，它会有正确的输出，但是它是如何做到的呢？在介绍它的实现之前，我们需要抽象一下我们的操作行为，在之前我们的描述都是 第 3 个字符行后面插入了一个 ‘d’ 这里怎么转换成程序识别或者能用代码表达的呢？其实这也是 OT 的关键。 这里我直接揭晓答案： 所有对文本的操作都可以抽象成三个原子行为： R = Retain，保持操作 I = Insert，插入操作 D = Delete，删除操作 那之前的行为 第 3 个字符行后面插入了一个 ‘d’ 就会变成 R(3), I(‘d’) 也就是保持三个字符后插入 1 个 ‘d’，其实应该也很好理解，这里的操作就像操作数组一样，不管干什么，第一步你得先找到操作的下标。有了这三个原子以后，我们就可以看到： A = R(3),I(‘c’)B = R(3), I(‘d’) 一切准备就绪，我们可以开始看 OT 了，这里 OT 算法现在已经很成熟了，这里我以一个 github 上的 repo 为例： ot.js我们可以看看它的核心代码 (有删减，理解起来可能会比较复杂，感兴趣的可以深入思考一下)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Transform takes two operations A and B that happened concurrently and // produces two operations A' and B' (in an array) such that // `apply(apply(S, A), B') = apply(apply(S, B), A')`. This function is the // heart of OT. // 上面这个公式就是OT的核心，它产生了A',B',同时保证执行结果一致，S就是我们开始的状态，可以把这个和菱形图对应起来 // 整体执行流程有点像合并排序的过程。两个下标指针分别往前走 TextOperation.transform = function (operation1, operation2) { // operation1， operation2就是我们的A，B var operation1prime = new TextOperation(); // 就是A' var operation2prime = new TextOperation(); // 就是B' var ops1 = operation1.ops, ops2 = operation2.ops; var i1 = 0, i2 = 0; var op1 = ops1[i1++], op2 = ops2[i2++]; while (true) { // At every iteration of the loop, the imaginary cursor that both // operation1 and operation2 have that operates on the input string must // have the same position in the input string. // 其实这里就是说transform的核心是保证两者的下标一致，这样操作的才是同一个位置的数据 // ... // next two cases: one or both ops are insert ops // =&gt; insert the string in the corresponding prime operation, skip it in // the other one. If both op1 and op2 are insert ops, prefer op1. // 如果A是插入操作，A'一定也是插入，但是B'就不一样了，因为A是插入，不管你B是啥，你先等等，所以retain一下，保证下标一致 // 这里实际上有三种情况，A是插入，B可能是R，I，D if (isInsert(op1)) { operation1prime.insert(op1); operation2prime.retain(op1.length); op1 = ops1[i1++]; continue; } // 如果B也是插入，那B’就是插入，但是你的A'也得retain一下，保证下标一致 // 这里可能有两者情况，A可能是R，D // 实例化思考一下，A [R(3),I('a')],B [I('b')],那对于A'来说就应该是[R(4),I('a')] if (isInsert(op2)) { operation1prime.retain(op2.length); operation2prime.insert(op2); op2 = ops2[i2++]; continue; } // ... var minl; if (isRetain(op1) &amp;&amp; isRetain(op2)) { // R和R处理 } else if (isDelete(op1) &amp;&amp; isDelete(op2)) { //D和D处理 } else if (isDelete(op1) &amp;&amp; isRetain(op2)) { // D和R处理 } else if (isRetain(op1) &amp;&amp; isDelete(op2)) { //R和D处理 } } return [operation1prime, operation2prime]; }; 这里就是 OT 的 transform 实现，本质上就是把用户的原子操作数组拿到以后，然后做 transform 操作，这里我只选了一小段来大概解析下，具体的可以看注释，其实原本的注释已经很全了。 其实上面那段代码，因为我们的原子操作只有三种，根据排列组合，最多只会有 9 种情况，只是上面把很多情况合并了，你要是不理解，也可以拆开，帮助理解。 其实上面的文件还有 compose，invert 等方法，但是其实 transform 才是我们理解的核心，其他方法大家感兴趣可以看看注释和下面贴的一些关于 OT 更详细介绍的文章。 OT 算法的时序简单的 OT 大家只要理解了，好像也并不是很难，但是其实真实情况下 OT 会比想象的还要复杂，因为之前说的菱形会无限拓展。 简单理解一下，就是 A 本地产生了两次编辑，B 产生了一次。这里就必须要和大家解释一下之前遗留的时序问题了，不然可能无法理解。 之前说的时序都是指时间先后顺序，冲突也是指同时产生编辑。但是其实这里的同时不是时间上的同时，而是 版本上的同时 。 也就是说我们需要用一个东西表示每一个版本，类似 git 的每次提交，每次提交到服务端的时候就要告诉后端，我的修改是基于哪个版本的修改。 最简单的标志位就是 递增的数字 。那基于版本的冲突，可以简单理解为我们都是基于 100 版本的提交，那就是冲突了，也许我们并不是同时， 谁先到后台决定了谁先被接受而已 。这里最夸张的就是离线编辑，可能正常版本已经到了 1000 了，某个用户因为离线了，本地的版本一直停留在 100，提交上来的版本是基于 100 的。 那有了时序的概念，我们再看上面这个菱形，它可以理解成 A 和 B 都基于 100 提交了数据，但是在 A 的提交还没被后台确认的时候，A 又编辑了，但是因为上一次提交没被确认，所以这次不会发到后台，这时服务器告诉它 B 基于 100 做了提交。 这种情况下如何处理，就有点类似于 OT 落地到实践当中，你怎么实现了，上面提到的 github 的那个 repo 的实现其实非常巧妙，你看完注释应该就能全部理解，这里给出 代码链接 精华就在于它把本地分成了几个状态： Synchronized 没有正在提交并且等待回包的 operation AwaitingConfirm 有一个 operation 提交了但是等后台确认，本地没有编辑数据 AwaitingWithBuffer 有一个 operation 提交了但是等后台确认，本地有编辑数据 剩下的就是在这三种状态下，收到了本地和服务端的数据，分别应该怎么处理 结语其实 OT 对应的只是一种思想，具体怎么实现是根据具体情况来区分的，比如我们现在讨论的就是文本的 OT，那有可能图的 OT、表格的 OT 又是其他的实现。OT 的核心就是 transform，而 transform 的核心就在于你怎么找到这样的原子操作了，然后原子操作的复杂度决定了 transform 实现的复杂度。 上面这个 repo 只是帮你实现了文本的协同处理，其实对于在线文档来说，还有样式的冲突处理，感兴趣的可以自己搜索相关资料了解一下，建议精读一下 ot.js 这个库。 最后如果读完这篇文章你对在线协作有了一定的认知，那这篇文章的使命也就达到了，最后如果有写的不正确的地方，欢迎斧正～ 参考资料understanding-and-applying-operational-transformationot.js 揭开在线协作的神秘面纱 – OT 算法 #javascript","link":"/2017/02/08/javascript/7cf9dbe629/"},{"title":"JavaScript 的静态作用域链与“动态”闭包链","text":"读完本文会解答你以下疑问： 静态作用域链和动态作用域链的区别 为什么会有闭包 闭包什么时候创建的 [[scopes]] 属性是什么 闭包保存什么内容 闭包存储在哪 为什么 eval 性能不好 eval 什么情况下会创建闭包 在 JavaScript 里面，函数、块、模块都可以形成作用域（一个存放变量的独立空间），他们之间可以相互嵌套，作用域之间会形成引用关系，这条链叫做作用域链。 作用域链具体是什么样呢？ 静态作用域链比如这样一段代码 1234567891011function func() { const guang = 'guang'; function func2() { const ssh = 'ssh'; { function func3 () { const suzhe = 'suzhe'; } } }} 其中，有 guang、ssh、suzhe 3个变量，有 func、func2、func3 3个函数，还有一个块，他们之间的作用域链可以用babel查看一下。 12345678910111213141516171819202122232425const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const code = ` function func() { const guang = 'guang'; function func2() { const ssh = 'ssh'; { function func3 () { const suzhe = 'suzhe'; } } } }`;const ast = parser.parse(code);traverse(ast, { FunctionDeclaration (path) { if (path.get('id.name').node === 'func3') { console.log(path.scope.dump()); } }}) 结果是 用图可视化一下就是这样的 函数和块的作用域内的变量声明会在作用域 （scope） 内创建一个绑定（变量名绑定到具体的值，也就是 binding），然后其余地方可以引用 （refer） 这个 binding，这样就是静态作用域链的变量访问顺序。 为什么叫“静态”呢？ 因为这样的嵌套关系是分析代码就可以得出的，不需要运行，按照这种顺序访问变量的链就是静态作用域链，这种链的好处是可以直观的知道变量之间的引用关系。 相对的，还有动态作用域链，也就是作用域的引用关系与嵌套关系无关，与执行顺序有关，会在执行的时候动态创建不同函数、块的作用域的引用关系。缺点就是不直观，没法静态分析。 静态作用域链是可以做静态分析的，比如我们刚刚用 babel 分析的 scope 链就是。所以绝大多数编程语言都是作用域链设计都是选择静态的顺序。 但是，JavaScript 除了静态作用域链外，还有一个特点就是函数可以作为返回值。比如 1234567function func () { const a = 1; return function () { console.log(a); }}const f2 = func(); 这就导致了一个问题，本来按照顺序创建调用一层层函数，按顺序创建和销毁作用域挺好的，但是如果内层函数返回了或者通过别的暴露出去了，那么外层函数销毁，内层函数却没有销毁，这时候怎么处理作用域，父作用域销不销毁？ （比如这里的 func 调用结束要不要销毁作用域） 不按顺序的函数调用与闭包比如把上面的代码做下改造，返回内部函数，然后在外面调用： 12345678910111213function func() { const guang = 'guang'; function func2() { const ssh = 'ssh'; function func3 () { const suzhe = 'suzhe'; } return func3; } return func2;}const func2 = func(); 当调用 func2 的时候 func1 已经执行完了，这时候销不销毁 ？于是 JavaScript 就设计了闭包的机制。 闭包怎么设计？先不看答案，考虑一下我们解决这个静态作用域链中的父作用域先于子作用域销毁怎么解决。 首先，父作用域要不要销毁？ 是不是父作用域不销毁就行了？ 不行的，父作用域中有很多东西与子函数无关，为啥因为子函数没结束就一直常驻内存。这样肯定有性能问题，所以还是要销毁。 但是销毁了父作用域不能影响子函数，所以要再创建个对象，要把子函数内引用（refer）的父作用域的变量打包里来，给子函数打包带走。 怎么让子函数打包带走？ 设计个独特的属性，比如 [[Scopes]]，用这个来放函数打包带走的用到的环境。并且这个属性得是一个栈，因为函数有子函数、子函数可能还有子函数，每次打包都要放在这里一个包，所以就要设计成一个栈结构，就像饭盒有多层一样。 我们所考虑的这个解决方案：销毁父作用域后，把用到的变量包起来，打包给子函数，放到一个属性上。这就是闭包的机制。 我们来试验一下闭包的特性： 这个 func3 需不需要打包一些东西？ 会不会有闭包？ 其实还是有闭包的，闭包最少会包含全局作用域。 但是为啥 guang、ssh、suzhe 都没有 ？ suzhe是因为不是外部的，只有外部变量的时候才会生成，比如我们改动下代码，打印下这 3 个变量。 再次查看 [[Scopes]] （打包带走的闭包环境）： 这时候就有俩闭包了，为什么呢？ suzhe 哪去了？ 首先，我们需要打包的只是环境内没有的，也就是闭包只保存外部引用。然后是在创建函数的时候保存到函数属性上的，创建的函数返回的时候会打包给函数，但是 JS 引擎怎么知道它要用到哪些外部引用呢，需要做 AST 扫描，很多 JS 引擎会做 Lazy Parsing，这时候去 parse 函数，正好也能知道它用到了哪些外部引用，然后把这些外部用打包成 Closure 闭包，加到 [[scopes]] 中。 所以， 闭包是返回函数的时候扫描函数内的标识符引用，把用到的本作用域的变量打成 Closure 包，放到 [[Scopes]] 里。 所以上面的函数会在 func3 返回的时候扫描函数内的标识符，把 guang、ssh 扫描出来了，就顺着作用域链条查找这俩变量，过滤出来打包成两个 Closure（因为属于两个作用域，所以生成两个 Closure），再加上最外层 Global，设置给函数 func3 的 [[scopes]] 属性，让它打包带走。 调用 func3 的时候，JS 引擎 会取出 [[Scopes]] 中的打包的 Closure + Global 链，设置成新的作用域链， 这就是函数用到的所有外部环境了，有了外部环境，自然就可以运行了。 这里思考一个问题： 调试代码的时候为什么遇到过某个变量明明在作用域内能访问到，但就是没有相关信息呢？ 这个 traverse，明明能访问到的，为啥就是不显示信息呢？是 debugger 做的太烂了么？ 不是的，如果你不知道原因，那是因为你还不理解闭包，因为这个 FunctionDeclaration 的函数是一个回调函数，明显是在另一个函数内调用的，就需要在创建的时候打包带走这个环境内的东西，根据只打包必要的环境的原则（不浪费内存），traverse 没有被引用（refer），自然就不打包了。并不是 debugger 有 bug 了。 所以我们只要访问一下，就能在调试的时候访问到了。 是不是突然知道为啥调试的时候不能看一些变量的信息了，能解释清楚这个现象，就算理解闭包了。 eval再来思考一个问题： 闭包需要扫描函数内的标识符，做静态分析，那 eval 怎么办，他有可能内容是从网络记载的，从磁盘读取的等等，内容是动态的。用静态去分析动态是不可能没 bug 的。怎么办？ 没错，eval 确实没法分析外部引用，也就没法打包闭包，这种就特殊处理一下，打包整个作用域就好了。 验证一下： 这个就像上面所说的，会把外部引用的打包成闭包 这个就是 eval 的实现，因为没法静态分析动态内容所以全部打包成闭包了，本来闭包就是为了不保存全部的作用域链的内容，结果 eval 导致全部保存了，所以尽量不要用 eval。会导致闭包保存内容过多。 但是 JS 引擎只处理了直接调用，也就是说直接调用 eval 才会打包整个作用域，如果不直接调用 eval，就没法分析引用，也就没法形成闭包了。 这种特殊情况有的时候还能用来完成一些黑魔法，比如利用不直接调用 eval 不会生成闭包，会在全局上下文执行的特性。 给闭包下个定义用我们刚刚的试验来给闭包下个定义： 闭包是在函数创建的时候，让函数打包带走的根据函数内的外部引用来过滤作用域链剩下的链。它是在函数创建的时候生成的作用域链的子集，是打包的外部环境。evel 因为没法分析内容，所以直接调用会把整个作用域打包（所以尽量不要用 eval，容易在闭包保存过多的无用变量），而不直接调用则没有闭包。 过滤规则： 全局作用域不会被过滤掉，一定包含。所以在何处调用函数都能访问到。 其余作用域会根据是否内部有变量被当前函数所引用而过滤掉一些。不是每个返回的子函数都会生成闭包。 被引用的作用域也会过滤掉没有被引用的 binding （变量声明）。只把用到的变量打个包。 闭包的缺点JavaScript 是静态作用域的设计，闭包是为了解决子函数晚于父函数销毁的问题，我们会在父函数销毁时，把子函数引用到的变量打成 Closure 包放到函数的 [[Scopes]] 上，让它计算父函数销毁了也随时随地能访问外部环境。 这样设计确实解决了问题，但是有没有什么缺点呢？ 其实问题就在于这个 [[Scopes]] 属性上 我们知道 JavaScript 引擎会把内存分为函数调用栈、全局作用域和堆，其中堆用于放一些动态的对象，调用栈每一个栈帧放一个函数的执行上下文，里面有一个 local 变量环境用于放内部声明的一些变量，如果是对象，会在堆上分配空间，然后把引用保存在栈帧的 local 环境中。全局作用域也是一样，只不过一般用于放静态的一些东西，有时候也叫静态域。 每个栈帧的执行上下文包含函数执行需要访问的所有环境，包括 local 环境、作用域链、this等。 那么如果子函数返回了会发生什么呢？ 首先父函数的栈帧会销毁，子函数这个时候其实还没有被调用，所以还是一个堆中的对象，没有对应的栈帧，这时候父函数把作用域链过滤出需要用到的，形成闭包链，设置到子函数的 [[Scopes]] 属性上。 父函数销毁，栈帧对应的内存马上释放，用到的 ssh Obj 会被 gc 回收，而返回的函数会把作用域链过滤出用到的引用形成闭包链放在堆中。 这就导致了一个隐患： 如果一个很大的对象被函数引用，本来函数调用结束就能销毁，但是现在引用却被通过闭包保存到了堆里，而且还一直用不到，那这块堆内存就一直没法使用，严重到一定程度就算是内存泄漏了。所以闭包不要乱用，少打包一点东西到堆内存。 总结我们从静态作用域开始聊起，明确了什么是作用域，通过 babel 静态分析了一下作用域，了解了下静态和动态作用域，然后引入了子函数先于父函数销毁的问题，思考了下方案，然后引入了闭包的概念，分析下闭包生成的流程，保存的位置。我们还用闭包的特性分析了下为什么有时候调试的时候查看不了变量信息，之后分析了下 eval 为什么没法精确生成闭包，什么时候全部打包作用域、什么时候不生成闭包， eval 为什么会导致内存占用过多。之后分析了下带有闭包的函数在内存中的特点，解释了下为啥可能会内存泄漏。 闭包是在返回一个函数的时候，为了把环境保存下载，创建的一个快照，对作用域链做了tree shking，只留下必要的闭包链，保存在堆里，作为对象的 [[scopes]] 属性，让函数不管走到哪，随时随地可访问用到的外部环境。在执行这个函数的时候，会利用这个“快照”，恢复作用域链。 因为还没执行函数，所以要静态分析标识符引用。静态分析动态这件事情被无数个框架证明做不了，所以返回的函数有eval 只能全部打包或者不生成闭包。类似webpack 的动态import没法分析一样。 JavaScript 的静态作用域链与“动态”闭包链 #javascript/closure","link":"/2020/01/15/javascript/b7b73df6f6/"},{"title":"高阶函数","text":"JavaScript的函数可以指向某个变量，变量也可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 简单的高阶函数123456789101112function add(x, y, f) { return f(x) + f(y);}//当调用add(-5, 6, Math.abs)时，参数x，y和f分别接收-5，6和函数Math.abs，根据函数定义，可以推导计算过程为：//x = -5;//y = 6;//f = Math.abs;//f(x) + f(y) ==&gt; Math.abs(-5) + Math.abs(6) ==&gt; 11;//return 11;//用代码验证一下：add(-5, 6, Math.abs); // 11 常用的高阶函数map1234567891011121314151617181920function pow(x) { return x * x;}var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]//map()传入的参数是pow，即函数对象本身。//不需要map()，写一个循环，也可以计算出结果：var f = function (x) { return x * x;};var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var result = [];for (var i=0; i&lt;arr.length; i++) { result.push(f(arr[i]));}//的确可以，但是，从上面的循环代码，我们无法一眼看明白“把f(x)作用在Array的每一个元素并把结果生成一个新的Array”。 所以，map() 作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的 f(x)=x2，还可以计算任意复杂的函数，比如，把 Array 的所有数字转为字符串： 123var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9']//只需要一行代码。 reduce再看 reduce 的用法。Array 的 reduce() 把一个函数作用在这个 Array 的 [x1, x2, x3…] 上，这个函数必须接收两个参数，reduce() 把结果继续和序列的下一个元素做累积计算，其效果就是： 1234567[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)//比方说对一个Array求和，就可以用reduce实现：var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) { return x + y;}); // 25 filterfilter 也是一个常用的操作，它用于把 Array 的某些元素过滤掉，然后返回剩下的元素。和 map() 类似，Array 的 filter() 也接收一个函数。和 map() 不同的是，filter() 把传入的函数依次作用于每个元素，然后根据返回值是 true 还是 false 决定保留还是丢弃该元素。 12345678910111213//例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：var arr = [1, 2, 4, 5, 6, 9, 10, 15];var r = arr.filter(function (x) { return x % 2 !== 0;});r; // [1, 5, 9, 15]//把一个Array中的空字符串删掉，可以这么写：var arr = ['A', '', 'B', null, undefined, 'C', ' '];var r = arr.filter(function (s) { return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法});arr; // ['A', 'B', 'C'] 回调函数：filter() 接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示 Array 的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身： 123456789101112131415161718var arr = ['A', 'B', 'C'];var r = arr.filter(function (element, index, self) { console.log(element); // 依次打印'A', 'B', 'C' console.log(index); // 依次打印0, 1, 2 console.log(self); // self就是变量arr return true;});//利用filter，可以巧妙地去除Array的重复元素：'use strict';var r, arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];r = arr.filter(function (element, index, self) { return self.indexOf(element) === index;});alert(r.toString());//去除重复元素依靠的是indexOf总是返回第一个元素的位置，后续的重复元素位置与indexOf返回的位置不相等，因此被filter滤掉了。 sort因为 Array 的 sort()方法默认把所有元素先转换为String再排序，结果’10’排在了’2’的前面，因为字符’1’比字符’2’的ASCII码小。如果不知道 sort() 方法的默认排序规则，直接对数字排序，绝对栽进坑里！ 幸运的是，sort() 方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//要按数字大小排序，我们可以这么写：var arr = [10, 20, 1, 2];arr.sort(function (x, y) { if (x &lt; y) { return -1; } if (x &gt; y) { return 1; } return 0;}); // [1, 2, 10, 20]//如果要倒序排序，我们可以把大的数放前面：var arr = [10, 20, 1, 2];arr.sort(function (x, y) { if (x &lt; y) { return 1; } if (x &gt; y) { return -1; } return 0;}); // [20, 10, 2, 1]//默认情况下，对字符串排序，是按照ASCII的大小比较的，现在，排序应该忽略大小写，按照字母序排序。//要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：var arr = ['Google', 'apple', 'Microsoft'];arr.sort(function (s1, s2) { x1 = s1.toUpperCase(); x2 = s2.toUpperCase(); if (x1 &lt; x2) { return -1; } if (x1 &gt; x2) { return 1; } return 0;}); // ['apple', 'Google', 'Microsoft']//忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。//sort()方法会直接对Array进行修改，它返回的结果仍是当前Array：var a1 = ['B', 'A', 'C'];var a2 = a1.sort();a1; // ['A', 'B', 'C']a2; // ['A', 'B', 'C']a1 === a2; // true, a1和a2是同一对象 #javascript","link":"/2016/01/23/javascript/bd4367dc13/"},{"title":"函数柯里化","text":"柯里化 - 维基百科，自由的百科全书把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。 柯里化有3个常见作用： 参数复用 提前确定 延迟计算/运行 基本实现12345var foo = function(a) { return function(b) { return a * a + b * b; }} 调用上述函数：(foo(3))(4)，或直接foo(3)(4) 参数复用1234567891011121314151617181920212223// 正常正则验证字符串 reg.test(txt)// 函数封装后function check(reg, txt) { return reg.test(txt)}check(/\\d+/g, 'test') //falsecheck(/[a-z]+/g, 'test') //true// Currying后function curryingCheck(reg) { return function(txt) { return reg.test(txt) }}var hasNumber = curryingCheck(/\\d+/g)var hasLetter = curryingCheck(/[a-z]+/g)hasNumber('test1') // truehasNumber('testtest') // falsehasLetter('21212') // false 上面的示例是一个正则的校验，正常来说直接调用check函数就可以了，但是如果我有很多地方都要校验是否有数字，其实就是需要将第一个参数reg进行复用，这样别的地方就能够直接调用hasNumber，hasLetter等函数，让参数能够复用，调用起来也更方便。 提前确定1234567891011function makeMap(str) { var map = Object.create(null); var list = str.split(&quot;,&quot;); for (var i = 0; i &lt; list.length; i++) { map[list[i]] = true; } return function (val) { return map[val.toLowerCase()]; };} 12345678910111213var isHTMLTag = makeMap( 'html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot' ); 这是vue源码中的一个方法，用这个方法来判断当前自定义标签跟html，这里就用了提前确认， 先将所有的标签都存入一个对象，然后每次查找只需要匹配对象里面是否存在该标签，这样就能防止多次循环遍历查找对应的标签 1isHTMLTag('div') 延迟执行12345678910111213141516const curryAdd = function(...rest) { const _args = rest return function cb(...rest) { if (rest.length === 0) { return _args.reduce((sum, single) =&gt; sum += single) } else { _args.push(...rest) return cb } }}() // 为了保存添加的数，这里要返回一个闭包curryAdd(1)curryAdd(2)curryAdd(3)curryAdd(4)curryAdd() // 最后计算输出:10 经典面试题12345678910111213141516171819202122232425262728// 实现一个add方法，使计算结果能够满足如下预期：add(1)(2)(3) = 6;add(1, 2, 3)(4) = 10;add(1)(2)(3)(4)(5) = 15;function add() { // 第一次执行时，定义一个数组专门用来存储所有的参数 var _args = Array.prototype.slice.call(arguments); // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值 var _adder = function() { _args.push(...arguments); return _adder; }; // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回 _adder.toString = function () { return _args.reduce(function (a, b) { return a + b; }); } return _adder;}add(1)(2)(3) // 6add(1, 2, 3)(4) // 10add(1)(2)(3)(4)(5) // 15add(2, 6)(1) // 9 #javascript","link":"/2018/02/04/javascript/f35160fe91/"},{"title":"Mac 设置环境变量 path 的几种方法","text":"Mac系统的环境变量，加载顺序为： 系统 /etc/profile /etc/paths /etc/profile 和 /etc/paths 是系统级别的，系统启动就会加载 用户 ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc 按照从前往后的顺序读取，如果 ~/.bash_profile 文件存在，则后面的几个文件就会被忽略不读了，如果 ~/.bash_profile 文件不存在，才会以此类推读取后面的文件。~/.bashrc 没有上述规则，它是 bash shell 打开的时候载入的 如果没特殊说明,设置PATH的语法都为： 1export PATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:------:&lt;PATH N&gt; 全局设置下面的几个文件设置是全局的，修改时需要root权限 /etc/paths （全局建议修改这个文件 ）编辑 paths，将环境变量添加到 paths 文件中 ，一行一个路径Hint：输入环境变量时，不用一个一个地输入，只要拖动文件夹到 Terminal 里就可以了。 /etc/profile （建议不修改这个文件 ）全局（公有）配置，不管是哪个用户，登录时都会读取该文件。 /etc/bashrc （一般在这个文件中添加系统级环境变量）全局（公有）配置，bash shell 执行时，不管是何种方式，都会读取此文件。 创建一个文件：1sudo touch /etc/paths.d/mysql 用 vim 打开这个文件（如果是以 open -t 的方式打开，则不允许编辑）：1sudo vim /etc/paths.d/mysql 编辑该文件，键入路径并保存（关闭该 Terminal 窗口并重新打开一个，就能使用 mysql 命令了）1/usr/local/mysql/bin 据说，这样可以自己生成新的文件，不用把变量全都放到 paths 一个文件里，方便管理。 单个用户设置 ~/.bash_profile （任意一个文件中添加用户级环境变量）（注：Linux 里面是 .bashrc 而 Mac 是 .bash_profile）若bash shell是以login方式执行时，才会读取此文件。该文件仅仅执行一次!默认情况下,他设置一些环境变量设置命令别名alias ll=’ls -la’ 设置环境变量： 1export PATH=/opt/local/bin:/opt/local/sbin:$PATH ~/.bashrc 同上 如果想立刻生效，则可执行下面的语句： 1$ source 相应的文件 一般环境变量更改后，重启后生效。 #other","link":"/2020/12/03/other/11bdcb2489/"},{"title":"你是哪种程序员？","text":"1.对待需求的态度 优秀程序员 ：在有需求与任务时，会不断的询问需求与任务，并且多次确认想要的结果，再动手写代码。 一般程序员 ：接到任务就闷头写代码，反正做错了也是你们要求的，不是我的锅。 2.编码习惯 优秀程序员 ：他的代码读起来是赏心悦目的，若遇到难理解的实现点时，他也会写下清晰的注释来帮助后来人理解。 一般程序员 ：我有我的代码风格，我看得懂就行了。几个月后我也看不懂了，那就重写一遍吧。 3. 善于学习 优秀程序员 ：遇到没接触过的技术时，他会主动搜索资料去学习钻研，并以此为乐趣。 一般程序员 ：疯狂地找插件，类库和框架，常常做代码搬运工，安慰自己不要造轮子。 4. 对工作精益求精 优秀程序员 ：会抽时间review自己的代码，并思考如何提高性能。 一般程序员 ：只喜欢开发新项目，不喜欢维护旧项目，万一搞崩了呢？ 5. 有钻研精神 优秀程序员 ：遇到问题，会考虑独立寻求解决办法，提升自己处理问题的能力。 一般程序员 ：喜欢把问题交给别人，把代码发给被人，让别人帮他找问题。 6. 良好的情绪管理 优秀程序员 ：理解需求是会不断变化的，不会把消极情绪表达出来，能控制好情绪，能跟产品经理和谐愉快沟通。 一般程序员 ：因为需求反复修改就索性说这个代码实现不了。 7. 态度很谦虚 优秀程序员 ：对新的技术敏感度，保持学习的热情，而且为人很谦虚，不觉得自己有多牛。 一般程序员 ：生怕别人不觉得他是大牛，到处瞎逼逼。 #other","link":"/2018/05/14/other/9ae83d9a2f/"},{"title":"ios 提醒事项同步日历快捷指令脚本","text":"AppStore 安装运行脚本的软件 scriptable scriptable https://docs.scriptable.app 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115const DUR_MONTH = 1const startDate = new Date()startDate.setMonth(startDate.getMonth() - DUR_MONTH)console.log(`日历的开始时间 ${startDate.toLocaleDateString()}`)const endDate = new Date()endDate.setMonth(endDate.getMonth() + DUR_MONTH)console.log(`日历的结束时间 ${endDate.toLocaleDateString()}`)const reminders = await Reminder.allDueBetween(startDate, endDate)console.log(`获取 ${reminders.length} 条提醒事项`)var calendar = await Calendar.forEvents()//获取日历名和对应的日历var m_dict = {}for (cal of calendar) { m_dict[cal.title] = cal}const events = await CalendarEvent.between(startDate, endDate, calendar)console.log(`获取 ${events.length} 条日历`)for (const reminder of reminders) { //reminder的标识符 const id = reminder.identifier.split('-')[0] const targetNote = `🍧 ${id} 🍰` // 添加标识符存进备注 用来防止重复添加 const [targetEvent] = events.filter( (e) =&gt; e.notes != null &amp;&amp; e.notes.indexOf(targetNote) != -1 ) //过滤重复的reminder if (!m_dict[reminder.calendar.title]) { console.warn('找不到日历' + reminder.calendar.title) continue } if (targetEvent) { //console.log(`找到已经创建的事项 ${reminder.title}`) updateEvent(targetEvent, reminder) } else { console.warn(`创建事项 ${reminder.title} 到 ${reminder.calendar.title}`) const newEvent = new CalendarEvent() const notes = reminder.notes ? reminder.notes : '' newEvent.notes = targetNote + '\\n\\n' + notes //要加入备注 updateEvent(newEvent, reminder) }}Script.complete()function updateEvent(event, reminder) { event.title = `${reminder.title}` cal_name = reminder.calendar.title cal = m_dict[cal_name] event.calendar = cal //已完成事项 if (reminder.isCompleted) { event.title = `✅ ${reminder.title}` event.isAllDay = false event.startDate = reminder.completionDate var ending = new Date(reminder.completionDate) ending.setHours(ending.getHours() + 1) event.endDate = ending var period = (reminder.dueDate - reminder.completionDate) / 1000 / 3600 / 24 period = period.toFixed(1) if (period &lt; 0) { period = -period event.location = ' 延期' + period + '天完成' } else if (period == 0) { event.location = ' 准时完成' } else { event.location = ' 提前' + period + '天完成' } } //未完成事项 else { const nowtime = new Date() var period = (reminder.dueDate - nowtime) / 1000 / 3600 / 24 period = period.toFixed(1) if (period &lt; 0) { //待办顺延 event.location = ' 延期' + -period + '天' //如果不是在同一天,设置为全天事项 if (reminder.dueDate.getDate() != nowtime.getDate()) { event.title = `❌ ${reminder.title}` event.startDate = nowtime event.endDate = nowtime event.isAllDay = true } //在同一天的保持原来的时间 else { event.title = `⭕️ ${reminder.title}` event.isAllDay = false event.startDate = reminder.dueDate var ending = new Date(reminder.dueDate) ending.setHours(ending.getHours() + 1) event.endDate = ending } console.log(`【${reminder.title}】待办顺延${-period}天`) } else { event.title = `⭕️ ${reminder.title}` event.isAllDay = false event.location = '还剩' + period + '天' event.startDate = reminder.dueDate var ending = new Date(reminder.dueDate) ending.setHours(ending.getHours() + 1) event.endDate = ending } } event.save()} 提醒事项数据格式 12345678910111213141516171819202122232425{ &quot;identifier&quot;: &quot;29803A1E-6C2F-454D-B366-2C67EB1F24BD&quot;, &quot;title&quot;: &quot;Recite word&quot;, &quot;isCompleted&quot;: false, &quot;isOverdue&quot;: true, &quot;priority&quot;: 0, &quot;dueDate&quot;: &quot;2021-03-11T23:20:00.000Z&quot;, &quot;dueDateIncludesTime&quot;: true, &quot;completionDate&quot;: null, &quot;creationDate&quot;: &quot;2021-03-12T03:28:00.621Z&quot;, &quot;calendar&quot;: { &quot;identifier&quot;: &quot;282088E0-DC16-4827-BA21-9B9FD5F0A16F&quot;, &quot;title&quot;: &quot;Learn&quot;, &quot;isSubscribed&quot;: false, &quot;allowsContentModifications&quot;: true, &quot;color&quot;: { &quot;hex&quot;: &quot;FF2968&quot;, &quot;red&quot;: 1, &quot;green&quot;: 0.1607843041419983, &quot;blue&quot;: 0.40784314274787903, &quot;alpha&quot;: 1 } }} ios 提醒事项同步日历快捷指令脚本 #other","link":"/2018/08/17/other/f93e2faf81/"},{"title":"占位图","text":"写页面的有时候需要一些临时的占位符图片，下面是常用的几种免费占位图片网站 picsum.photos (https://picsum.photos/)支持https, 而且图片特别多, 随机图片, 模糊图片, 宽高, 唯一的缺点就是感觉请求有点慢 图片地址 说明 https://picsum.photos/list 查看所有图片 https://picsum.photos/200 正方形图片 只想要一个值 https://picsum.photos/200/300 设置宽高 https://picsum.photos/500/300/?random 随机获取图片 https://picsum.photos/id/0/200/300 指定特定图片 https://picsum.photos/g/200/300 将图片变成灰色 只需要加一个 /g/ https://picsum.photos/200/300/?blur 模糊图片 1![](/images/?random~) fakeimg.pl(https://fakeimg.pl)如果你只需要使用文字，这个就特别好用了， 支持背景颜色，文字颜色，文字样式， 他的访问速度还很快 图片地址 说明 https://fakeimg.pl/400x300 设置宽高 https://fakeimg.pl/400x300/ba8f6c/FFFFFF/ 设置背景颜色 字体颜色 https://fakeimg.pl/400x300/ba8f6c/FFFFFF/?text=text 设置显示的文字 https://fakeimg.pl/400x300/ba8f6c/FFFFFF/?text=RegExp&amp;font=noto 设置字体样式 font=lobster 1![](/images/?text=糖小米&amp;font=noto~) #other","link":"/2018/01/23/other/f986e0d132/"},{"title":"iframe 报错 Refused to display &#39;URL&#39; in a frame because it set &#39;X-Frame-Options&#39; to &#39;DENY&#39;","text":"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options X-Frame-Options 有三个值: DENY表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。 SAMEORIGIN表示该页面可以在相同域名页面的 frame 中展示。 ALLOW-FROM uri表示该页面可以在指定来源的 frame 中展示。 换一句话说，如果设置为 DENY，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载。另一方面，如果设置为 SAMEORIGIN，那么页面就可以在同域名页面的 frame 中嵌套。 express 配置123const helmet = require('helmet');const app = express();app.use(helmet.frameguard({ action: 'SAMEORIGIN' })) 或者使用： 123const frameguard = require('frameguard')app.use(frameguard({ action: 'SAMEORIGIN' })) #question","link":"/2019/01/18/question/1a191f86ed/"},{"title":"枚举","text":"枚举使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript支持数字的和基于字符串的枚举。 数字枚举首先我们看看数字枚举，如果你使用过其它编程语言应该会很熟悉。 123456enum Direction { Up = 1, Down, Left, Right} 如上，我们定义了一个数字枚举，Up使用初始化为1。 其余的成员会从1开始自动增长。 换句话说，Direction.Up的值为1，Down为2，Left为3，Right为4。 我们还可以完全不使用初始化器： 123456enum Direction { Up, Down, Left, Right,} 现在，Up的值为0，Down的值为1等等。 当我们不在乎成员的值的时候，这种自增长的行为是很有用处的，但是要注意每个枚举成员的值都是不同的。 使用枚举很简单：通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型： 12345678910enum Response { No = 0, Yes = 1,}function respond(recipient: string, message: Response): void { // ...}respond(&quot;Princess Caroline&quot;, Response.Yes) 数字枚举可以被混入到计算过的和常量成员（如下所示）。 简短地说，没有初始化器的成员要么在首位，要么必须在用数值常量或其他常量枚举成员初始化的数值枚举之后。 换句话说，下面的情况是不被允许的： 1234enum E { A = getSomeValue(), B, // Error! Enum member must have initializer.} 字符串枚举字符串枚举的概念很简单，但是有细微的运行时的差别。 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。 123456enum Direction { Up = &quot;UP&quot;, Down = &quot;DOWN&quot;, Left = &quot;LEFT&quot;, Right = &quot;RIGHT&quot;,} 由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管反向映射会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。 异构枚举（Heterogeneous enums）从技术的角度来说，枚举可以混合字符串和数字成员，但是似乎你并不会这么做： 1234enum BooleanLikeHeterogeneousEnum { No = 0, Yes = &quot;YES&quot;,} 除非你真的想要利用JavaScript运行时的行为，否则我们不建议这样做。 计算的和常量成员每个枚举成员都带有一个值，它可以是_常量_或_计算出来的_。 当满足如下条件时，枚举成员被当作是常量： 它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值0： 12// E.X is constant:enum E { X } 它不带有初始化器且它之前的枚举成员是一个_数字_常量。 这种情况下，当前枚举成员的值为它上一个枚举成员的值加1。 1234567// All enum members in 'E1' and 'E2' are constant.enum E1 { X, Y, Z }enum E2 { A = 1, B, C} 枚举成员使用_常量枚举表达式_初始化。 常量枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式： 一个枚举表达式字面量（主要是字符串字面量或数字字面量） 一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的） 带括号的常量枚举表达式 一元运算符+, -, ~其中之一应用在了常量枚举表达式 常量枚举表达式做为二元运算符+, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^的操作对象。 若常量枚举表达式求值后为NaN或Infinity，则会在编译阶段报错。 所有其它情况的枚举成员被当作是需要计算得出的值。 123456789enum FileAccess { // constant members None, Read = 1 &lt;&lt; 1, Write = 1 &lt;&lt; 2, ReadWrite = Read | Write, // computed member G = &quot;123&quot;.length} 联合枚举与枚举成员的类型存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。 字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为 任何字符串字面量（例如：&quot;foo&quot;，&quot;bar&quot;，&quot;baz&quot;） 任何数字字面量（例如：1, 100） 应用了一元-符号的数字字面量（例如：-1, -100） 当所有枚举成员都拥有字面量枚举值时，它就带有了一种特殊的语义。 首先，枚举成员成为了类型！ 例如，我们可以说某些成员_只能_是枚举成员的值： 12345678910111213141516171819enum ShapeKind { Circle, Square,}interface Circle { kind: ShapeKind.Circle; radius: number;}interface Square { kind: ShapeKind.Square; sideLength: number;}let c: Circle = { kind: ShapeKind.Square, // Error! Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'. radius: 100,} 另一个变化是枚举类型本身变成了每个枚举成员的_联合_。 虽然我们还没有讨论联合类型，但你只要知道通过联合枚举，类型系统能够利用这样一个事实，它可以知道枚举里的值的集合。 因此，TypeScript能够捕获在比较值的时候犯的愚蠢的错误。 例如： 1234567891011enum E { Foo, Bar,}function f(x: E) { if (x !== E.Foo || x !== E.Bar) { // ~~~~~~~~~~~ // Error! This condition will always return 'true' since the types 'E.Foo' and 'E.Bar' have no overlap. }} 这个例子里，我们先检查x是否不是E.Foo。 如果通过了这个检查，然后||会发生短路效果，if语句体里的内容会被执行。 然而，这个检查没有通过，那么x则_只能_为E.Foo，因此没理由再去检查它是否为E.Bar。 运行时的枚举枚举是在运行时真正存在的对象。 例如下面的枚举： 123enum E { X, Y, Z} 可以传递给函数 123456function f(obj: { X: number }) { return obj.X;}// 没问题，因为 'E'包含一个数值型属性'X'。f(E); 编译时的枚举尽管一个枚举是在运行时真正存在的对象，但keyof关键字的行为与其作用在对象上时有所不同。应该使用keyof typeof来获取一个表示枚举里所有字符串key的类型。 12345678910111213141516171819enum LogLevel { ERROR, WARN, INFO, DEBUG}/** * 等同于： * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG'; */type LogLevelStrings = keyof typeof LogLevel;function printImportant(key: LogLevelStrings, message: string) { const num = LogLevel[key]; if (num &lt;= LogLevel.WARN) { console.log('Log level key is: ', key); console.log('Log level value is: ', num); console.log('Log level message is: ', message); }}printImportant('ERROR', 'This is a message'); 反向映射除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了_反向映射_，从枚举值到枚举名字。 例如，在下面的例子中： 12345enum Enum { A}let a = Enum.A;let nameOfA = Enum[a]; // &quot;A&quot; TypeScript可能会将这段代码编译为下面的JavaScript： 123456var Enum;(function (Enum) { Enum[Enum[&quot;A&quot;] = 0] = &quot;A&quot;;})(Enum || (Enum = {}));var a = Enum.A;var nameOfA = Enum[a]; // &quot;A&quot; 生成的代码中，枚举类型被编译成一个对象，它包含了正向映射（name -&gt; value）和反向映射（value -&gt; name）。 引用枚举成员总会生成为对属性访问并且永远也不会内联代码。 要注意的是_不会_为字符串枚举成员生成反向映射。 const枚举大多数情况下，枚举是十分有效的方案。 然而在某些情况下需求很严格。 为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用const枚举。 常量枚举通过在枚举上使用const修饰符来定义。 1234const enum Enum { A = 1, B = A * 2} 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。 12345678const enum Directions { Up, Down, Left, Right}let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right] 生成后的代码为： 1var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; 外部枚举外部枚举用来描述已经存在的枚举类型的形状。 12345declare enum Enum { A = 1, B, C = 2} 外部枚举和非外部枚举之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常量成员。 对于非常量的外部枚举而言，没有初始化方法时被当做需要经过计算的。 #typescript","link":"/2021/06/01/typescript/20d599057f/"},{"title":"泛型","text":"介绍软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。 在像C#和Java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。 泛型之Hello World下面来创建第一个使用泛型的例子：identity函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是echo命令。 不用泛型的话，这个函数可能是下面这样： 123function identity(arg: number): number { return arg;} 或者，我们使用any类型来定义函数： 123function identity(arg: any): any { return arg;} 使用any类型会导致这个函数可以接收任何类型的arg参数，这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。 如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。 因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。 这里，我们使用了_类型变量_，它是一种特殊的变量，只用于表示类型而不是值。 123function identity&lt;T&gt;(arg: T): T { return arg;} 我们给identity添加了类型变量T。 T帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。 之后我们再次使用了T当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。 我们把这个版本的identity函数叫做泛型，因为它可以适用于多个类型。 不同于使用any，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。 我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数： 1let output = identity&lt;string&gt;(&quot;myString&quot;); // type of output will be 'string' 这里我们明确的指定了T是string类型，并做为一个参数传给函数，使用了&lt;&gt;括起来而不是()。 第二种方法更普遍。利用了类型推论 – 即编译器会根据传入的参数自动地帮助我们确定T的类型： 1let output = identity(&quot;myString&quot;); // type of output will be 'string' 注意我们没必要使用尖括号（&lt;&gt;）来明确地传入类型；编译器可以查看myString的值，然后把T设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，在一些复杂的情况下，这是可能出现的。 使用泛型变量使用泛型创建像identity这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。 看下之前identity例子： 123function identity&lt;T&gt;(arg: T): T { return arg;} 如果我们想同时打印出arg的长度。 我们很可能会这样做： 1234function loggingIdentity&lt;T&gt;(arg: T): T { console.log(arg.length); // Error: T doesn't have .length return arg;} 如果这么做，编译器会报错说我们使用了arg的.length属性，但是没有地方指明arg具有这个属性。 记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有.length属性的。 现在假设我们想操作T类型的数组而不直接是T。由于我们操作的是数组，所以.length属性是应该存在的。 我们可以像创建其它数组一样创建这个数组： 1234function loggingIdentity&lt;T&gt;(arg: T[]): T[] { console.log(arg.length); // Array has a .length, so no more error return arg;} 你可以这样理解loggingIdentity的类型：泛型函数loggingIdentity，接收类型参数T和参数arg，它是个元素类型是T的数组，并返回元素类型是T的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时T的的类型为number。 这可以让我们把泛型变量T当做类型的一部分使用，而不是整个类型，增加了灵活性。 我们也可以这样实现上面的例子： 1234function loggingIdentity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; { console.log(arg.length); // Array has a .length, so no more error return arg;} 使用过其它语言的话，你可能对这种语法已经很熟悉了。 在下一节，会介绍如何创建自定义泛型像Array&lt;T&gt;一样。 泛型类型上一节，我们创建了identity通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。 泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样： 12345function identity&lt;T&gt;(arg: T): T { return arg;}let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity; 我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。 12345function identity&lt;T&gt;(arg: T): T { return arg;}let myIdentity: &lt;U&gt;(arg: U) =&gt; U = identity; 我们还可以使用带有调用签名的对象字面量来定义泛型函数： 12345function identity&lt;T&gt;(arg: T): T { return arg;}let myIdentity: {&lt;T&gt;(arg: T): T} = identity; 这引导我们去写第一个泛型接口了。 我们把上面例子里的对象字面量拿出来做为一个接口： 123456789interface GenericIdentityFn { &lt;T&gt;(arg: T): T;}function identity&lt;T&gt;(arg: T): T { return arg;}let myIdentity: GenericIdentityFn = identity; 一个相似的例子，我们可能想把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如：Dictionary&lt;string&gt;而不只是Dictionary）。 这样接口里的其它成员也能知道这个参数的类型了。 123456789interface GenericIdentityFn&lt;T&gt; { (arg: T): T;}function identity&lt;T&gt;(arg: T): T { return arg;}let myIdentity: GenericIdentityFn&lt;number&gt; = identity; 注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用GenericIdentityFn的时候，还得传入一个类型参数来指定泛型类型（这里是：number），锁定了之后代码里使用的类型。 对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。 除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。 泛型类泛型类看上去与泛型接口差不多。 泛型类使用（&lt;&gt;）括起泛型类型，跟在类名后面。 12345678class GenericNumber&lt;T&gt; { zeroValue: T; add: (x: T, y: T) =&gt; T;}let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) { return x + y; }; GenericNumber类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用number类型。 也可以使用字符串或其它更复杂的类型。 12345let stringNumeric = new GenericNumber&lt;string&gt;();stringNumeric.zeroValue = &quot;&quot;;stringNumeric.add = function(x, y) { return x + y; };console.log(stringNumeric.add(stringNumeric.zeroValue, &quot;test&quot;)); 与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。 我们在类那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。 泛型约束你应该会记得之前的一个例子，我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。 在loggingIdentity例子中，我们想访问arg的length属性，但是编译器并不能证明每种类型都有length属性，所以就报错了。 1234function loggingIdentity&lt;T&gt;(arg: T): T { console.log(arg.length); // Error: T doesn't have .length return arg;} 相比于操作any所有类型，我们想要限制函数去处理任意带有.length属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。 为此，我们需要列出对于T的约束要求。 为此，我们定义一个接口来描述约束条件。 创建一个包含.length属性的接口，使用这个接口和extends关键字来实现约束： 12345678interface Lengthwise { length: number;}function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T { console.log(arg.length); // Now we know it has a .length property, so no more error return arg;} 现在这个泛型函数被定义了约束，因此它不再是适用于任意类型： 1loggingIdentity(3); // Error, number doesn't have a .length property 我们需要传入符合约束类型的值，必须包含必须的属性： 1loggingIdentity({length: 10, value: 3}); 在泛型约束中使用类型参数你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象obj上，因此我们需要在这两个类型之间使用约束。 12345678function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) { return obj[key];}let x = { a: 1, b: 2, c: 3, d: 4 };getProperty(x, &quot;a&quot;); // okaygetProperty(x, &quot;m&quot;); // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'. 在泛型里使用类类型在TypeScript使用泛型创建工厂函数时，需要引用构造函数的类类型。比如， 123function create&lt;T&gt;(c: {new(): T; }): T { return new c();} 一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系。 1234567891011121314151617181920212223242526class BeeKeeper { hasMask: boolean;}class ZooKeeper { nametag: string;}class Animal { numLegs: number;}class Bee extends Animal { keeper: BeeKeeper;}class Lion extends Animal { keeper: ZooKeeper;}function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A { return new c();}createInstance(Lion).keeper.nametag; // typechecks!createInstance(Bee).keeper.hasMask; // typechecks! #typescript","link":"/2021/06/01/typescript/9caaa469bb/"},{"title":"TypeScript","text":"目录 手册 [[基础类型]] [[接口]] [[函数]] [[字面量类型]] [[类]] [[枚举]] [[泛型]] 手册（进阶） 高级类型 实用工具类型 Decorators 声明合并 Iterators 和 Generators JSX 混入 模块 模块解析 命名空间 命名空间和模块 Symbols 三斜线指令 类型兼容性 类型推论 变量声明 手册（v2） 模版字面量类型 如何书写声明文件 介绍 举例 库结构 模板 最佳实践 深入 发布 使用 JavaScript JavaScript文件里的类型检查 工程配置 tsconfig.json 工程引用 NPM包的类型 编译选项 配置 Watch 在MSBuild里使用编译选项 与其它构建工具整合 使用TypeScript的每日构建版本 Wiki TypeScript里的this 编码规范 常见编译错误 支持TypeScript的编辑器 结合ASP.NET v5使用TypeScript 架构概述 发展路线图 #typescript","link":"/2020/10/28/typescript/e22dc01851/"},{"title":"基础类型","text":"介绍为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。 Boolean最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。 1let isDone: boolean = false; Number和JavaScript一样，TypeScript里的所有数字都是浮点数或者大整数 。 这些浮点数的类型是number， 而大整数的类型则是 bigint。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。 12345let decLiteral: number = 6;let hexLiteral: number = 0xf00d;let binaryLiteral: number = 0b1010;let octalLiteral: number = 0o744;let bigLiteral: bigint = 100n; StringJavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用string表示文本数据类型。 和JavaScript一样，可以使用双引号（&quot;）或单引号（'）表示字符串。 12let name: string = &quot;bob&quot;;name = &quot;smith&quot;; 你还可以使用_模版字符串_，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（````` ），并且以${ expr }这种形式嵌入表达式 12345let name: string = `Gene`;let age: number = 37;let sentence: string = `Hello, my name is ${ name }.I'll be ${ age + 1 } years old next month.`; 这与下面定义sentence的方式效果相同： 12let sentence: string = &quot;Hello, my name is &quot; + name + &quot;.\\n\\n&quot; + &quot;I'll be &quot; + (age + 1) + &quot; years old next month.&quot;; ArrayTypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上[]，表示由此类型元素组成的一个数组： 1let list: number[] = [1, 2, 3]; 第二种方式是使用数组泛型，Array&lt;元素类型&gt;： 1let list: Array&lt;number&gt; = [1, 2, 3]; Tuple元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。比如，你可以定义一对值分别为string和number类型的元组。 123456// Declare a tuple typelet x: [string, number];// Initialize itx = ['hello', 10]; // OK// Initialize it incorrectlyx = [10, 'hello']; // Error 当访问一个已知索引的元素，会得到正确的类型： 12console.log(x[0].substr(1)); // OKconsole.log(x[1].substr(1)); // Error, 'number' does not have 'substr' 当访问一个越界的元素会报错。 123x[3] = &quot;world&quot;; // Error, Property '3' does not exist on type '[string, number]'.console.log(x[5].toString()); // Error, Property '5' does not exist on type '[string, number]'. Enumenum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。 12enum Color {Red, Green, Blue}let c: Color = Color.Green; 默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从1开始编号： 12enum Color {Red = 1, Green, Blue}let c: Color = Color.Green; 或者，全部都采用手动赋值： 12enum Color {Red = 1, Green = 2, Blue = 4}let c: Color = Color.Green; 枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字： 1234enum Color {Red = 1, Green, Blue}let colorName: string = Color[2];console.log(colorName); // 显示'Green'因为上面代码里它的值是2 Unknown当我们在写应用的时候可能会需要描述一个我们还不知道其类型的变量。这些值可以来自动态内容，例如从用户获得，或者我们想在我们的 API 中接收所有可能类型的值。在这些情况下，我们想要让编译器以及未来的用户知道这个变量可以是任意类型。这个时候我们会对它使用 unknown 类型。 12345let notSure: unknown = 4;notSure = &quot;maybe a string instead&quot;;// OK, definitely a booleannotSure = false; 如果你有一个 unknwon 类型的变量，你可以通过进行 typeof 、比较或者更高级的类型检查来将其的类型范围缩小，这些方法会在后续章节中进一步讨论： 123456789101112131415161718// @errors: 2322 2322 2322declare const maybe: unknown;// 'maybe' could be a string, object, boolean, undefined, or other typesconst aNumber: number = maybe;if (maybe === true) { // TypeScript knows that maybe is a boolean now const aBoolean: boolean = maybe; // So, it cannot be a string const aString: string = maybe;}if (typeof maybe === &quot;string&quot;) { // TypeScript knows that maybe is a string const aString: string = maybe; // So, it cannot be a boolean const aBoolean: boolean = maybe;} Any有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用any类型来标记这些变量： 123let notSure: any = 4;notSure = &quot;maybe a string instead&quot;;notSure = false; // okay, definitely a boolean 在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为Object有相似的作用，就像它在其它语言中那样。 但是Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法： 123456let notSure: any = 4;notSure.ifItExists(); // okay, ifItExists might exist at runtimenotSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)let prettySure: Object = 4;prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'. 注意：应避免使用Object，而是使用非原始object类型，正如Do’s and Don’ts里所讲的那样。当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据： 123let list: any[] = [1, true, &quot;free&quot;];list[1] = 100; Void某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是void： 123function warnUser(): void { console.log(&quot;This is my warning message&quot;);} 声明一个void类型的变量没有什么大用，因为你只能为它赋予null（只在--strictNullChecks未指定时）和undefined： 1let unusable: void = undefined; Null 和 UndefinedTypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和void相似，它们的本身的类型用处不是很大： 123// Not much else we can assign to these variables!let u: undefined = undefined;let n: null = null; 默认情况下null和undefined是所有类型的子类型。 就是说你可以把null和undefined赋值给number类型的变量。 然而，当你指定了--strictNullChecks标记，null和undefined只能赋值给any和它们各自的类型（有一个例外是undefined还可以赋值给void类型）。 这能避免_很多_常见的问题。 也许在某处你想传入一个string或null或undefined，你可以使用联合类型string | null | undefined。 联合类型是高级主题，我们会在以后的章节里讨论它。 注意：我们鼓励尽可能地使用--strictNullChecks，但在本手册里我们假设这个标记是关闭的。 Nevernever类型表示的是那些永不存在的值的类型。 例如，never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是never类型，当它们被永不为真的类型保护所约束时。 never类型是任何类型的子类型，也可以赋值给任何类型；然而，_没有_类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使any也不可以赋值给never。 下面是一些返回never类型的函数： 123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never { throw new Error(message);}// 推断的返回值类型为neverfunction fail() { return error(&quot;Something failed&quot;);}// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never { while (true) { }} Objectobject表示非原始类型，也就是除number，string，boolean，bigint，symbol，null或undefined之外的类型。 使用object类型，就可以更好的表示像Object.create这样的API。例如： 123456789declare function create(o: object | null): void;create({ prop: 0 }); // OKcreate(null); // OKcreate(42); // Errorcreate(&quot;string&quot;); // Errorcreate(false); // Errorcreate(undefined); // Error 类型断言有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。 通过_类型断言_这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。 类型断言有两种形式。 其一是“尖括号”语法： 123let someValue: any = &quot;this is a string&quot;;let strLength: number = (&lt;string&gt;someValue).length; 另一个为as语法： 123let someValue: any = &quot;this is a string&quot;;let strLength: number = (someValue as string).length; 两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有as语法断言是被允许的。 关于let你可能已经注意到了，我们使用let关键字来代替大家所熟悉的JavaScript关键字var。 let是ES2015引入的关键字，它比var更加安全，因此被看做是声明变量的标准方式。 我们会在以后详细介绍它，很多常见的问题都可以通过使用let来解决，所以尽可能地使用let来代替var吧。 关于 Number, String, Boolean, Symbol 和 Object我们很容易会认为 Number、 String、 Boolean、Symbol 以及 Object 这些类型和我们以上推荐的小写版本的类型是一样的。但这些类型不属于语言的基本类型，并且几乎在任何时候都不应该被用作一个类型： 123456// @errors: 2339function reverse(s: String): String { return s.split(&quot;&quot;).reverse().join(&quot;&quot;);}reverse(&quot;hello world&quot;); 相对地，我们应该使用 number、string、boolean、object 和 symbol 12345function reverse(s: string): string { return s.split(&quot;&quot;).reverse().join(&quot;&quot;);}reverse(&quot;hello world&quot;); #typescript","link":"/2021/06/01/typescript/f951c213ec/"},{"title":"字面量类型","text":"介绍一个字面量是一个集体类型中更为具体的一种子类型。意思是：&quot;Hello World&quot; 是一个 string，但是一个 string 不是类型系统中的 &quot;Hello World&quot;。 目前 TypeScript 中有三种可用的字面量类型集合，分别是：字符串、数字和布尔值。通过使用字面量类型，你可以规定一个字符串、数字或布尔值必须含有的确定值。 字面量收窄当你通过 var 或 let 来声明一个变量时，实际上你在告诉编译器这个变量中的内容有可能会被改变。与之相对地，用 const 来声明对象会让 TypeScript 知道这个对象永远不会被改变。 12345678// We're making a guarantee that this variable// helloWorld will never change, by using const.// So, TypeScript sets the type to be &quot;Hello World&quot; not stringconst helloWorld = &quot;Hello World&quot;;// On the other hand, a let can change, and so the compiler declares it a stringlet hiWorld = &quot;Hi World&quot;; 从无穷多种可能的例子（string 变量的值有无穷多种）到一个更小、确定数量的例子（在上述例子中，&quot;Hello Wrold&quot; 的可能值只有一种）的过程就叫收窄。 字符串字面量类型字面量类型可以通过联合联系、类型守卫、类型别名来结合实际字符串值。通过这些特性，我们可以获取一种字符串并使其有类似枚举（enum）的行为。 12345678910111213141516171819type Easing = &quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;;class UIElement { animate(dx: number, dy: number, easing: Easing) { if (easing === &quot;ease-in&quot;) { // ... } else if (easing === &quot;ease-out&quot;) { } else if (easing === &quot;ease-in-out&quot;) { } else { // It's possible that someone could reach this // by ignoring your types though. } }}let button = new UIElement();button.animate(0, 0, &quot;ease-in&quot;);button.animate(0, 0, &quot;uneasy&quot;);// Error: Argument of type '&quot;uneasy&quot;' is not assignable to parameter of type 'Easing'. 你可以传递三种允许的字符串，但是如果传递其他的字符串会收到如下错误： 1Argument of type '&quot;uneasy&quot;' is not assignable to parameter of type '&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;' 字符串字面可以通过相同的方式用来分别重载： 123456function createElement(tagName: &quot;img&quot;): HTMLImageElement;function createElement(tagName: &quot;input&quot;): HTMLInputElement;// ... more overloads ...function createElement(tagName: string): Element { // ... code goes here ...} 数字字面量类型TypeScript 还有数字字面量类型，它的行为和上述字符串字面量类型相同。 12345function rollDice(): 1 | 2 | 3 | 4 | 5 | 6 { return (Math.floor(Math.random() * 6) + 1) as 1 | 2 | 3 | 4 | 5 | 6;}const result = rollDice(); 数字字面量类型经常用来描述配置值： 1234567interface MapConfig { lng: number; lat: number; tileSize: 8 | 16 | 32;}setupMap({ lng: -73.935242, lat: 40.73061, tileSize: 16 }); 布尔字面量类型TypeScript 还有布尔值字面量类型，你可以通过他们来约束某些属性之间互有关联的对象。 12345678910111213interface ValidationSuccess { isValid: true; reason: null;};interface ValidationFailure { isValid: false; reason: string;};type ValidationResult = | ValidationSuccess | ValidationFailure; #typescript","link":"/2021/06/01/typescript/fb5f45ef91/"},{"title":"element-ui tabs的label slot不能及时动态更新","text":"https://github.com/ElemeFE/element/issues/2934 问题12345678910111213141516171819202122232425262728293031323334353637var Main = { template: `&lt;el-tabs type=&quot;border-card&quot;&gt; &lt;el-tab-pane :name=&quot;index&quot; v-for=&quot;(item, index) in tabs&quot;&gt; &lt;span slot=&quot;label&quot;&gt;{{ item.name }}&lt;/span&gt; &lt;div&gt; {{ item.name }} &lt;input type=&quot;text&quot; v-model=&quot;item.name&quot; name=&quot;name&quot;/&gt; &lt;/div&gt; &lt;/el-tab-pane&gt;&lt;/el-tabs&gt; `, data() { return { tabs: [ { name: 'tab1', content: 'Content Tab1', }, { name: 'tab2', content: 'Content Tab2', }, { name: 'tab3', content: 'Content Tab3', }, ], } },}new Vue({ el: '#app', render: (h) =&gt; h(Main)}) 解决方法1&lt;el-tabs&gt;, like &lt;el-tabs ref=&quot;tabs&quot;&gt; 1this.$refs.tabs.$refs.nav.$forceUpdate(); #vue# #javascript #question","link":"/2019/07/28/vue/fd861c285b/"},{"title":"你不知道的浏览器渲染原理","text":"在我们面试过程中，面试官经常会问到这么一个问题，那就是从在浏览器地址栏中输入URL到页面显示，浏览器到底发生了什么？这个问题看起来是老生常谈，但是这个问题回答的好坏，确实可以很好的反映出面试者知识的广度和深度。本文从浏览器角度来告诉你，URL后输入后按回车，浏览器内部究竟发生了什么，读完本文后，你将了解到： 浏览器内有哪些进程，这些进程都有些什么作用 浏览器地址输入URL后，内部的进程、线程都做了哪些事 我们与浏览器交互时，内部进程是怎么处理这些交互事件的 浏览器架构在讲浏览器架构之前，先理解两个概念， 进程 和 线程 。 进程（process）是程序的一次执行过程，是一个动态概念，是程序在执行过程中分配和管理资源的基本单位，线程（thread）是CPU调度和分派的基本单位，它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 简单的说呢，进程可以理解成正在执行的应用程序，而线程呢，可以理解成我们应用程序中的代码的执行器。而他们的关系可想而知，线程是跑在进程里面的，一个进程里面可能有一个或者多个线程，而一个线程，只能隶属于一个进程。 大家都知道，浏览器属于一个应用程序，而应用程序的一次执行，可以理解为计算机启动了一个 进程 ，进程启动后，CPU会给该进程分配相应的内存空间，当我们的进程得到了内存之后，就可以使用 线程 进行资源调度，进而完成我们应用程序的功能。 而在应用程序中，为了满足功能的需要，启动的进程会创建另外的新的进程来处理其他任务，这些创建出来的新的进程拥有全新的独立的内存空间，不能与原来的进程内向内存，如果这些进程之间需要通信，可以通过IPC机制f（Inter Process Communication）来进行。 很多应用程序都会采取这种多进程的方式来工作，因为进程和进程之间是互相独立的它们 互不影响 ，也就是说，当其中一个进程挂掉了之后，不会影响到其他进程的执行，只需要重启挂掉的进程就可以恢复运行。 浏览器的多进程架构假如我们去开发一个浏览器，它的架构可以是一个单进程多线程的应用程序，也可以是一个使用IPC通信的多进程应用程序。 不同的浏览器使用不同的架构，下面主要以Chrome为例，介绍浏览器的多进程架构。 在Chrome中，主要的进程有4个： 浏览器进程 (Browser Process)：负责浏览器的TAB的前进、后退、地址栏、书签栏的工作和处理浏览器的一些不可见的底层操作，比如网络请求和文件访问。 渲染进程 (Renderer Process)：负责一个Tab内的显示相关的工作，也称渲染引擎。 插件进程 (Plugin Process)：负责控制网页使用到的插件 GPU进程 (GPU Process)：负责处理整个应用程序的GPU任务 这4个进程之间的关系是什么呢？ 首先，当我们是要浏览一个网页，我们会在浏览器的地址栏里输入URL，这个时候 Browser Process 会向这个URL发送请求，获取这个URL的HTML内容，然后将HTML交给 Renderer Process ， Renderer Process 解析HTML内容，解析遇到需要请求网络的资源又返回来交给 Browser Process 进行加载，同时通知 Browser Process ，需要 Plugin Process 加载插件资源，执行插件代码。解析完成后， Renderer Process 计算得到图像帧，并将这些图像帧交给 GPU Process ， GPU Process 将其转化为图像显示屏幕。 多进程架构的好处Chrome为什么要使用多进程架构呢？ 第一，更高的容错性。当今WEB应用中，HTML，JavaScript和CSS日益复杂，这些跑在渲染引擎的代码，频繁的出现BUG，而有些BUG会直接导致渲染引擎崩溃，多进程架构使得每一个渲染引擎运行在各自的进程中，相互之间不受影响，也就是说，当其中一个页面崩溃挂掉之后，其他页面还可以正常的运行不收影响。 第二，更高的安全性和沙盒性（sanboxing）。渲染引擎会经常性的在网络上遇到不可信、甚至是恶意的代码，它们会利用这些漏洞在你的电脑上安装恶意的软件，针对这一问题，浏览器对不同进程限制了不同的权限，并为其提供沙盒运行环境，使其更安全更可靠 第三，更高的响应速度。在单进程的架构中，各个任务相互竞争抢夺CPU资源，使得浏览器响应速度变慢，而多进程架构正好规避了这一缺点。 多进程架构优化之前的我们说到， Renderer Process 的作用是负责一个Tab内的显示相关的工作，这就意味着，一个Tab，就会有一个Renderer Process，这些进程之间的内存无法进行共享，而不同进程的内存常常需要包含相同的内容。 浏览器的进程模式为了节省内存，Chrome提供了四种进程模式（Process Models），不同的进程模式会对 tab 进程做不同的处理。 Process-per-site-instance (default) - 同一个 site-instance 使用一个进程 Process-per-site - 同一个 site 使用一个进程 Process-per-tab - 每个 tab 使用一个进程 Single process - 所有 tab 共用一个进程 这里需要给出 site 和 site-instance 的定义 site 指的是相同的 registered domain name(如：google.com ，bbc.co.uk)和scheme (如：https://)。比如a.baidu.com和b.baidu.com就可以理解为同一个 site（注意这里要和 Same-origin policy 区分开来，同源策略还涉及到子域名和端口）。 site-instance 指的是一组 connected pages from the same site，这里 connected 的定义是 can obtain references to each other in script code 怎么理解这段话呢。满足下面两中情况并且打开的新页面和旧页面属于上面定义的同一个 site，就属于同一个 site-instance 用户通过 &lt;a target=&quot;_blank&quot;&gt; 这种方式点击打开的新页面 JS代码打开的新页面（比如 window.open ) 理解了概念之后，下面解释四个进程模式 首先是 Single process ，顾名思义，单进程模式，所有tab都会使用同一个进程。接下来是 Process-per-tab ，也是顾名思义，每打开一个tab，会新建一个进程。而对于 Process-per-site ，当你打开 a.baidu.com 页面，在打开 b.baidu.com 的页面，这两个页面的tab使用的是共一个进程，因为这两个页面的site相同，而如此一来，如果其中一个tab崩溃了，而另一个tab也会崩溃。 Process-per-site-instance 是最重要的，因为这个是 Chrome 默认使用的模式，也就是几乎所有的用户都在用的模式。当你打开一个 tab 访问 a.baidu.com ，然后再打开一个 tab 访问 b.baidu.com，这两个 tab 会使用两个进程。而如果你在 a.baidu.com 中，通过JS代码打开了 b.baidu.com 页面，这两个 tab 会使用同一个进程。 默认模式选择那么为什么浏览器使用 Process-per-site-instance 作为默认的进程模式呢？ Process-per-site-instance 兼容了性能与易用性，是一个比较中庸通用的模式。 相较于 Process-per-tab，能够少开很多进程，就意味着更少的内存占用 相较于 Process-per-site，能够更好的隔离相同域名下毫无关联的 tab，更加安全 导航过程都发生了什么前面我们讲了浏览器的多进程架构，讲了多进程架构的各种好处，和Chrome是怎么优化多进程架构的，下面从用户浏览网页这一简单的场景，来深入了解进程和线程是如何呈现我们的网站页面的。 网页加载过程之前我们我们提到，tab以外的大部分工作由浏览器进程 Browser Process 负责，针对工作的不同，Browser Process 划分出不同的工作线程： UI thread：控制浏览器上的按钮及输入框； network thread：处理网络请求，从网上获取数据； storage thread：控制文件等的访问； 第一步：处理输入当我们在浏览器的地址栏输入内容按下回车时， UI thread 会判断输入的内容是搜索关键词（search query）还是URL，如果是搜索关键词，跳转至默认搜索引擎对应都搜索URL，如果输入的内容是URL，则开始请求URL。 第二步：开始导航回车按下后， UI thread 将关键词搜索对应的URL或输入的URL交给网络线程 Network thread ，此时UI线程使Tab前的图标展示为加载中状态，然后网络进程进行一系列诸如DNS寻址，建立TLS连接等操作进行资源请求，如果收到服务器的301重定向响应，它就会告知UI线程进行重定向然后它会再次发起一个新的网络请求。 第三步：读取响应network thread 接收到服务器的响应后，开始解析HTTP响应报文，然后根据响应头中的 Content-Type 字段来确定响应主体的媒体类型（MIME Type），如果媒体类型是一个HTML文件，则将响应数据交给渲染进程（renderer process）来进行下一步的工作，如果是 zip 文件或者其它文件，会把相关数据传输给下载管理器。 与此同时，浏览器会进行 Safe Browsing 安全检查，如果域名或者请求内容匹配到已知的恶意站点，network thread 会展示一个警告页。除此之外，网络线程还会做 CORB（Cross Origin Read Blocking）检查来确定那些敏感的跨站数据不会被发送至渲染进程。 第四步：查找渲染进程各种检查完毕以后，network thread 确信浏览器可以导航到请求网页，network thread 会通知 UI thread 数据已经准备好，UI thread 会查找到一个 renderer process 进行网页的渲染。 浏览器为了对查找渲染进程这一步骤进行优化，考虑到网络请求获取响应需要时间，所以在第二步开始，浏览器已经预先查找和启动了一个渲染进程，如果中间步骤一切顺利，当 network thread 接收到数据时，渲染进程已经准备好了，但是如果遇到重定向，这个准备好的渲染进程也许就不可用了，这个时候会重新启动一个渲染进程。 第五步：提交导航到了这一步，数据和渲染进程都准备好了， Browser Process 会向 Renderer Process 发送IPC消息来确认导航，此时，浏览器进程将准备好的数据发送给渲染进程，渲染进程接收到数据之后，又发送IPC消息给浏览器进程，告诉浏览器进程导航已经提交了，页面开始加载。 这个时候导航栏会更新，安全指示符更新（地址前面的小锁），访问历史列表（history tab）更新，即可以通过前进后退来切换该页面。 第六步：初始化加载完成当导航提交完成后，渲染进程开始加载资源及渲染页面（详细内容下文介绍），当页面渲染完成后（页面及内部的iframe都触发了onload事件），会向浏览器进程发送IPC消息，告知浏览器进程，这个时候UI thread会停止展示tab中的加载中图标。 网页渲染原理导航过程完成之后，浏览器进程把数据交给了渲染进程，渲染进程负责tab内的所有事情，核心目的就是将HTML/CSS/JS代码，转化为用户可进行交互的web页面。那么渲染进程是如何工作的呢？ 渲染进程中，包含线程分别是： 一个主线程（main thread） 多个工作线程（work thread） 一个合成器线程（compositor thread） 多个光栅化线程（raster thread） 不同的线程，有着不同的工作职责。 构建DOM当渲染进程接受到导航的确认信息后，开始接受来自浏览器进程的数据，这个时候，主线程会解析数据转化为DOM（Document Object Model）对象。 DOM为WEB开发人员通过JavaScript与网页进行交互的数据结构及API。 资源子加载在构建DOM的过程中，会解析到图片、CSS、JavaScript脚本等资源，这些资源是需要从网络或者缓存中获取的，主线程在构建DOM过程中如果遇到了这些资源，逐一发起请求去获取，而为了提升效率，浏览器也会运行预加载扫描（preload scanner）程序，如果如果HTML中存在 img、link 等标签，预加载扫描程序会把这些请求传递给 Browser Process 的network thread进行资源下载。 JavaScript的下载与执行构建DOM过程中，如果遇到 &lt;script&gt; 标签，渲染引擎会停止对HTML的解析，而去加载执行JS代码，原因在于JS代码可能会改变DOM的结构（比如执行 document.write() 等API） 不过开发者其实也有多种方式来告知浏览器应对如何应对某个资源，比如说如果在 &lt;script&gt; 标签上添加了 async 或 defer 等属性，浏览器会异步的加载和执行JS代码，而不会阻塞渲染。 样式计算 - Style calculationDOM树只是我们页面的结构，我们要知道页面长什么样子，我们还需要知道DOM的每一个节点的样式。主线程在解析页面时，遇到 &lt;style&gt; 标签或者 &lt;link&gt; 标签的CSS资源，会加载CSS代码，根据CSS代码确定每个DOM节点的计算样式（computed style）。 计算样式是主线程根据CSS样式选择器（CSS selectors）计算出的每个DOM元素应该具备的具体样式，即使你的页面没有设置任何自定义的样式，浏览器也会提供其默认的样式。 布局 - LayoutDOM树和计算样式完成后，我们还需要知道每一个节点在页面上的位置，布局（Layout）其实就是找到所有元素的几何关系的过程。 主线程会遍历DOM 及相关元素的计算样式，构建出包含每个元素的页面坐标信息及盒子模型大小的布局树（Render Tree），遍历过程中，会跳过隐藏的元素（display: none），另外，伪元素虽然在DOM上不可见，但是在布局树上是可见的。 绘制 - Paint布局 layout 之后，我们知道了不同元素的结构，样式，几何关系，我们要绘制出一个页面，我们要需要知道每个元素的绘制先后顺序，在绘制阶段，主线程会遍历布局树（layout tree），生成一系列的绘画记录（paint records）。绘画记录可以看做是记录各元素绘制先后顺序的笔记。 合成 - Compositing文档结构、元素的样式、元素的几何关系、绘画顺序，这些信息我们都有了，这个时候如果要绘制一个页面，我们需要做的是把这些信息转化为显示器中的像素，这个转化的过程，叫做 光栅化 （rasterizing）。 那我们要绘制一个页面，最简单的做法是只光栅化视口内（viewport）的网页内容，如果用户进行了页面滚动，就移动光栅帧（rastered frame）并且光栅化更多的内容以补上页面缺失的部分，如下： Chrome第一个版本就是采用这种简单的绘制方式，这一方式唯一的缺点就是每当页面滚动，光栅线程都需要对新移进视图的内容进行光栅化，这是一定的性能损耗，为了优化这种情况，Chrome采取一种更加复杂的叫做合成（compositing）的做法。 那么，什么是合成？合成是一种将页面分成若干层，然后分别对它们进行光栅化，最后在一个单独的线程 - 合成线程（compositor thread）里面合并成一个页面的技术。当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧来展示滚动后的效果罢了。页面的动画效果实现也是类似，将页面上的层进行移动并构建出一个新的帧即可。 为了实现合成技术，我们需要对元素进行分层，确定哪些元素需要放置在哪一层，主线程需要遍历渲染树来创建一棵层次树（Layer Tree），对于添加了 will-change CSS 属性的元素，会被看做单独的一层，没有 will-change CSS属性的元素，浏览器会根据情况决定是否要把该元素放在单独的层。 你可能会想要给页面上所有的元素一个单独的层，然而当页面的层超过一定的数量后，层的合成操作要比在每个帧中光栅化页面的一小部分还要慢，因此衡量你应用的渲染性能是十分重要的一件事情。 一旦Layer Tress被创建，渲染顺序被确定，主线程会把这些信息通知给合成器线程，合成器线程开始对层次数的每一层进行光栅化。有的层的可以达到整个页面的大小，所以合成线程需要将它们切分为一块又一块的小图块（tiles），之后将这些小图块分别进行发送给一系列光栅线程（raster threads）进行光栅化，结束后光栅线程会将每个图块的光栅结果存在 GPU Process 的内存中。 为了优化显示体验，合成线程可以给不同的光栅线程赋予不同的优先级，将那些在视口中的或者视口附近的层先被光栅化。 当图层上面的图块都被栅格化后，合成线程会收集图块上面叫做绘画四边形（draw quads）的信息来构建一个合成帧（compositor frame）。 绘画四边形：包含图块在内存的位置以及图层合成后图块在页面的位置之类的信息。 合成帧：代表页面一个帧的内容的绘制四边形集合。 以上所有步骤完成后，合成线程就会通过IPC向浏览器进程（browser process）提交（commit）一个渲染帧。这个时候可能有另外一个合成帧被浏览器进程的UI线程（UI thread）提交以改变浏览器的UI。这些合成帧都会被发送给GPU从而展示在屏幕上。如果合成线程收到页面滚动的事件，合成线程会构建另外一个合成帧发送给GPU来更新页面。 合成的好处在于这个过程没有涉及到主线程，所以合成线程不需要等待样式的计算以及JavaScript完成执行。这就是为什么合成器相关的动画最流畅，如果某个动画涉及到布局或者绘制的调整，就会涉及到主线程的重新计算，自然会慢很多。 浏览器对事件的处理当页面渲染完毕以后，TAB内已经显示出了可交互的WEB页面，用户可以进行移动鼠标、点击页面等操作了，而当这些事件发生时候，浏览器是如何处理这些事件的呢？ 以点击事件（click event）为例，让鼠标点击页面时候，首先接受到事件信息的是 Browser Process ，但是Browser Process只知道事件发生的类型和发生的位置，具体怎么对这个点击事件进行处理，还是由Tab内的 Renderer Process 进行的。Browser Process接受到事件后，随后便把事件的信息传递给了渲染进程，渲染进程会找到根据事件发生的坐标，找到目标对象（target），并且运行这个目标对象的点击事件绑定的监听函数（listener）。 渲染进程中合成器线程接收事件前面我们说到，合成器线程可以独立于主线程之外通过已光栅化的层创建组合帧，例如页面滚动，如果没有对页面滚动绑定相关的事件，组合器线程可以独立于主线程创建组合帧，如果页面绑定了页面滚动事件，合成器线程会等待主线程进行事件处理后才会创建组合帧。那么，合成器线程是如何判断出这个事件是否需要路由给主线程处理的呢？ 由于执行 JS 是主线程的工作，当页面合成时，合成器线程会标记页面中绑定有事件处理器的区域为 非快速滚动区域 (non-fast scrollable region)，如果事件发生在这些存在标注的区域，合成器线程会把事件信息发送给主线程，等待主线程进行事件处理，如果事件不是发生在这些区域，合成器线程则会直接合成新的帧而不用等到主线程的响应。 而对于非快速滚动区域的标记，开发者需要注意全局事件的绑定，比如我们使用事件委托，将目标元素的事件交给根元素body进行处理，代码如下： 1document.body.addEventListener('touchstart', event =&gt; { if (event.target === area) { event.preventDefault() }}) 在开发者角度看，这一段代码没什么问题，但是从浏览器角度看，这一段代码给body元素绑定了事件监听器，也就意味着整个页面都被编辑为一个非快速滚动区域，这会使得即使你的页面的某些区域没有绑定任何事件，每次用户触发事件时，合成器线程也需要和主线程通信并等待反馈，流畅的合成器独立处理合成帧的模式就失效了。 其实这种情况也很好处理，只需要在事件监听时传递 passtive 参数为 true， passtive 会告诉浏览器你既要绑定事件，又要让组合器线程直接跳过主线程的事件处理直接合成创建组合帧。 1document.body.addEventListener('touchstart', event =&gt; { if (event.target === area) { event.preventDefault() } }, {passive: true}); 查找事件的目标对象（event target）当合成器线程接收到事件信息，判定到事件发生不在非快速滚动区域后，合成器线程会向主线程发送这个时间信息，主线程获取到事件信息的第一件事就是通过命中测试（hit test）去找到事件的目标对象。具体的命中测试流程是遍历在绘制阶段生成的绘画记录（paint records）来找到包含了事件发生坐标上的元素对象。 浏览器对事件的优化一般我们屏幕的帧率是每秒60帧，也就是60fps，但是某些事件触发的频率超过了这个数值，比如wheel，mousewheel，mousemove，pointermove，touchmove，这些连续性的事件一般每秒会触发60~120次，假如每一次触发事件都将事件发送到主线程处理，由于屏幕的刷新速率相对来说较低，这样使得主线程会触发过量的命中测试以及JS代码，使得性能有了没必要是损耗。 出于优化的目的，浏览器会合并这些连续的事件，延迟到下一帧渲染是执行，也就是 requestAnimationFrame 之前。 而对于非连续性的事件，如keydown，keyup，mousedown，mouseup，touchstart，touchend等，会直接派发给主线程去执行。 总结浏览器的多进程架构，根据不同的功能划分了不同的进程，进程内不同的使命划分了不同的线程，当用户开始浏览网页时候，浏览器进程进行处理输入、开始导航请求数据、请求响应数据，查找新建渲染进程，提交导航，之后渲染又进行了解析HTML构建DOM、构建过程加载子资源、下载并执行JS代码、样式计算、布局、绘制、合成，一步一步的构建出一个可交互的WEB页面，之后浏览器进程又接受页面的交互事件信息，并将其交给渲染进程，渲染进程内主进程进行命中测试，查找目标元素并执行绑定的事件，完成页面的交互。 #javascript","link":"/2018/06/15/javascript/63b7e86461/"},{"title":"实时协同编辑的实现","text":"在最近某个项目中打算使用协同编辑来解决冲突问题，因此抽空调研了现有的实现方案，结果发现要想做完美是很难的，但我们可以低成本地做到不错的效果，本文将介绍几种实现方法，大家在项目中如果有需要可以参考。 什么是实时协同编辑这里所说的实时协同编辑，是指多人同时编辑一个文档，最典型的例子是 Google Docs，你可以实时看到别人做出的修改，不用手动刷新页面。 要实现实时编辑，我们需要解决两个技术点：实时通信问题、编辑冲突问题，其中实时通信问题比较好解决，可以使用 long pull 或 WebSocket，所以这里就不过多讨论了，重点将放在如何解决编辑冲突问题上。 可选方案接下来将从易至难的顺序来介绍几种可行的方案，分别是：「编辑锁」、「GNU diff-patch」、「Myer’s diff-patch」、「Operational Transformation」和「分布式 Operational Transformation」。 编辑锁编辑锁这是实现协同编辑最简单的方法，简单来说就是当有人在编辑某个文档时，系统会将这个文档锁定，避免其他人同时编辑，因为实现简单，所以这个方案是应用最广的，比如公司内部常用的 TWiki 系统，采用这种方式虽然可以在一定程度上避免覆盖问题，但它的使用体验不好，也做不到「实时」，所以这里就不讨论了。 GNU diff-patchGit 等版本管理软件其实也是一种协同编辑工具，因为每个人都可以并行编辑，遇到编辑同一个文件时可以自动合并，因此我们也能使用类似的原理来实现协同编辑，具体可以有两种方法：diff-patch 和 merge。 先说 diff-patch，这里的 diff 和 patch 是指两个 unix 下的命令，diff 能输出两个文本的不同之处，然后用 patch 来更新其它文件，我们只要在 JS 中实现这两个算法，就能通过如下流程来实现协同编辑： 每个用户进来时都建立长连接，保存好当前文档副本 有人编辑时，如果停顿 5 秒（具体要根据产品策略），就将现有文档和之前的副本进行 diff，将结果传给服务端，更新副本 服务端更新文档，然后通过长连接将这个 diff 结果发给同时在编辑的其它用户，这些用户使用 patch 方法来更新 ta 们文档 但 GNU diff 有个问题，因为基于行匹配的，所以很容易冲突，让我们测试一下「百度 Web」和「百度 Web 前端」这两段文本的 diff 结果 123456[nwind@fex ~]$ diff old.txt other-new.txt &gt; old-to-other-new.patch[nwind@fex ~]$ cat old-to-other-new.patch1c1&lt; 百度 Web---&gt; 百度 Web 前端 在这个 diff 结果中， 1c1 的第一个「1」代表修改前的第一行，后面的「c」代表「修改」，第二个「1」代表修改后的行，也就是说将第一行的「百度 Web」改成「百度 Web 前端」，修改后的内容放第一行。也就意味着如果两人同时修改一行就会冲突，可以通过下面的测试来确认： 123456789[nwind@fex ~]$ cat my-new.txtWeb [nwind@fex ~]$ patch my-new.txt &lt; old-to-other-new.patchpatching file b-new.txtHunk #1 FAILED at 1.1 out of 1 hunk FAILED -- saving rejects to file my-new.txt.rej [nwind@fex ~]$ cat my-new.txt.rej****************** 1- 百度 Web--- 1 -----+ 百度 Web 前端 其中 my-new.txt 是我修改的版本，我去掉了前面的「百度 」，只留下「Web」，其实这两处修改是不冲突的，它们可以合并成「Web 前端」，如下图所示 但使用 patch 命令部下，它在冲突后会生成一个新文件 my-new.txt.rej 来描述失败原因，这种展现方式不直观，需要打开两个文件比对，我们使用另一种方式来更好地展现，那就是接下来介绍的 merge 命令，它的使用方法如下： 12345[nwind@fex ~]$ merge my-new.txt old.txt other-new.txtmerge: warning: conflicts during merge [nwind@fex ~]$ cat my-new.txt&lt;&lt;&lt;&lt;&lt;&lt;&lt; my-new.txtWeb=======百度 Web 前端&gt;&gt;&gt;&gt;&gt;&gt;&gt; other-new.txt 可以看到它直接将冲突的地方写到 my-new.txt 里了，这点比 patch 看起来要方便些，对于这个结果估计大部分同学都会眼熟，因为 merge 命令和 Git 等工具 中的合并算法是一样的 。 通过使用我们可以发现 merge 命令有个缺点，那就是需要使用 3 份完整的文本来进行比较，为了避免每次传递所有文本内容，我们可以结合使用 diff 来减小传输体积，在后端 patch 成新的文本。 无论是 diff 还是 merge，由于它们的算法都是基于行进行比较，导致对同一行的编辑必然冲突，为了解决这个问题，我们可以尝试基于字符粒度的 diff 算法，那就是接下来将介绍的 Myer’s diff-patch。 Myer’s diff-patchMyer 算法 是另一种 diff-patch 算法，它有很多 语言的开源实现 ，这里我们就不介绍细节算法了，直接用之前的例子来测试它的效果，首先看一下它的 diff 结果，调用代码如下： 1234var old_text = &quot;百度 Web&quot;;var new_text = &quot;百度 Web 前端&quot;; var dmp = new diff_match_patch();var patch_list = dmp.patch_make(old_text, new_text);patch_text = dmp.patch_toText(patch_list); console.log(decodeURI(patch_text)) 输出结果为 123@@ -1,6 +1,9 @@ 百度 Web+ 前端 其中第一行的 - 和 + 两个符号没有什么意义，这句话表示修改处之前的起始位置为 1（由于数组是从 0 开始的，所以内部计算时会先减一），长度为 6，后面的 1,9 ，表示修改后的起始位置为 1，长度为 9。在接下来的两段文本代表修改的地方，注意「百度 Web」前面有空格，这代表相等，也就是直接添加这个字符串，而后面的 + 代表添加文本，具体细节可以通过它的 实现源码 了解。 因此确定它的 diff 策略是基于字符匹配的，这样能否解决我们之前遇到的冲突问题呢？接下来来测试一下，源码如下： 123//相关代码同上var patches = dmp.patch_fromText(patch_text);var results = dmp.patch_apply(patches, &quot;Web&quot;); console.log(results[0]); //Web 前端 这个输出结果是正确的，也就是说它能很好地解决之前的问题，但如果是同一个位置的修改会怎样？我继续做了几个实验： 1234567891011121314var old_text = &quot;百度 Web&quot;;var other_new_text = &quot;百度 Web 后端&quot;;var my_new_text = &quot;百度 Web 前端&quot;;...//结果为「百度 Web 前端 后端」 ===var old_text = &quot;百度 Web 前端&quot;;var other_new_text = &quot;百度 Web 后端&quot;;var my_new_text = &quot;百度 Web 全端&quot;;...//结果为「百度 Web 后端」 ===var old_text = &quot;百度 Web&quot;;var other_new_text = &quot;Web 前端&quot;;var my_new_text = &quot;百度 FE&quot;;//结果为「FE 前」 第一个例子是在后面添加不同的字符，它的结果是两个添加都生效，第二个例子是在同一处修改成不同的字符，它的结果是别人的修改生效，但最后一个例子出错了，丢失了「端」字，这里看起来还好，但如果内容是富文本就有问题了，比如 &lt;b&gt; 少了 &gt; 是不行的。 整体来看 Myer 算法可以低成本地解决大部分问题，所以有些在线编辑器选择它来实现协同编辑功能，比如 codebox ，它的客户端代码 在这 ，服务端代码 在这 。 不过 Myer 在某些情况下会丢字符，是否还有更好的方法？答案是有，那就是接下来介绍的 Operational Transformation 技术。 Operational TransformationOperational Transformation（下面简称 OT）技术正是 Google Docs 中所采用的方案，因此是经过验证的，值得研究。 最开始我一直觉得 OT 会很复杂，因为它的相关介绍文章都写得很长，比如 这篇 及维基百科上的 介绍 ，不过看了之后才后发现它的原理并不复杂，我将在这里进行简单的说明。 首先，我们可以将文本内容修改转成以下 3 种类型的操作(Operational)： retain(n)：保持 n 个字符，也就是说这 n 个字符不变 insert(str)：插入字符 str delete(str)：删除字符 str 举个例子，假设 A 用户将「百度 Web」变成「Web 前端」，相当于产生了如下 3 个操作： 123delete('百度 '), //删掉「百度 」retain(3), //跳过 3 个字符（也就是「Web」）insert(' 前端') //插入「 前端」 提取这些操作可以通过 Levenshtein distance（编辑距离）算法来实现。那它如何解决冲突问题了？比如这时如果 B 用户将「百度 Web」改成了「百度 FE」，B 所生产的操作步骤将会是如下： 123retain(3), //跳过 3 个字符（也就是「百度 」）delete('Web'),insert('FE') 如果我们先应用 A 的操作，将字符串变为「Web 前端」，然后再应用 B 的操作时就会失效，因为在执行 B 的第二个操作 delete('Web') 时并没有「Web」，这时从第四个字符开始已经变成了「 前端」。 因此我们需要转换 B 的操作来适应新的字符串，比如调成如下操作： 123delete('Web'),insert('FE'),retain(3) 这个转换算法就是 OT 的核心，实际上 OT 指的是一类技术，而不是具体的算法，这个思路就是首先将编辑转成操作(Operational)，如果多人操作同时进行，需要对这些操作进行转换(Transformation)，这就是为什么叫 Operational Transformation，而具体应该拆分成哪些操作以及转换算法都是可以自定义的，因此 OT 可以灵活地支持各种协同编辑应用，比如非文本类的编辑。 回到之前 Myer 算法导致丢字符的那个例子，我们看看 OT 是否能解决，这里我使用了一个开源库 changesets ，以下是基于它实现合并的例子： 123var Changeset = require('changesets').Changeset; var text = &quot;百度 Web&quot; , textA = &quot;Web 前端&quot; , textB = &quot;百度 FE&quot;; var csA = Changeset.fromDiff(text, textA);var csB = Changeset.fromDiff(text, textB); var csB_new = csB.transformAgainst(csA); //这里这就是操作转换 var textA_new = csA.apply(text);console.log(csB_new.apply(textA_new)); //结果是「 前端FE」 结果并不正确，正确的应该是「FE 前端」，查看一下 csB_new 的内容，发现它实际上是转换成了如下操作： 123delete(3), //注意 changesets 在这里的参数不是字符串而是数字，它会直接删掉 3 个字符，不够内容是什么retain(3),insert('FE') 需要注意这并不是 OT 技术本身的问题，而是 changesets 所实现的转换算法问题，虽然不够完美，但和之前的 Myer 算法相比，至少没丢字符，后来我又做了几个测试，发现 OT 技术的准确率比 Myer 高，因此它是最适合用于协同编辑的技术。 分布式 Operational Transformation如果看完上面的文章你觉得实现实时协同编辑似乎不难，那你就错了，因为我们之前都没有考虑分布式的问题，OT 技术在学术界都研究 20 多年了，至今也没人总结出一个最好的方法，前 Google Wave 工程师在 ShareJS 首页上这样写道： Unfortunately, implementing OT sucks. There’s a million algorithms with different tradeoffs, mostly trapped in academic papers. The algorithms are really hard and time consuming to implement correctly. I am an ex Google Wave engineer. Wave took 2 years to write and if we rewrote it today, it would take almost as long to write a second time. 所以其实要做好是很难的，这里面最麻烦的就是分布式导致的问题，接下来将介绍 3 个我能想到的问题及解决方法。 1. 顺序问题 首先第一个问题是顺序问题，因为 OT 等算法都是依赖顺序的，不同顺序会导致结果不同，我们通过下面这张图来说明： 假设 Client A 在做两次修改时发了两个异步请求，可能因为网络延迟导致第二个请求反而先到了，导致最终服务器版本和 Client A 所看到的不一致，同样在服务器发往其它客户端的请求时也会出现乱序的问题，如图中 Client B 也有问题。 这个问题的解决方法很简单，我们可以在客户端和服务器端都加上队列来保证请求顺序，等前一个请求结束后再发下一个请求。 2. 存储的原子操作 如果有多台服务器，或者有多个线程/进程在同时处理请求时就会遇到覆盖问题，因为读写数据库并不是原子操作，比如下面的例子： Web Server A 和 Web Server B 同时访问数据库，结果导致 Web Server A 的修改被覆盖了。 好在这种问题还算比较常见，解决办法可以有 3 种： 保证操作只在一个线程中执行，比如某个文档的更新只在某个固定的机器，使用 Node 这样的单线程模型提供服务，这样就不可能并行修改了 如果数据库支持事务(transaction)，可以通过事务来解决 如果数据库不支持事务，就只能用分布式锁了，如 ZooKeeper 从实现角度来看，第一和第二种方法都比较简单，而第三种方法会带来很多问题，比如可能导致文档被锁死，假如上锁后由于种种原因没有执行解锁操作，这个文档就会永远被锁住，所以还得加上超时限制等策略。 然而在解决了原子操作后，我们将发现一个新的问题，那就是版本管理问题。 3. 版本管理问题 在前面的例子中，两段新文本的修改都是基于同一个旧版本的，如果旧版本不一样，就有可能出错，具体可以通过下面这张图来解释： 在这个例子中，Web Server A 接收到操作命令是将「a」文本改成「aa」，Web Server B 接收到操作命令是将「a」文本改成「ab」，这里我们加上了锁机制来避免同时读写数据，Web Server A 首先得到了锁，然后修改并更新数据，而 Web Server B 需要先等待数据解锁，等 Web Server B 拿到数据后它已经从「a」变成了「aa」，如果还按照 retain(1), insert('b') 进行修改，数据将变成「ab」，而不是正确的「aab」，引起这个问题的原因就是旧版本不一致，Web Server B 需要根据 Web Server A 的操作进行操作转换，变成 retain(2), insert('b') ，然后才能对数据进行修改。 因此想要解决这个问题，就必须引入版本，每次修改后都需要存储下新版本，有了版本我们就能使用 diff 功能来计算不同版本的差异，得到其它人修改的内容，然后通过 OT 合并算法合并两个操作，如下所示： 在 Web Server A 操作前数据版本是 v=1 ，操作后变成了 v=2 ，等到 Web Server B 处理的时候，它通过版本比较发现不一致，所以就首先通过编辑距离算法算出 Web Server A 所做的操作，然后用这个操作来对自己的操作进行转换，得到正确的新操作，从而避免了覆盖问题。 如果保存所有版本会导致数据量大大增加，所以还需要再优化，比如每个服务器保存一个数据副本，但这里就不再展开了，可以看要支持分布式 还是挺麻烦的，不过目前出现了一些前后端整合的方案，如 ShareJS 和 OpenCoweb Framework ，可以参考。 另外之前提到的 Myer’s diff 算法也有分布式解决方案，具体细节可以参考 这篇文档 。 初步结论 如果你只是一个内部小项目，实时性要求不高，但对准确性要求比较高 推荐用 merge 或 diff3 工具，出现同一行冲突时由用户来解决，这样能避免自动合并有可能出错的问题 如果想具备一定的实时性，流量不大，不想实现太复杂，且对少量的冲突可以忍受 推荐用 Myer’s diff，后端只开一个 Node 进程 如果想具备实时性，且有多台后端服务同时处理 可以用 Operational Transformation 或 Myer’s diff，但需要注意分布式带来的问题 如果需要很精细的控制，如支持富文本编辑等非单纯文本格式 只能使用 Operational Transformation，但要自己实现操作合并算法，比如 XML 可以参考 这篇文章 后续除了文本合并，真正要做在线编辑还有很多细节处理，感兴趣的同学可以继续研究： 支持选区，看到其他人选择的文本段，当然，这也有合并问题 指针要更随文本变化移动到正确的位置 支持 undo 实时协同编辑的实现 #javascript","link":"/2017/04/28/javascript/982b3a8836/"},{"title":"函数","text":"介绍函数是JavaScript应用程序的基础。 它帮助你实现抽象层，模拟类，信息隐藏和模块。 在TypeScript里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义_行为_的地方。 TypeScript为JavaScript函数添加了额外的功能，让我们可以更容易地使用。 函数和JavaScript一样，TypeScript函数可以创建有名字的函数和匿名函数。 你可以随意选择适合应用程序的方式，不论是定义一系列API函数还是只使用一次的函数。 通过下面的例子可以迅速回想起这两种JavaScript中的函数： 1234567// Named functionfunction add(x, y) { return x + y;}// Anonymous functionlet myAdd = function(x, y) { return x + y; }; 在JavaScript里，函数可以使用函数体外部的变量。 当函数这么做时，我们说它‘捕获’了这些变量。 至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习JavaScript和TypeScript会很有帮助。 12345let z = 100;function addToZ(x, y) { return x + y + z;} 函数类型为函数定义类型让我们为上面那个函数添加类型： 12345function add(x: number, y: number): number { return x + y;}let myAdd = function(x: number, y: number): number { return x + y; }; 我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。 书写完整函数类型现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。 12let myAdd: (x:number, y:number) =&gt; number = function(x: number, y: number): number { return x + y; }; 函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。 这个名字只是为了增加可读性。 我们也可以这么写： 12let myAdd: (baseValue: number, increment: number) =&gt; number = function(x: number, y: number): number { return x + y; }; 只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。 第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用(=&gt;)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为void而不能留空。 函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成API的一部分。 推断类型尝试这个例子的时候，你会注意到，就算仅在等式的一侧带有类型，TypeScript编译器仍可正确识别类型： 123456// myAdd has the full function typelet myAdd = function(x: number, y: number): number { return x + y; };// The parameters `x` and `y` have the type numberlet myAdd: (baseValue: number, increment: number) =&gt; number = function(x, y) { return x + y; }; 这叫做“按上下文归类”，是类型推论的一种。 它帮助我们更好地为程序指定类型。 可选参数和默认参数TypeScript里的每个函数参数都是必须的。 这不是指不能传递null或undefined作为参数，而是说编译器检查用户是否为每个参数都传入了值。 编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。 1234567function buildName(firstName: string, lastName: string) { return firstName + &quot; &quot; + lastName;}let result1 = buildName(&quot;Bob&quot;); // error, too few parameterslet result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;); // error, too many parameterslet result3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;); // ah, just right JavaScript里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是undefined。 在TypeScript里我们可以在参数名旁使用?实现可选参数的功能。 比如，我们想让last name是可选的： 12345678910function buildName(firstName: string, lastName?: string) { if (lastName) return firstName + &quot; &quot; + lastName; else return firstName;}let result1 = buildName(&quot;Bob&quot;); // works correctly nowlet result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;); // error, too many parameterslet result3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;); // ah, just right 可选参数必须跟在必须参数后面。 如果上例我们想让first name是可选的，那么就必须调整它们的位置，把first name放在后面。 在TypeScript里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是undefined时。 它们叫做有默认初始化值的参数。 让我们修改上例，把last name的默认值设置为&quot;Smith&quot;。 12345678function buildName(firstName: string, lastName = &quot;Smith&quot;) { return firstName + &quot; &quot; + lastName;}let result1 = buildName(&quot;Bob&quot;); // works correctly now, returns &quot;Bob Smith&quot;let result2 = buildName(&quot;Bob&quot;, undefined); // still works, also returns &quot;Bob Smith&quot;let result3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;); // error, too many parameterslet result4 = buildName(&quot;Bob&quot;, &quot;Adams&quot;); // ah, just right 在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用函数的时候可以省略。 也就是说可选参数与末尾的默认参数共享参数类型。 123function buildName(firstName: string, lastName?: string) { // ...} 和 123function buildName(firstName: string, lastName = &quot;Smith&quot;) { // ...} 共享同样的类型(firstName: string, lastName?: string) =&gt; string。 在函数类型中，默认参数的默认值不会显示，而只会显示它是一个可选参数。 与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入undefined值来获得默认值。 例如，我们重写最后一个例子，让firstName是带默认值的参数： 12345678function buildName(firstName = &quot;Will&quot;, lastName: string) { return firstName + &quot; &quot; + lastName;}let result1 = buildName(&quot;Bob&quot;); // error, too few parameterslet result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;); // error, too many parameterslet result3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;); // okay and returns &quot;Bob Adams&quot;let result4 = buildName(undefined, &quot;Adams&quot;); // okay and returns &quot;Will Adams&quot; 剩余参数必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在JavaScript里，你可以使用arguments来访问所有传入的参数。 在TypeScript里，你可以把所有参数收集到一个变量里： 12345function buildName(firstName: string, ...restOfName: string[]) { return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);}let employeeName = buildName(&quot;Joseph&quot;, &quot;Samuel&quot;, &quot;Lucas&quot;, &quot;MacKinzie&quot;); 剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（...）后面给定的名字，你可以在函数体内使用这个数组。 这个省略号也会在带有剩余参数的函数类型定义上使用到： 12345function buildName(firstName: string, ...restOfName: string[]) { return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);}let buildNameFun: (fname: string, ...rest: string[]) =&gt; string = buildName; this学习如何在JavaScript里正确使用this就好比一场成年礼。 由于TypeScript是JavaScript的超集，TypeScript程序员也需要弄清this工作机制并且当有bug的时候能够找出错误所在。 幸运的是，TypeScript能通知你错误地使用了this的地方。 如果你想了解JavaScript里的this是如何工作的，那么首先阅读Yehuda Katz写的Understanding JavaScript Function Invocation and “this”。 Yehuda的文章详细的阐述了this的内部工作原理，因此我们这里只做简单介绍。 this和箭头函数JavaScript里，this的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。 但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。 下面看一个例子： 1234567891011121314151617let deck = { suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;], cards: Array(52), createCardPicker: function() { return function() { let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return {suit: this.suits[pickedSuit], card: pickedCard % 13}; } }}let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(&quot;card: &quot; + pickedCard.card + &quot; of &quot; + pickedCard.suit); 可以看到createCardPicker是个函数，并且它又返回了一个函数。 如果我们尝试运行这个程序，会发现它并没有弹出对话框而是报错了。 因为createCardPicker返回的函数里的this被设置成了window而不是deck对象。 因为我们只是独立的调用了cardPicker()。 顶级的非方法式调用会将this视为window。 （注意：在严格模式下，this为undefined而不是window）。 为了解决这个问题，我们可以在函数被返回时就绑好正确的this。 这样的话，无论之后怎么使用它，都会引用绑定的‘deck’对象。 我们需要改变函数表达式来使用ECMAScript 6箭头语法。 箭头函数能保存函数创建时的this值，而不是调用时的值： 123456789101112131415161718let deck = { suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;], cards: Array(52), createCardPicker: function() { // NOTE: the line below is now an arrow function, allowing us to capture 'this' right here return () =&gt; { let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return {suit: this.suits[pickedSuit], card: pickedCard % 13}; } }}let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(&quot;card: &quot; + pickedCard.card + &quot; of &quot; + pickedCard.suit); 更好事情是，TypeScript会警告你犯了一个错误，如果你给编译器设置了--noImplicitThis标记。 它会指出this.suits[pickedSuit]里的this的类型为any。 this参数不幸的是，this.suits[pickedSuit]中的this的类型依旧为any。 这是因为this来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的this参数。 this参数是个假的参数，它出现在参数列表的最前面： 123function f(this: void) { // make sure `this` is unusable in this standalone function} 让我们往例子里添加一些接口，Card 和 Deck，让类型重用能够变得清晰简单些： 123456789101112131415161718192021222324252627interface Card { suit: string; card: number;}interface Deck { suits: string[]; cards: number[]; createCardPicker(this: Deck): () =&gt; Card;}let deck: Deck = { suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;], cards: Array(52), // NOTE: The function now explicitly specifies that its callee must be of type Deck createCardPicker: function(this: Deck) { return () =&gt; { let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return {suit: this.suits[pickedSuit], card: pickedCard % 13}; } }}let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(&quot;card: &quot; + pickedCard.card + &quot; of &quot; + pickedCard.suit); 现在TypeScript知道createCardPicker期望在某个Deck对象上调用。 也就是说this是Deck类型的，而非any，因此--noImplicitThis不会报错了。 回调函数里的this参数当你将一个函数传递到某个库函数里在稍后被调用时，你可能也见到过回调函数里的this会报错。 因为当回调函数被调用时，它会被当成一个普通函数调用，this将为undefined。 稍做改动，你就可以通过this参数来避免错误。 首先，库函数的作者要指定this的类型： 123interface UIElement { addClickListener(onclick: (this: void, e: Event) =&gt; void): void;} this: void意味着addClickListener期望onclick是一个函数且它不需要一个this类型。 然后，为调用代码里的this添加类型注解： 123456789class Handler { info: string; onClickBad(this: Handler, e: Event) { // oops, used this here. using this callback would crash at runtime this.info = e.message; }}let h = new Handler();uiElement.addClickListener(h.onClickBad); // error! 指定了this类型后，你显式声明onClickBad必须在Handler的实例上调用。 然后TypeScript会检测到addClickListener要求函数带有this: void。 改变this类型来修复这个错误： 123456789class Handler { info: string; onClickGood(this: void, e: Event) { // can't use this here because it's of type void! console.log('clicked!'); }}let h = new Handler();uiElement.addClickListener(h.onClickGood); 因为onClickGood指定了this类型为void，因此传递addClickListener是合法的。 当然了，这也意味着不能使用this.info. 如果你两者都想要，你不得不使用箭头函数了： 1234class Handler { info: string; onClickGood = (e: Event) =&gt; { this.info = e.message }} 这是可行的因为箭头函数使用外层的this，所以你总是可以把它们传给期望this: void的函数。 缺点是每个Handler对象都会创建一个箭头函数。 另一方面，方法只会被创建一次，添加到Handler的原型链上。 它们在不同Handler对象间是共享的。 重载JavaScript本身是个动态语言。 JavaScript里函数根据传入不同的参数而返回不同类型的数据是很常见的。 12345678910111213141516171819202122let suits = [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;];function pickCard(x): any { // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == &quot;object&quot;) { let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; } // Otherwise just let them pick the card else if (typeof x == &quot;number&quot;) { let pickedSuit = Math.floor(x / 13); return { suit: suits[pickedSuit], card: x % 13 }; }}let myDeck = [{ suit: &quot;diamonds&quot;, card: 2 }, { suit: &quot;spades&quot;, card: 10 }, { suit: &quot;hearts&quot;, card: 4 }];let pickedCard1 = myDeck[pickCard(myDeck)];alert(&quot;card: &quot; + pickedCard1.card + &quot; of &quot; + pickedCard1.suit);let pickedCard2 = pickCard(15);alert(&quot;card: &quot; + pickedCard2.card + &quot; of &quot; + pickedCard2.suit); pickCard方法根据传入参数的不同会返回两种不同的类型。 如果传入的是代表纸牌的对象，函数作用是从中抓一张牌。 如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。 方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载pickCard函数。 123456789101112131415161718192021222324let suits = [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;];function pickCard(x: {suit: string; card: number; }[]): number;function pickCard(x: number): {suit: string; card: number; };function pickCard(x): any { // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == &quot;object&quot;) { let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; } // Otherwise just let them pick the card else if (typeof x == &quot;number&quot;) { let pickedSuit = Math.floor(x / 13); return { suit: suits[pickedSuit], card: x % 13 }; }}let myDeck = [{ suit: &quot;diamonds&quot;, card: 2 }, { suit: &quot;spades&quot;, card: 10 }, { suit: &quot;hearts&quot;, card: 4 }];let pickedCard1 = myDeck[pickCard(myDeck)];alert(&quot;card: &quot; + pickedCard1.card + &quot; of &quot; + pickedCard1.suit);let pickedCard2 = pickCard(15);alert(&quot;card: &quot; + pickedCard2.card + &quot; of &quot; + pickedCard2.suit); 这样改变后，重载的pickCard函数在调用的时候会进行正确的类型检查。 为了让编译器能够选择正确的检查类型，它与JavaScript里的处理流程相似。 它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。 注意，function pickCard(x): any并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象另一个接收数字。 以其它参数调用pickCard会产生错误。 #typescript","link":"/2021/06/01/typescript/521cfbdc11/"},{"title":"类","text":"介绍传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。 类下面看一个使用类的例子： 1234567891011class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return &quot;Hello, &quot; + this.greeting; }}let greeter = new Greeter(&quot;world&quot;); 如果你使用过C#或Java，你会对这种语法非常熟悉。 我们声明一个Greeter类。这个类有3个成员：一个叫做greeting的属性，一个构造函数和一个greet方法。 你会注意到，我们在引用任何一个类成员的时候都用了this。 它表示我们访问的是类的成员。 最后一行，我们使用new构造了Greeter类的一个实例。 它会调用之前定义的构造函数，创建一个Greeter类型的新对象，并执行构造函数初始化它。 继承在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。 看下面的例子： 12345678910111213141516class Animal { move(distanceInMeters: number = 0) { console.log(`Animal moved ${distanceInMeters}m.`); }}class Dog extends Animal { bark() { console.log('Woof! Woof!'); }}const dog = new Dog();dog.bark();dog.move(10);dog.bark(); 这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，Dog是一个_派生类_，它派生自Animal基类，通过extends关键字。 派生类通常被称作_子类_，基类通常被称作_超类_。 因为Dog继承了Animal的功能，因此我们可以创建一个Dog的实例，它能够bark()和move()。 下面我们来看个更加复杂的例子。 1234567891011121314151617181920212223242526272829class Animal { name: string; constructor(theName: string) { this.name = theName; } move(distanceInMeters: number = 0) { console.log(`${this.name} moved ${distanceInMeters}m.`); }}class Snake extends Animal { constructor(name: string) { super(name); } move(distanceInMeters = 5) { console.log(&quot;Slithering...&quot;); super.move(distanceInMeters); }}class Horse extends Animal { constructor(name: string) { super(name); } move(distanceInMeters = 45) { console.log(&quot;Galloping...&quot;); super.move(distanceInMeters); }}let sam = new Snake(&quot;Sammy the Python&quot;);let tom: Animal = new Horse(&quot;Tommy the Palomino&quot;);sam.move();tom.move(34); 这个例子展示了一些上面没有提到的特性。 这一次，我们使用extends关键字创建了Animal的两个子类：Horse和Snake。 与前一个例子的不同点是，派生类包含了一个构造函数，它_必须_调用super()，它会执行基类的构造函数。 而且，在构造函数里访问this的属性之前，我们_一定_要调用super()。 这个是TypeScript强制执行的一条重要规则。 这个例子演示了如何在子类里可以重写父类的方法。 Snake类和Horse类都创建了move方法，它们重写了从Animal继承来的move方法，使得move方法根据不同的类而具有不同的功能。 注意，即使tom被声明为Animal类型，但因为它的值是Horse，调用tom.move(34)时，它会调用Horse里重写的方法： 1234Slithering...Sammy the Python moved 5m.Galloping...Tommy the Palomino moved 34m. 公共，私有与受保护的修饰符默认为public在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用public来做修饰；例如，C#要求必须明确地使用public指定成员是可见的。 在TypeScript里，成员都默认为public。 你也可以明确的将一个成员标记成public。 我们可以用下面的方式来重写上面的Animal类： 1234567class Animal { public name: string; public constructor(theName: string) { this.name = theName; } public move(distanceInMeters: number) { console.log(`${this.name} moved ${distanceInMeters}m.`); }} 理解private当成员被标记成private时，它就不能在声明它的类的外部访问。比如： 123456class Animal { private name: string; constructor(theName: string) { this.name = theName; }}new Animal(&quot;Cat&quot;).name; // 错误: 'name' 是私有的. TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。 然而，当我们比较带有private或protected成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个private成员，那么只有当另外一个类型中也存在这样一个private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于protected成员也使用这个规则。 下面来看一个例子，更好地说明了这一点： 1234567891011121314151617181920class Animal { private name: string; constructor(theName: string) { this.name = theName; }}class Rhino extends Animal { constructor() { super(&quot;Rhino&quot;); }}class Employee { private name: string; constructor(theName: string) { this.name = theName; }}let animal = new Animal(&quot;Goat&quot;);let rhino = new Rhino();let employee = new Employee(&quot;Bob&quot;);animal = rhino;animal = employee; // 错误: Animal 与 Employee 不兼容. 这个例子中有Animal和Rhino两个类，Rhino是Animal类的子类。 还有一个Employee类，其类型看上去与Animal是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为Animal和Rhino共享了来自Animal里的私有成员定义private name: string，因此它们是兼容的。 然而Employee却不是这样。当把Employee赋值给Animal的时候，得到一个错误，说它们的类型不兼容。 尽管Employee里也有一个私有成员name，但它明显不是Animal里面定义的那个。 理解protectedprotected修饰符与private修饰符的行为很相似，但有一点不同，protected成员在派生类中仍然可以访问。例如： 123456789101112131415161718192021class Person { protected name: string; constructor(name: string) { this.name = name; }}class Employee extends Person { private department: string; constructor(name: string, department: string) { super(name) this.department = department; } public getElevatorPitch() { return `Hello, my name is ${this.name} and I work in ${this.department}.`; }}let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;);console.log(howard.getElevatorPitch());console.log(howard.name); // 错误 注意，我们不能在Person类外使用name，但是我们仍然可以通过Employee类的实例方法访问，因为Employee是由Person派生而来的。 构造函数也可以被标记成protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如， 123456789101112131415161718192021class Person { protected name: string; protected constructor(theName: string) { this.name = theName; }}// Employee 能够继承 Personclass Employee extends Person { private department: string; constructor(name: string, department: string) { super(name); this.department = department; } public getElevatorPitch() { return `Hello, my name is ${this.name} and I work in ${this.department}.`; }}let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;);let john = new Person(&quot;John&quot;); // 错误: 'Person' 的构造函数是被保护的. readonly修饰符你可以使用readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 123456789class Octopus { readonly name: string; readonly numberOfLegs: number = 8; constructor (theName: string) { this.name = theName; }}let dad = new Octopus(&quot;Man with the 8 strong legs&quot;);dad.name = &quot;Man with the 3-piece suit&quot;; // 错误! name 是只读的. 参数属性在上面的例子中，我们不得不在在Person类里定义一个只读成员name和一个构造函数参数theName。这样做是为了在Octopus构造函数被执行后，就可以访问theName的值。 这种情况经常会遇到。_参数属性_可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前Animal类的修改版，使用了参数属性： 123456class Animal { constructor(private name: string) { } move(distanceInMeters: number) { console.log(`${this.name} moved ${distanceInMeters}m.`); }} 注意看我们是如何舍弃了theName，仅在构造函数里使用private name: string参数来创建和初始化name成员。 我们把声明和赋值合并至一处。 参数属性通过给构造函数参数添加一个访问限定符来声明。 使用private限定一个参数属性会声明并初始化一个私有成员；对于public和protected来说也是一样。 存取器TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。 下面来看如何把一个简单的类改写成使用get和set。 首先，我们从一个没有使用存取器的例子开始。 123456789class Employee { fullName: string;}let employee = new Employee();employee.fullName = &quot;Bob Smith&quot;;if (employee.fullName) { console.log(employee.fullName);} 允许随意设置fullName虽然方便，但是我们仍想在设置fullName强制执行某些约束。 在这个版本里，我们添加一个setter来检查newName的长度，以确保它满足数据库字段的最大长度限制。若它不满足，那么我们就抛一个错误来告诉客户端出错了。 为保留原有的功能，我们同时添加一个getter用来读取fullName。 1234567891011121314151617181920212223const fullNameMaxLength = 10;class Employee { private _fullName: string; get fullName(): string { return this._fullName; } set fullName(newName: string) { if (newName &amp;&amp; newName.length &gt; fullNameMaxLength) { throw new Error(&quot;fullName has a max length of &quot; + fullNameMaxLength); } this._fullName = newName; }}let employee = new Employee();employee.fullName = &quot;Bob Smith&quot;;if (employee.fullName) { alert(employee.fullName);} 为证明我们写的存取器现在能检查长度，我们可以给名字赋一个长度大于10字符的值，并验证是否得到一个错误。 对于存取器有下面几点需要注意的： 首先，存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有get不带有set的存取器自动被推断为readonly。 这在从代码生成.d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。 静态属性到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用static定义origin，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在origin前面加上类名。 如同在实例属性上使用this.前缀来访问属性一样，这里我们使用Grid.来访问静态属性。 123456789101112131415class Grid { static origin = {x: 0, y: 0}; calculateDistanceFromOrigin(point: {x: number; y: number;}) { let xDist = (point.x - Grid.origin.x); let yDist = (point.y - Grid.origin.y); return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; } constructor (public scale: number) { }}let grid1 = new Grid(1.0); // 1x scalelet grid2 = new Grid(5.0); // 5x scaleconsole.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10})); 抽象类抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节（抽象类中除抽象函数之外，其他函数可以包含具体实现）。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法。 123456abstract class Animal { abstract makeSound(): void; move(): void { console.log(&quot;roaming the earth...&quot;); }} 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含abstract关键字并且可以包含访问修饰符。 123456789101112131415161718192021222324252627282930313233abstract class Department { constructor(public name: string) { } printName(): void { console.log('Department name: ' + this.name); } abstract printMeeting(): void; // 必须在派生类中实现}class AccountingDepartment extends Department { constructor() { super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super() } printMeeting(): void { console.log('The Accounting Department meets each Monday at 10am.'); } generateReports(): void { console.log('Generating accounting reports...'); }}let department: Department; // 允许创建一个对抽象类型的引用department = new Department(); // 错误: 不能创建一个抽象类的实例department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值department.printName();department.printMeeting();department.generateReports(); // 错误: 方法在声明的抽象类中不存在 高级技巧构造函数当你在TypeScript里声明了一个类的时候，实际上同时声明了很多东西。 首先就是类的_实例_的类型。 12345678910111213class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return &quot;Hello, &quot; + this.greeting; }}let greeter: Greeter;greeter = new Greeter(&quot;world&quot;);console.log(greeter.greet()); 这里，我们写了let greeter: Greeter，意思是Greeter类的实例的类型是Greeter。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。 我们也创建了一个叫做_构造函数_的值。 这个函数会在我们使用new创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的： 12345678910111213let Greeter = (function () { function Greeter(message) { this.greeting = message; } Greeter.prototype.greet = function () { return &quot;Hello, &quot; + this.greeting; }; return Greeter;})();let greeter;greeter = new Greeter(&quot;world&quot;);console.log(greeter.greet()); 上面的代码里，let Greeter将被赋值为构造函数。 当我们调用new并执行了这个函数后，便会得到一个类的实例。 这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有_实例部分_与_静态部分_这两个部分。 让我们稍微改写一下这个例子，看看它们之间的区别： 12345678910111213141516171819202122class Greeter { static standardGreeting = &quot;Hello, there&quot;; greeting: string; greet() { if (this.greeting) { return &quot;Hello, &quot; + this.greeting; } else { return Greeter.standardGreeting; } }}let greeter1: Greeter;greeter1 = new Greeter();console.log(greeter1.greet());let greeterMaker: typeof Greeter = Greeter;greeterMaker.standardGreeting = &quot;Hey there!&quot;;let greeter2: Greeter = new greeterMaker();console.log(greeter2.greet()); 这个例子里，greeter1与之前看到的一样。 我们实例化Greeter类，并使用这个对象。 与我们之前看到的一样。 再之后，我们直接使用类。 我们创建了一个叫做greeterMaker的变量。 这个变量保存了这个类或者说保存了类构造函数。 然后我们使用typeof Greeter，意思是取Greeter类的类型，而不是实例的类型。 或者更确切的说，”告诉我Greeter标识符的类型”，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在greeterMaker上使用new，创建Greeter的实例。 把类当做接口使用如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。 12345678910class Point { x: number; y: number;}interface Point3d extends Point { z: number;}let point3d: Point3d = {x: 1, y: 2, z: 3}; #typescript","link":"/2021/06/01/typescript/994338fb03/"},{"title":"接口","text":"介绍TypeScript 的核心原则之一是对值所具有的_结构_进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 接口初探下面通过一个简单示例来观察接口是如何工作的： 123456function printLabel(labeledObj: { label: string }) { console.log(labeledObj.label);}let myObj = { size: 10, label: &quot;Size 10 Object&quot; };printLabel(myObj); 类型检查器会查看printLabel的调用。 printLabel有一个参数，并要求这个对象参数有一个名为label类型为string的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候 TypeScript 却并不会这么宽松，我们下面会稍做讲解。 下面我们重写上面的例子，这次使用接口来描述：必须包含一个label属性且类型为string： 12345678910interface LabeledValue { label: string;}function printLabel(labeledObj: LabeledValue) { console.log(labeledObj.label);}let myObj = { size: 10, label: &quot;Size 10 Object&quot; };printLabel(myObj); LabeledValue接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个label属性且类型为string的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给printLabel的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。 还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。 可选属性接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。 下面是应用了“option bags”的例子： 1234567891011121314151617interface SquareConfig { color?: string; width?: number;}function createSquare(config: SquareConfig): { color: string; area: number } { let newSquare = { color: &quot;white&quot;, area: 100 }; if (config.color) { newSquare.color = config.color; } if (config.width) { newSquare.area = config.width * config.width; } return newSquare;}let mySquare = createSquare({ color: &quot;black&quot; }); 带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。 可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将createSquare里的color属性名拼错，就会得到一个错误提示： 123456789101112131415161718interface SquareConfig { color?: string; width?: number;}function createSquare(config: SquareConfig): { color: string; area: number } { let newSquare = { color: &quot;white&quot;, area: 100 }; if (config.clor) { // Error: Property 'clor' does not exist on type 'SquareConfig' newSquare.color = config.clor; } if (config.width) { newSquare.area = config.width * config.width; } return newSquare;}let mySquare = createSquare({ color: &quot;black&quot; }); 只读属性一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用readonly来指定只读属性: 1234interface Point { readonly x: number; readonly y: number;} 你可以通过赋值一个对象字面量来构造一个Point。 赋值后，x和y再也不能被改变了。 12let p1: Point = { x: 10, y: 20 };p1.x = 5; // error! TypeScript 具有ReadonlyArray&lt;T&gt;类型，它与Array&lt;T&gt;相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改： 123456let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;ro[0] = 12; // error!ro.push(5); // error!ro.length = 100; // error!a = ro; // error! 上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写： 1a = ro as number[]; readonly vs const最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用const，若做为属性则使用readonly。 额外的属性检查我们在第一个例子里使用了接口，TypeScript 让我们传入{ size: number; label: string; }到仅期望得到{ label: string; }的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。 然而，天真地将这两者结合的话就会像在 JavaScript 里那样搬起石头砸自己的脚。比如，拿createSquare例子来说： 12345678910interface SquareConfig { color?: string; width?: number;}function createSquare(config: SquareConfig): { color: string; area: number } { // ...}let mySquare = createSquare({ colour: &quot;red&quot;, width: 100 }); 注意传入createSquare的参数拼写为colour而不是color。 在 JavaScript 里，这会默默地失败。 你可能会争辩这个程序已经正确地类型化了，因为width属性是兼容的，不存在color属性，而且额外的colour属性是无意义的。 然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过_额外属性检查_，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。 12// error: Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?let mySquare = createSquare({ colour: &quot;red&quot;, width: 100 }); 绕开这些检查非常简单。 最简便的方法是使用类型断言： 1let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig); 然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果SquareConfig带有上面定义的类型的color和width属性，并且_还会_带有任意数量的其它属性，那么我们可以这样定义它： 12345interface SquareConfig { color?: string; width?: number; [propName: string]: any;} 我们稍后会讲到索引签名，但在这我们要表示的是SquareConfig可以有任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。 还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为squareOptions不会经过额外属性检查，所以编译器不会报错。 12let squareOptions = { colour: &quot;red&quot;, width: 100 };let mySquare = createSquare(squareOptions); 上面的方法只在squareOptions和SquareConfig之间有共同的属性时才好用。 在这个例子中，这个属性为width。如果变量间不存在共同的对象属性将会报错。例如： 12let squareOptions = { colour: &quot;red&quot; };let mySquare = createSquare(squareOptions); 要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的 bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入color或colour属性到createSquare，你应该修改SquareConfig定义来体现出这一点。 函数类型接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。 为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。 123interface SearchFunc { (source: string, subString: string): boolean;} 这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。 12345let mySearch: SearchFunc;mySearch = function(source: string, subString: string) { let result = source.search(subString); return result &gt; -1;}; 对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子： 12345let mySearch: SearchFunc;mySearch = function(src: string, sub: string): boolean { let result = src.search(sub); return result &gt; -1;}; 函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了SearchFunc类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是false和true）。 12345let mySearch: SearchFunc;mySearch = function(src, sub) { let result = src.search(sub); return result &gt; -1;}; 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与SearchFunc接口中的定义不匹配。 12345678let mySearch: SearchFunc;// error: Type '(src: string, sub: string) =&gt; string' is not assignable to type 'SearchFunc'.// Type 'string' is not assignable to type 'boolean'.mySearch = function(src, sub) { let result = src.search(sub); return &quot;string&quot;;}; 可索引的类型与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[&quot;daniel&quot;]。 可索引类型具有一个_索引签名_，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子： 12345678interface StringArray { [index: number]: string;}let myArray: StringArray;myArray = [&quot;Bob&quot;, &quot;Fred&quot;];let myStr: string = myArray[0]; 上面例子里，我们定义了StringArray接口，它具有索引签名。 这个索引签名表示了当用number去索引StringArray时会得到string类型的返回值。 Typescript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用number来索引时，JavaScript 会将它转换成string然后再去索引对象。 也就是说用100（一个number）去索引等同于使用&quot;100&quot;（一个string）去索引，因此两者需要保持一致。 123456789101112class Animal { name: string;}class Dog extends Animal { breed: string;}// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!interface NotOkay { [x: number]: Animal; [x: string]: Dog;} 字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了obj.property和obj[&quot;property&quot;]两种形式都可以。 下面的例子里，name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示： 12345interface NumberDictionary { [index: string]: number; length: number; // 可以，length是number类型 name: string; // 错误，`name`的类型与索引类型返回值的类型不匹配} 但如果索引签名是包含属性类型的联合类型，那么使用不同类型的属性就是允许的。 12345interface NumberOrStringDictionary { [index: string]: number | string; length: number; // ok, length is a number name: string; // ok, name is a string} 最后，你可以将索引签名设置为只读，这样就防止了给索引赋值： 12345interface ReadonlyStringArray { readonly [index: number]: string;}let myArray: ReadonlyStringArray = [&quot;Alice&quot;, &quot;Bob&quot;];myArray[2] = &quot;Mallory&quot;; // error! 你不能设置myArray[2]，因为索引签名是只读的。 类类型实现接口与 C#或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。 12345678interface ClockInterface { currentTime: Date;}class Clock implements ClockInterface { currentTime: Date = new Date(); constructor(h: number, m: number) {}} 你也可以在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样： 123456789101112interface ClockInterface { currentTime: Date; setTime(d: Date): void;}class Clock implements ClockInterface { currentTime: Date = new Date(); setTime(d: Date) { this.currentTime = d; } constructor(h: number, m: number) {}} 接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。 类静态部分与实例部分的区别当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误： 12345678interface ClockConstructor { new (hour: number, minute: number);}class Clock implements ClockConstructor { currentTime: Date; constructor(h: number, m: number) {}} 这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor 存在于类的静态部分，所以不在检查的范围内。 因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口，ClockConstructor为构造函数所用和ClockInterface为实例方法所用。 为了方便我们定义一个构造函数createClock，它用传入的类型创建实例。 123456789101112131415161718192021222324252627282930interface ClockConstructor { new (hour: number, minute: number): ClockInterface;}interface ClockInterface { tick(): void;}function createClock( ctor: ClockConstructor, hour: number, minute: number): ClockInterface { return new ctor(hour, minute);}class DigitalClock implements ClockInterface { constructor(h: number, m: number) {} tick() { console.log(&quot;beep beep&quot;); }}class AnalogClock implements ClockInterface { constructor(h: number, m: number) {} tick() { console.log(&quot;tick tock&quot;); }}let digital = createClock(DigitalClock, 12, 17);let analog = createClock(AnalogClock, 7, 32); 因为createClock的第一个参数是ClockConstructor类型，在createClock(AnalogClock, 7, 32)里，会检查AnalogClock是否符合构造函数签名。 另一种简单方式是使用类表达式： 1234567891011121314interface ClockConstructor { new (hour: number, minute: number);}interface ClockInterface { tick();}const Clock: ClockConstructor = class Clock implements ClockInterface { constructor(h: number, m: number) {} tick() { console.log(&quot;beep beep&quot;); }}; 继承接口和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。 1234567891011interface Shape { color: string;}interface Square extends Shape { sideLength: number;}let square = {} as Square;square.color = &quot;blue&quot;;square.sideLength = 10; 一个接口可以继承多个接口，创建出多个接口的合成接口。 12345678910111213141516interface Shape { color: string;}interface PenStroke { penWidth: number;}interface Square extends Shape, PenStroke { sideLength: number;}let square = {} as Square;square.color = &quot;blue&quot;;square.sideLength = 10;square.penWidth = 5.0; 混合类型先前我们提过，接口能够描述 JavaScript 里丰富的类型。 因为 JavaScript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。 一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。 1234567891011121314151617interface Counter { (start: number): string; interval: number; reset(): void;}function getCounter(): Counter { let counter = function(start: number) {} as Counter; counter.interval = 123; counter.reset = function() {}; return counter;}let c = getCounter();c(10);c.reset();c.interval = 5.0; 在使用 JavaScript 第三方库的时候，你可能需要像上面那样去完整地定义类型。 接口继承类当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 private 和 protected 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。 当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 除了继承自基类，子类之间不必相关联。 例： 12345678910111213141516171819202122class Control { private state: any;}interface SelectableControl extends Control { select(): void;}class Button extends Control implements SelectableControl { select() {}}class TextBox extends Control { select() {}}class ImageControl implements SelectableControl {// Error: Class 'ImageControl' incorrectly implements interface 'SelectableControl'.// Types have separate declarations of a private property 'state'. private state: any; select() {}} 在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。 在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上，SelectableControl就像Control一样，并拥有一个select方法。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法）。而对于 ImageControl 类，它有自身的私有成员 state 而不是通过继承 Control 得来的，所以它不可以实现 SelectableControl 。 #typescript","link":"/2021/06/01/typescript/d802c53695/"},{"title":"Airbnb JavaScript Style Guide","text":"Types1.1 ::Primitives::: When you access a primitive type you work directly on its value. * `string` * `number` * `boolean` * `null` * `undefined` * `symbol` * `bigint` 12345const foo = 1;let bar = foo;bar = 9;console.log(foo, bar); // =&gt; 1, 9 * Symbols and BigInts cannot be faithfully polyfilled, so they should not be used when targeting browsers/environments that don’t support them natively. 1.2 ::Complex::: When you access a complex type you work on a reference to its value. object array function 123456const foo = [1, 2];const bar = foo;bar[0] = 9;console.log(foo[0], bar[0]); // =&gt; 9, 9 References 2.1 Use const for all of your references; avoid using var. eslint: prefer-const, no-const-assign Why? This ensures that you can’t reassign your references, which can lead to bugs and difficult to comprehend code. 1234567// badvar a = 1;var b = 2;// goodconst a = 1;const b = 2; 2.2 If you must reassign references, use let instead of var. eslint: no-var Why? let is block-scoped rather than function-scoped like var. 1234567891011// badvar count = 1;if (true) { count += 1;}// good, use the let.let count = 1;if (true) { count += 1;} 2.3 Note that both let and const are block-scoped, whereas var is function-scoped. 123456789// const and let only exist in the blocks they are defined in.{ let a = 1; const b = 1; var c = 1;}console.log(a); // ReferenceErrorconsole.log(b); // ReferenceErrorconsole.log(c); // Prints 1 In the above code, you can see that referencing a and b will produce a ReferenceError, while c contains the number. This is because a and b are block scoped, while c is scoped to the containing function. Objects 3.1 Use the literal syntax for object creation. eslint: no-new-object 12345// badconst item = new Object();// goodconst item = {}; 3.2 Use computed property names when creating objects with dynamic property names. Why? They allow you to define all the properties of an object in one place. 123456789101112131415161718function getKey(k) { return `a key named ${k}`;}// badconst obj = { id: 5, name: 'San Francisco',};obj[getKey('enabled')] = true;// goodconst obj = { id: 5, name: 'San Francisco', [getKey('enabled')]: true,}; 3.3 Use object method shorthand. eslint: object-shorthand 1234567891011121314151617// badconst atom = { value: 1, addValue: function (value) { return atom.value + value; },};// goodconst atom = { value: 1, addValue(value) { return atom.value + value; },}; 3.4 Use property value shorthand. eslint: object-shorthand Why? It is shorter and descriptive. 1234567891011const lukeSkywalker = 'Luke Skywalker';// badconst obj = { lukeSkywalker: lukeSkywalker,};// goodconst obj = { lukeSkywalker,}; 3.5 Group your shorthand properties at the beginning of your object declaration. Why? It’s easier to tell which properties are using the shorthand. 12345678910111213141516171819202122const anakinSkywalker = 'Anakin Skywalker';const lukeSkywalker = 'Luke Skywalker';// badconst obj = { episodeOne: 1, twoJediWalkIntoACantina: 2, lukeSkywalker, episodeThree: 3, mayTheFourth: 4, anakinSkywalker,};// goodconst obj = { lukeSkywalker, anakinSkywalker, episodeOne: 1, twoJediWalkIntoACantina: 2, episodeThree: 3, mayTheFourth: 4,}; 3.6 Only quote properties that are invalid identifiers. eslint: quote-props Why? In general we consider it subjectively easier to read. It improves syntax highlighting, and is also more easily optimized by many JS engines. 12345678910111213// badconst bad = { 'foo': 3, 'bar': 4, 'data-blah': 5,};// goodconst good = { foo: 3, bar: 4, 'data-blah': 5,}; 3.7 Do not call Object.prototype methods directly, such as hasOwnProperty, propertyIsEnumerable, and isPrototypeOf. eslint: no-prototype-builtins Why? These methods may be shadowed by properties on the object in question - consider { hasOwnProperty: false } - or, the object may be a null object (Object.create(null)). 123456789101112// badconsole.log(object.hasOwnProperty(key));// goodconsole.log(Object.prototype.hasOwnProperty.call(object, key));// bestconst has = Object.prototype.hasOwnProperty; // cache the lookup once, in module scope.console.log(has.call(object, key));/* or */import has from 'has'; // https://www.npmjs.com/package/hasconsole.log(has(object, key)); 3.8 Prefer the object spread syntax over Object.assign to shallow-copy objects. Use the object rest operator to get a new object with certain properties omitted. eslint: prefer-object-spread 1234567891011121314// very badconst original = { a: 1, b: 2 };const copy = Object.assign(original, { c: 3 }); // this mutates `original` ಠ_ಠdelete copy.a; // so does this// badconst original = { a: 1, b: 2 };const copy = Object.assign({}, original, { c: 3 }); // copy =&gt; { a: 1, b: 2, c: 3 }// goodconst original = { a: 1, b: 2 };const copy = { ...original, c: 3 }; // copy =&gt; { a: 1, b: 2, c: 3 }const { a, ...noA } = copy; // noA =&gt; { b: 2, c: 3 } Arrays 4.1 Use the literal syntax for array creation. eslint: no-array-constructor 12345// badconst items = new Array();// goodconst items = []; 4.2 Use Array#push instead of direct assignment to add items to an array. 1234567const someStack = [];// badsomeStack[someStack.length] = 'abracadabra';// goodsomeStack.push('abracadabra'); 4.3 Use array spreads ... to copy arrays. 1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i += 1) { itemsCopy[i] = items[i];}// goodconst itemsCopy = [...items]; 4.4 To convert an iterable object to an array, use spreads ... instead of Array.from. 1234567const foo = document.querySelectorAll('.foo');// goodconst nodes = Array.from(foo);// bestconst nodes = [...foo]; 4.5 Use Array.from for converting an array-like object to an array. 1234567const arrLike = { 0: 'foo', 1: 'bar', 2: 'baz', length: 3 };// badconst arr = Array.prototype.slice.call(arrLike);// goodconst arr = Array.from(arrLike); 4.6 Use Array.from instead of spread ... for mapping over iterables, because it avoids creating an intermediate array. 12345// badconst baz = [...foo].map(bar);// goodconst baz = Array.from(foo, bar); 4.7 Use return statements in array method callbacks. It’s ok to omit the return if the function body consists of a single statement returning an expression without side effects, following 8.2. eslint: array-callback-return 123456789101112131415161718192021222324252627282930313233343536373839// good[1, 2, 3].map((x) =&gt; { const y = x + 1; return x * y;});// good[1, 2, 3].map((x) =&gt; x + 1);// bad - no returned value means `acc` becomes undefined after the first iteration[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) =&gt; { const flatten = acc.concat(item);});// good[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) =&gt; { const flatten = acc.concat(item); return flatten;});// badinbox.filter((msg) =&gt; { const { subject, author } = msg; if (subject === 'Mockingbird') { return author === 'Harper Lee'; } else { return false; }});// goodinbox.filter((msg) =&gt; { const { subject, author } = msg; if (subject === 'Mockingbird') { return author === 'Harper Lee'; } return false;}); 4.8 Use line breaks after open and before close array brackets if an array has multiple lines 12345678910111213141516171819202122232425262728293031// badconst arr = [ [0, 1], [2, 3], [4, 5],];const objectInArray = [{ id: 1,}, { id: 2,}];const numberInArray = [ 1, 2,];// goodconst arr = [[0, 1], [2, 3], [4, 5]];const objectInArray = [ { id: 1, }, { id: 2, },];const numberInArray = [ 1, 2,]; Destructuring 5.1 Use object destructuring when accessing and using multiple properties of an object. eslint: prefer-destructuring Why? Destructuring saves you from creating temporary references for those properties, and from repetitive access of the object. Repeating object access creates more repetitive code, requires more reading, and creates more opportunities for mistakes. Destructuring objects also provides a single site of definition of the object structure that is used in the block, rather than requiring reading the entire block to determine what is used. 123456789101112131415161718// badfunction getFullName(user) { const firstName = user.firstName; const lastName = user.lastName; return `${firstName} ${lastName}`;}// goodfunction getFullName(user) { const { firstName, lastName } = user; return `${firstName} ${lastName}`;}// bestfunction getFullName({ firstName, lastName }) { return `${firstName} ${lastName}`;} 5.2 Use array destructuring. eslint: prefer-destructuring 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 5.3 Use object destructuring for multiple return values, not array destructuring. Why? You can add new properties over time or change the order of things without breaking call sites. 1234567891011121314151617// badfunction processInput(input) { // then a miracle occurs return [left, right, top, bottom];}// the caller needs to think about the order of return dataconst [left, __, top] = processInput(input);// goodfunction processInput(input) { // then a miracle occurs return { left, right, top, bottom };}// the caller selects only the data they needconst { left, top } = processInput(input); Strings 6.1 Use single quotes '' for strings. eslint: quotes 12345678// badconst name = &quot;Capt. Janeway&quot;;// bad - template literals should contain interpolation or newlinesconst name = `Capt. Janeway`;// goodconst name = 'Capt. Janeway'; 6.2 Strings that cause the line to go over 100 characters should not be written across multiple lines using string concatenation. Why? Broken strings are painful to work with and make code less searchable. 12345678910111213// badconst errorMessage = 'This is a super long error that was thrown because \\of Batman. When you stop to think about how Batman had anything to do \\with this, you would get nowhere \\fast.';// badconst errorMessage = 'This is a super long error that was thrown because ' + 'of Batman. When you stop to think about how Batman had anything to do ' + 'with this, you would get nowhere fast.';// goodconst errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.'; 6.3 When programmatically building up strings, use template strings instead of concatenation. eslint: prefer-template template-curly-spacing Why? Template strings give you a readable, concise syntax with proper newlines and string interpolation features. 12345678910111213141516171819// badfunction sayHi(name) { return 'How are you, ' + name + '?';}// badfunction sayHi(name) { return ['How are you, ', name, '?'].join();}// badfunction sayHi(name) { return `How are you, ${ name }?`;}// goodfunction sayHi(name) { return `How are you, ${name}?`;} 6.4 Never use eval() on a string, it opens too many vulnerabilities. eslint: no-eval 6.5 Do not unnecessarily escape characters in strings. eslint: no-useless-escape Why? Backslashes harm readability, thus they should only be present when necessary. 123456// badconst foo = '\\'this\\' \\i\\s \\&quot;quoted\\&quot;';// goodconst foo = '\\'this\\' is &quot;quoted&quot;';const foo = `my name is '${name}'`; Functions 7.1 Use named function expressions instead of function declarations. eslint: func-style Why? Function declarations are hoisted, which means that it’s easy - too easy - to reference the function before it is defined in the file. This harms readability and maintainability. If you find that a function’s definition is large or complex enough that it is interfering with understanding the rest of the file, then perhaps it’s time to extract it to its own module! Don’t forget to explicitly name the expression, regardless of whether or not the name is inferred from the containing variable (which is often the case in modern browsers or when using compilers such as Babel). This eliminates any assumptions made about the Error’s call stack. (Discussion) 123456789101112131415// badfunction foo() { // ...}// badconst foo = function () { // ...};// good// lexical name distinguished from the variable-referenced invocation(s)const short = function longUniqueMoreDescriptiveLexicalFoo() { // ...}; 7.2 Wrap immediately invoked function expressions in parentheses. eslint: wrap-iife Why? An immediately invoked function expression is a single unit - wrapping both it, and its invocation parens, in parens, cleanly expresses this. Note that in a world with modules everywhere, you almost never need an IIFE. 1234// immediately-invoked function expression (IIFE)(function () { console.log('Welcome to the Internet. Please follow me.');}()); 7.3 Never declare a function in a non-function block (if, while, etc). Assign the function to a variable instead. Browsers will allow you to do it, but they all interpret it differently, which is bad news bears. eslint: no-loop-func 7.4 Note: ECMA-262 defines a block as a list of statements. A function declaration is not a statement. 1234567891011121314// badif (currentUser) { function test() { console.log('Nope.'); }}// goodlet test;if (currentUser) { test = () =&gt; { console.log('Yup.'); };} 7.5 Never name a parameter arguments. This will take precedence over the arguments object that is given to every function scope. 123456789// badfunction foo(name, options, arguments) { // ...}// goodfunction foo(name, options, args) { // ...} 7.6 Never use arguments, opt to use rest syntax ... instead. eslint: prefer-rest-params Why? ... is explicit about which arguments you want pulled. Plus, rest arguments are a real Array, and not merely Array-like like arguments. 12345678910// badfunction concatenateAll() { const args = Array.prototype.slice.call(arguments); return args.join('');}// goodfunction concatenateAll(...args) { return args.join('');} 7.7 Use default parameter syntax rather than mutating function arguments. 123456789101112131415161718192021// really badfunction handleThings(opts) { // No! We shouldn’t mutate function arguments. // Double bad: if opts is falsy it'll be set to an object which may // be what you want but it can introduce subtle bugs. opts = opts || {}; // ...}// still badfunction handleThings(opts) { if (opts === void 0) { opts = {}; } // ...}// goodfunction handleThings(opts = {}) { // ...} 7.8 Avoid side effects with default parameters. Why? They are confusing to reason about. 123456789var b = 1;// badfunction count(a = b++) { console.log(a);}count(); // 1count(); // 2count(3); // 3count(); // 3 7.9 Always put default parameters last. eslint: default-param-last 123456789// badfunction handleThings(opts = {}, name) { // ...}// goodfunction handleThings(name, opts = {}) { // ...} 7.10 Never use the Function constructor to create a new function. eslint: no-new-func Why? Creating a function in this way evaluates a string similarly to eval(), which opens vulnerabilities. 12345// badvar add = new Function('a', 'b', 'return a + b');// still badvar subtract = Function('a', 'b', 'return a - b'); 7.11 Spacing in a function signature. eslint: space-before-function-paren space-before-blocks Why? Consistency is good, and you shouldn’t have to add or remove a space when adding or removing a name. 12345678// badconst f = function(){};const g = function (){};const h = function() {};// goodconst x = function () {};const y = function a() {}; 7.12 Never mutate parameters. eslint: no-param-reassign Why? Manipulating objects passed in as parameters can cause unwanted variable side effects in the original caller. 123456789// badfunction f1(obj) { obj.key = 1;}// goodfunction f2(obj) { const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1;} 7.13 Never reassign parameters. eslint: no-param-reassign Why? Reassigning parameters can lead to unexpected behavior, especially when accessing the arguments object. It can also cause optimization issues, especially in V8. 1234567891011121314151617181920// badfunction f1(a) { a = 1; // ...}function f2(a) { if (!a) { a = 1; } // ...}// goodfunction f3(a) { const b = a || 1; // ...}function f4(a = 1) { // ...} 7.14 Prefer the use of the spread syntax ... to call variadic functions. eslint: prefer-spread Why? It’s cleaner, you don’t need to supply a context, and you can not easily compose new with apply. 12345678910111213// badconst x = [1, 2, 3, 4, 5];console.log.apply(console, x);// goodconst x = [1, 2, 3, 4, 5];console.log(...x);// badnew (Function.prototype.bind.apply(Date, [null, 2016, 8, 5]));// goodnew Date(...[2016, 8, 5]); 7.15 Functions with multiline signatures, or invocations, should be indented just like every other multiline list in this guide: with each item on a line by itself, with a trailing comma on the last item. eslint: function-paren-newline 123456789101112131415161718192021222324252627// badfunction foo(bar, baz, quux) { // ...}// goodfunction foo( bar, baz, quux,) { // ...}// badconsole.log(foo, bar, baz);// goodconsole.log( foo, bar, baz,); Arrow Functions 8.1 When you must use an anonymous function (as when passing an inline callback), use arrow function notation. eslint: prefer-arrow-callback, arrow-spacing Why? It creates a version of the function that executes in the context of this, which is usually what you want, and is a more concise syntax. Why not? If you have a fairly complicated function, you might move that logic out into its own named function expression. 1234567891011// bad[1, 2, 3].map(function (x) { const y = x + 1; return x * y;});// good[1, 2, 3].map((x) =&gt; { const y = x + 1; return x * y;}); 8.2 If the function body consists of a single statement returning an expression without side effects, omit the braces and use the implicit return. Otherwise, keep the braces and use a return statement. eslint: arrow-parens, arrow-body-style Why? Syntactic sugar. It reads well when multiple functions are chained together. 12345678910111213141516171819202122232425262728293031323334353637// bad[1, 2, 3].map((number) =&gt; { const nextNumber = number + 1; `A string containing the ${nextNumber}.`;});// good[1, 2, 3].map((number) =&gt; `A string containing the ${number + 1}.`);// good[1, 2, 3].map((number) =&gt; { const nextNumber = number + 1; return `A string containing the ${nextNumber}.`;});// good[1, 2, 3].map((number, index) =&gt; ({ [index]: number,}));// No implicit return with side effectsfunction foo(callback) { const val = callback(); if (val === true) { // Do something if callback returns true }}let bool = false;// badfoo(() =&gt; bool = true);// goodfoo(() =&gt; { bool = true;}); 8.3 In case the expression spans over multiple lines, wrap it in parentheses for better readability. Why? It shows clearly where the function starts and ends. 1234567891011121314// bad['get', 'post', 'put'].map((httpMethod) =&gt; Object.prototype.hasOwnProperty.call( httpMagicObjectWithAVeryLongName, httpMethod, ));// good['get', 'post', 'put'].map((httpMethod) =&gt; ( Object.prototype.hasOwnProperty.call( httpMagicObjectWithAVeryLongName, httpMethod, ))); 8.4 Always include parentheses around arguments for clarity and consistency. eslint: arrow-parens Why? Minimizes diff churn when adding or removing arguments. 123456789101112131415161718192021222324252627// bad[1, 2, 3].map(x =&gt; x * x);// good[1, 2, 3].map((x) =&gt; x * x);// bad[1, 2, 3].map(number =&gt; ( `A long string with the ${number}. It’s so long that we don’t want it to take up space on the .map line!`));// good[1, 2, 3].map((number) =&gt; ( `A long string with the ${number}. It’s so long that we don’t want it to take up space on the .map line!`));// bad[1, 2, 3].map(x =&gt; { const y = x + 1; return x * y;});// good[1, 2, 3].map((x) =&gt; { const y = x + 1; return x * y;}); 8.5 Avoid confusing arrow function syntax (=&gt;) with comparison operators (&lt;=, &gt;=). eslint: no-confusing-arrow 1234567891011121314// badconst itemHeight = (item) =&gt; item.height &lt;= 256 ? item.largeSize : item.smallSize;// badconst itemHeight = (item) =&gt; item.height &gt;= 256 ? item.largeSize : item.smallSize;// goodconst itemHeight = (item) =&gt; (item.height &lt;= 256 ? item.largeSize : item.smallSize);// goodconst itemHeight = (item) =&gt; { const { height, largeSize, smallSize } = item; return height &lt;= 256 ? largeSize : smallSize;}; 8.6 Enforce the location of arrow function bodies with implicit returns. eslint: implicit-arrow-linebreak 12345678910111213// bad(foo) =&gt; bar;(foo) =&gt; (bar);// good(foo) =&gt; bar;(foo) =&gt; (bar);(foo) =&gt; ( bar) Classes &amp; Constructors 9.1 Always use class. Avoid manipulating prototype directly. Why? class syntax is more concise and easier to reason about. 123456789101112131415161718192021// badfunction Queue(contents = []) { this.queue = [...contents];}Queue.prototype.pop = function () { const value = this.queue[0]; this.queue.splice(0, 1); return value;};// goodclass Queue { constructor(contents = []) { this.queue = [...contents]; } pop() { const value = this.queue[0]; this.queue.splice(0, 1); return value; }} 9.2 Use extends for inheritance. Why? It is a built-in way to inherit prototype functionality without breaking instanceof. 12345678910111213141516// badconst inherits = require('inherits');function PeekableQueue(contents) { Queue.apply(this, contents);}inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function () { return this.queue[0];};// goodclass PeekableQueue extends Queue { peek() { return this.queue[0]; }} 9.3 Methods can return this to help with method chaining. 12345678910111213141516171819202122232425262728293031// badJedi.prototype.jump = function () { this.jumping = true; return true;};Jedi.prototype.setHeight = function (height) { this.height = height;};const luke = new Jedi();luke.jump(); // =&gt; trueluke.setHeight(20); // =&gt; undefined// goodclass Jedi { jump() { this.jumping = true; return this; } setHeight(height) { this.height = height; return this; }}const luke = new Jedi();luke.jump() .setHeight(20); 9.4 It’s okay to write a custom toString() method, just make sure it works successfully and causes no side effects. 12345678910111213class Jedi { constructor(options = {}) { this.name = options.name || 'no name'; } getName() { return this.name; } toString() { return `Jedi - ${this.getName()}`; }} 9.5 Classes have a default constructor if one is not specified. An empty constructor function or one that just delegates to a parent class is unnecessary. eslint: no-useless-constructor 1234567891011121314151617181920212223// badclass Jedi { constructor() {} getName() { return this.name; }}// badclass Rey extends Jedi { constructor(...args) { super(...args); }}// goodclass Rey extends Jedi { constructor(...args) { super(...args); this.name = 'Rey'; }} 9.6 Avoid duplicate class members. eslint: no-dupe-class-members Why? Duplicate class member declarations will silently prefer the last one - having duplicates is almost certainly a bug. 123456789101112131415// badclass Foo { bar() { return 1; } bar() { return 2; }}// goodclass Foo { bar() { return 1; }}// goodclass Foo { bar() { return 2; }} 9.7 Class methods should use this or be made into a static method unless an external library or framework requires to use specific non-static methods. Being an instance method should indicate that it behaves differently based on properties of the receiver. eslint: class-methods-use-this 123456789101112131415161718192021222324252627// badclass Foo { bar() { console.log('bar'); }}// good - this is usedclass Foo { bar() { console.log(this.bar); }}// good - constructor is exemptclass Foo { constructor() { // ... }}// good - static methods aren't expected to use thisclass Foo { static bar() { console.log('bar'); }} Modules 10.1 Always use modules (import/export) over a non-standard module system. You can always transpile to your preferred module system. Why? Modules are the future, let’s start using the future now. 1234567891011// badconst AirbnbStyleGuide = require('./AirbnbStyleGuide');module.exports = AirbnbStyleGuide.es6;// okimport AirbnbStyleGuide from './AirbnbStyleGuide';export default AirbnbStyleGuide.es6;// bestimport { es6 } from './AirbnbStyleGuide';export default es6; 10.2 Do not use wildcard imports. Why? This makes sure you have a single default export. 12345// badimport * as AirbnbStyleGuide from './AirbnbStyleGuide';// goodimport AirbnbStyleGuide from './AirbnbStyleGuide'; 10.3 And do not export directly from an import. Why? Although the one-liner is concise, having one clear way to import and one clear way to export makes things consistent. 12345678// bad// filename es6.jsexport { es6 as default } from './AirbnbStyleGuide';// good// filename es6.jsimport { es6 } from './AirbnbStyleGuide';export default es6; 10.4 Only import from a path in one place.eslint: no-duplicate-imports Why? Having multiple lines that import from the same path can make code harder to maintain. 12345678910111213// badimport foo from 'foo';// … some other imports … //import { named1, named2 } from 'foo';// goodimport foo, { named1, named2 } from 'foo';// goodimport foo, { named1, named2,} from 'foo'; 10.5 Do not export mutable bindings.eslint: import/no-mutable-exports Why? Mutation should be avoided in general, but in particular when exporting mutable bindings. While this technique may be needed for some special cases, in general, only constant references should be exported. 1234567// badlet foo = 3;export { foo };// goodconst foo = 3;export { foo }; 10.6 In modules with a single export, prefer default export over named export.eslint: import/prefer-default-export Why? To encourage more files that only ever export one thing, which is better for readability and maintainability. 12345// badexport function foo() {}// goodexport default function foo() {} 10.7 Put all imports above non-import statements.eslint: import/first Why? Since imports are hoisted, keeping them all at the top prevents surprising behavior. 1234567891011// badimport foo from 'foo';foo.init();import bar from 'bar';// goodimport foo from 'foo';import bar from 'bar';foo.init(); 10.8 Multiline imports should be indented just like multiline array and object literals.eslint: object-curly-newline Why? The curly braces follow the same indentation rules as every other curly brace block in the style guide, as do the trailing commas. 1234567891011// badimport {longNameA, longNameB, longNameC, longNameD, longNameE} from 'path';// goodimport { longNameA, longNameB, longNameC, longNameD, longNameE,} from 'path'; 10.9 Disallow Webpack loader syntax in module import statements.eslint: import/no-webpack-loader-syntax Why? Since using Webpack syntax in the imports couples the code to a module bundler. Prefer using the loader syntax in webpack.config.js. 1234567// badimport fooSass from 'css!sass!foo.scss';import barCss from 'style!css!bar.css';// goodimport fooSass from 'foo.scss';import barCss from 'bar.css'; 10.10 Do not include JavaScript filename extensionseslint: import/extensions Why? Including extensions inhibits refactoring, and inappropriately hardcodes implementation details of the module you’re importing in every consumer. 123456789// badimport foo from './foo.js';import bar from './bar.jsx';import baz from './baz/index.jsx';// goodimport foo from './foo';import bar from './bar';import baz from './baz'; Iterators and Generators 11.1 Don’t use iterators. Prefer JavaScript’s higher-order functions instead of loops like for-in or for-of. eslint: no-iterator no-restricted-syntax Why? This enforces our immutable rule. Dealing with pure functions that return values is easier to reason about than side effects. Use map() / every() / filter() / find() / findIndex() / reduce() / some() / … to iterate over arrays, and Object.keys() / Object.values() / Object.entries() to produce arrays so you can iterate over objects. 12345678910111213141516171819202122232425262728293031323334const numbers = [1, 2, 3, 4, 5];// badlet sum = 0;for (let num of numbers) { sum += num;}sum === 15;// goodlet sum = 0;numbers.forEach((num) =&gt; { sum += num;});sum === 15;// best (use the functional force)const sum = numbers.reduce((total, num) =&gt; total + num, 0);sum === 15;// badconst increasedByOne = [];for (let i = 0; i &lt; numbers.length; i++) { increasedByOne.push(numbers[i] + 1);}// goodconst increasedByOne = [];numbers.forEach((num) =&gt; { increasedByOne.push(num + 1);});// best (keeping it functional)const increasedByOne = numbers.map((num) =&gt; num + 1); 11.2 Don’t use generators for now. Why? They don’t transpile well to ES5. 11.3 If you must use generators, or if you disregard our advice, make sure their function signature is spaced properly. eslint: generator-star-spacing Why? function and * are part of the same conceptual keyword - * is not a modifier for function, function* is a unique construct, different from function. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// badfunction * foo() { // ...}// badconst bar = function * () { // ...};// badconst baz = function *() { // ...};// badconst quux = function*() { // ...};// badfunction*foo() { // ...}// badfunction *foo() { // ...}// very badfunction*foo() { // ...}// very badconst wat = function*() { // ...};// goodfunction* foo() { // ...}// goodconst foo = function* () { // ...}; Properties 12.1 Use dot notation when accessing properties. eslint: dot-notation 12345678910const luke = { jedi: true, age: 28,};// badconst isJedi = luke['jedi'];// goodconst isJedi = luke.jedi; 12.2 Use bracket notation [] when accessing properties with a variable. 12345678910const luke = { jedi: true, age: 28,};function getProp(prop) { return luke[prop];}const isJedi = getProp('jedi'); 12.3 Use exponentiation operator ** when calculating exponentiations. eslint: no-restricted-properties. 12345// badconst binary = Math.pow(2, 10);// goodconst binary = 2 ** 10; Variables 13.1 Always use const or let to declare variables. Not doing so will result in global variables. We want to avoid polluting the global namespace. Captain Planet warned us of that. eslint: no-undef prefer-const 12345// badsuperPower = new SuperPower();// goodconst superPower = new SuperPower(); 13.2 Use one const or let declaration per variable or assignment. eslint: one-var Why? It’s easier to add new variable declarations this way, and you never have to worry about swapping out a ; for a , or introducing punctuation-only diffs. You can also step through each declaration with the debugger, instead of jumping through all of them at once. 123456789101112131415// badconst items = getItems(), goSportsTeam = true, dragonball = 'z';// bad// (compare to above, and try to spot the mistake)const items = getItems(), goSportsTeam = true; dragonball = 'z';// goodconst items = getItems();const goSportsTeam = true;const dragonball = 'z'; 13.3 Group all your consts and then group all your lets. Why? This is helpful when later on you might need to assign a variable depending on one of the previously assigned variables. 123456789101112131415161718// badlet i, len, dragonball, items = getItems(), goSportsTeam = true;// badlet i;const items = getItems();let dragonball;const goSportsTeam = true;let len;// goodconst goSportsTeam = true;const items = getItems();let dragonball;let i;let length; 13.4 Assign variables where you need them, but place them in a reasonable place. Why? let and const are block scoped and not function scoped. 12345678910111213141516171819202122232425262728293031// bad - unnecessary function callfunction checkName(hasName) { const name = getName(); if (hasName === 'test') { return false; } if (name === 'test') { this.setName(''); return false; } return name;}// goodfunction checkName(hasName) { if (hasName === 'test') { return false; } const name = getName(); if (name === 'test') { this.setName(''); return false; } return name;} 13.5 Don’t chain variable assignments. eslint: no-multi-assign Why? Chaining variable assignments creates implicit global variables. 12345678910111213141516171819202122232425// bad(function example() { // JavaScript interprets this as // let a = ( b = ( c = 1 ) ); // The let keyword only applies to variable a; variables b and c become // global variables. let a = b = c = 1;}());console.log(a); // throws ReferenceErrorconsole.log(b); // 1console.log(c); // 1// good(function example() { let a = 1; let b = a; let c = a;}());console.log(a); // throws ReferenceErrorconsole.log(b); // throws ReferenceErrorconsole.log(c); // throws ReferenceError// the same applies for `const` 13.6 Avoid using unary increments and decrements (++, --). eslint no-plusplus Why? Per the eslint documentation, unary increment and decrement statements are subject to automatic semicolon insertion and can cause silent errors with incrementing or decrementing values within an application. It is also more expressive to mutate your values with statements like num += 1 instead of num++ or num ++. Disallowing unary increment and decrement statements also prevents you from pre-incrementing/pre-decrementing values unintentionally which can also cause unexpected behavior in your programs. 1234567891011121314151617181920212223242526// badconst array = [1, 2, 3];let num = 1;num++;--num;let sum = 0;let truthyCount = 0;for (let i = 0; i &lt; array.length; i++) { let value = array[i]; sum += value; if (value) { truthyCount++; }}// goodconst array = [1, 2, 3];let num = 1;num += 1;num -= 1;const sum = array.reduce((a, b) =&gt; a + b, 0);const truthyCount = array.filter(Boolean).length; 13.7 Avoid linebreaks before or after = in an assignment. If your assignment violates max-len, surround the value in parens. eslint operator-linebreak. Why? Linebreaks surrounding = can obfuscate the value of an assignment. 123456789101112131415// badconst foo = superLongLongLongLongLongLongLongLongFunctionName();// badconst foo = 'superLongLongLongLongLongLongLongLongString';// goodconst foo = ( superLongLongLongLongLongLongLongLongFunctionName());// goodconst foo = 'superLongLongLongLongLongLongLongLongString'; 13.8 Disallow unused variables. eslint: no-unused-vars Why? Variables that are declared and not used anywhere in the code are most likely an error due to incomplete refactoring. Such variables take up space in the code and can lead to confusion by readers. 1234567891011121314151617181920212223242526272829303132// badvar some_unused_var = 42;// Write-only variables are not considered as used.var y = 10;y = 5;// A read for a modification of itself is not considered as used.var z = 0;z = z + 1;// Unused function arguments.function getX(x, y) { return x;}// goodfunction getXPlusY(x, y) { return x + y;}var x = 1;var y = a + 2;alert(getXPlusY(x, y));// 'type' is ignored even if unused because it has a rest property sibling.// This is a form of extracting an object that omits the specified keys.var { type, ...coords } = data;// 'coords' is now the 'data' object without its 'type' property. Hoisting 14.1 var declarations get hoisted to the top of their closest enclosing function scope, their assignment does not. const and let declarations are blessed with a new concept called Temporal Dead Zones (TDZ). It’s important to know why typeof is no longer safe. 123456789101112131415161718192021222324252627282930// we know this wouldn’t work (assuming there// is no notDefined global variable)function example() { console.log(notDefined); // =&gt; throws a ReferenceError}// creating a variable declaration after you// reference the variable will work due to// variable hoisting. Note: the assignment// value of `true` is not hoisted.function example() { console.log(declaredButNotAssigned); // =&gt; undefined var declaredButNotAssigned = true;}// the interpreter is hoisting the variable// declaration to the top of the scope,// which means our example could be rewritten as:function example() { let declaredButNotAssigned; console.log(declaredButNotAssigned); // =&gt; undefined declaredButNotAssigned = true;}// using const and letfunction example() { console.log(declaredButNotAssigned); // =&gt; throws a ReferenceError console.log(typeof declaredButNotAssigned); // =&gt; throws a ReferenceError const declaredButNotAssigned = true;} 14.2 Anonymous function expressions hoist their variable name, but not the function assignment. 123456789function example() { console.log(anonymous); // =&gt; undefined anonymous(); // =&gt; TypeError anonymous is not a function var anonymous = function () { console.log('anonymous function expression'); };} 14.3 Named function expressions hoist the variable name, not the function name or the function body. 1234567891011121314151617181920212223function example() { console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function superPower(); // =&gt; ReferenceError superPower is not defined var named = function superPower() { console.log('Flying'); };}// the same is true when the function name// is the same as the variable name.function example() { console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function var named = function named() { console.log('named'); };} 14.4 Function declarations hoist their name and the function body. 1234567function example() { superPower(); // =&gt; Flying function superPower() { console.log('Flying'); }} For more information refer to JavaScript Scoping &amp; Hoisting by Ben Cherry. Comparison Operators &amp; Equality 15.1 Use === and !== over == and !=. eslint: eqeqeq 15.2 Conditional statements such as the if statement evaluate their expression using coercion with the ToBoolean abstract method and always follow these simple rules: Objects evaluate to true Undefined evaluates to false Null evaluates to false Booleans evaluate to the value of the boolean Numbers evaluate to false if +0, -0, or NaN, otherwise true Strings evaluate to false if an empty string '', otherwise true 1234if ([0] &amp;&amp; []) { // true // an array (even an empty one) is an object, objects will evaluate to true} 15.3 Use shortcuts for booleans, but explicit comparisons for strings and numbers. 1234567891011121314151617181920212223242526272829// badif (isValid === true) { // ...}// goodif (isValid) { // ...}// badif (name) { // ...}// goodif (name !== '') { // ...}// badif (collection.length) { // ...}// goodif (collection.length &gt; 0) { // ...} 15.4 For more information see Truth Equality and JavaScript by Angus Croll. 15.5 Use braces to create blocks in case and default clauses that contain lexical declarations (e.g. let, const, function, and class). eslint: no-case-declarations Why? Lexical declarations are visible in the entire switch block but only get initialized when assigned, which only happens when its case is reached. This causes problems when multiple case clauses attempt to define the same thing. 12345678910111213141516171819202122232425262728293031323334353637383940// badswitch (foo) { case 1: let x = 1; break; case 2: const y = 2; break; case 3: function f() { // ... } break; default: class C {}}// goodswitch (foo) { case 1: { let x = 1; break; } case 2: { const y = 2; break; } case 3: { function f() { // ... } break; } case 4: bar(); break; default: { class C {} }} 15.6 Ternaries should not be nested and generally be single line expressions. eslint: no-nested-ternary 123456789101112131415// badconst foo = maybe1 &gt; maybe2 ? &quot;bar&quot; : value1 &gt; value2 ? &quot;baz&quot; : null;// split into 2 separated ternary expressionsconst maybeNull = value1 &gt; value2 ? 'baz' : null;// betterconst foo = maybe1 &gt; maybe2 ? 'bar' : maybeNull;// bestconst foo = maybe1 &gt; maybe2 ? 'bar' : maybeNull; 15.7 Avoid unneeded ternary statements. eslint: no-unneeded-ternary 123456789// badconst foo = a ? a : b;const bar = c ? true : false;const baz = c ? false : true;// goodconst foo = a || b;const bar = !!c;const baz = !c; 15.8 When mixing operators, enclose them in parentheses. The only exception is the standard arithmetic operators: +, -, and ** since their precedence is broadly understood. We recommend enclosing / and * in parentheses because their precedence can be ambiguous when they are mixed.eslint: no-mixed-operators Why? This improves readability and clarifies the developer’s intention. 12345678910111213141516171819202122232425262728// badconst foo = a &amp;&amp; b &lt; 0 || c &gt; 0 || d + 1 === 0;// badconst bar = a ** b - 5 % d;// bad// one may be confused into thinking (a || b) &amp;&amp; cif (a || b &amp;&amp; c) { return d;}// badconst bar = a + b / c * d;// goodconst foo = (a &amp;&amp; b &lt; 0) || c &gt; 0 || (d + 1 === 0);// goodconst bar = a ** b - (5 % d);// goodif (a || (b &amp;&amp; c)) { return d;}// goodconst bar = a + (b / c) * d; Blocks 16.1 Use braces with all multiline blocks. eslint: nonblock-statement-body-position 12345678910111213141516171819// badif (test) return false;// goodif (test) return false;// goodif (test) { return false;}// badfunction foo() { return false; }// goodfunction bar() { return false;} 16.2 If you’re using multiline blocks with if and else, put else on the same line as your if block’s closing brace. eslint: brace-style 12345678910111213141516// badif (test) { thing1(); thing2();}else { thing3();}// goodif (test) { thing1(); thing2();} else { thing3();} 16.3 If an if block always executes a return statement, the subsequent else block is unnecessary. A return in an else if block following an if block that contains a return can be separated into multiple if blocks. eslint: no-else-return 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// badfunction foo() { if (x) { return x; } else { return y; }}// badfunction cats() { if (x) { return x; } else if (y) { return y; }}// badfunction dogs() { if (x) { return x; } else { if (y) { return y; } }}// goodfunction foo() { if (x) { return x; } return y;}// goodfunction cats() { if (x) { return x; } if (y) { return y; }}// goodfunction dogs(x) { if (x) { if (z) { return y; } } else { return z; }} Control Statements 17.1 In case your control statement (if, while etc.) gets too long or exceeds the maximum line length, each (grouped) condition could be put into a new line. The logical operator should begin the line. Why? Requiring operators at the beginning of the line keeps the operators aligned and follows a pattern similar to method chaining. This also improves readability by making it easier to visually follow complex logic. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// badif ((foo === 123 || bar === 'abc') &amp;&amp; doesItLookGoodWhenItBecomesThatLong() &amp;&amp; isThisReallyHappening()) { thing1();}// badif (foo === 123 &amp;&amp; bar === 'abc') { thing1();}// badif (foo === 123 &amp;&amp; bar === 'abc') { thing1();}// badif ( foo === 123 &amp;&amp; bar === 'abc') { thing1();}// goodif ( foo === 123 &amp;&amp; bar === 'abc') { thing1();}// goodif ( (foo === 123 || bar === 'abc') &amp;&amp; doesItLookGoodWhenItBecomesThatLong() &amp;&amp; isThisReallyHappening()) { thing1();}// goodif (foo === 123 &amp;&amp; bar === 'abc') { thing1();} 17.2 Don’t use selection operators in place of control statements. 1234567// bad!isRunning &amp;&amp; startRunning();// goodif (!isRunning) { startRunning();} Comments 18.1 Use /** ... */ for multiline comments. 123456789101112131415161718192021222324// bad// make() returns a new element// based on the passed in tag name//// @param {String} tag// @return {Element} elementfunction make(tag) { // ... return element;}// good/** * make() returns a new element * based on the passed-in tag name */function make(tag) { // ... return element;} 18.2 Use // for single line comments. Place single line comments on a newline above the subject of the comment. Put an empty line before the comment unless it’s on the first line of a block. 123456789101112131415161718192021222324252627282930313233// badconst active = true; // is current tab// good// is current tabconst active = true;// badfunction getType() { console.log('fetching type...'); // set the default type to 'no type' const type = this.type || 'no type'; return type;}// goodfunction getType() { console.log('fetching type...'); // set the default type to 'no type' const type = this.type || 'no type'; return type;}// also goodfunction getType() { // set the default type to 'no type' const type = this.type || 'no type'; return type;} 18.3 Start all comments with a space to make it easier to read. eslint: spaced-comment 12345678910111213141516171819202122232425262728293031// bad//is current tabconst active = true;// good// is current tabconst active = true;// bad/** *make() returns a new element *based on the passed-in tag name */function make(tag) { // ... return element;}// good/** * make() returns a new element * based on the passed-in tag name */function make(tag) { // ... return element;} 18.4 Prefixing your comments with FIXME or TODO helps other developers quickly understand if you’re pointing out a problem that needs to be revisited, or if you’re suggesting a solution to the problem that needs to be implemented. These are different than regular comments because they are actionable. The actions are FIXME: -- need to figure this out or TODO: -- need to implement. 18.5 Use // FIXME: to annotate problems. 12345678class Calculator extends Abacus { constructor() { super(); // FIXME: shouldn’t use a global here total = 0; }} 18.6 Use // TODO: to annotate solutions to problems. 12345678class Calculator extends Abacus { constructor() { super(); // TODO: total should be configurable by an options param this.total = 0; }} Whitespace 19.1 Use soft tabs (space character) set to 2 spaces. eslint: indent 1234567891011121314// badfunction foo() {∙∙∙∙let name;}// badfunction bar() {∙let name;}// goodfunction baz() {∙∙let name;} 19.2 Place 1 space before the leading brace. eslint: space-before-blocks 123456789101112131415161718192021// badfunction test(){ console.log('test');}// goodfunction test() { console.log('test');}// baddog.set('attr',{ age: '1 year', breed: 'Bernese Mountain Dog',});// gooddog.set('attr', { age: '1 year', breed: 'Bernese Mountain Dog',}); 19.3 Place 1 space before the opening parenthesis in control statements (if, while etc.). Place no space between the argument list and the function name in function calls and declarations. eslint: keyword-spacing 12345678910111213141516171819// badif(isJedi) { fight ();}// goodif (isJedi) { fight();}// badfunction fight () { console.log ('Swooosh!');}// goodfunction fight() { console.log('Swooosh!');} 19.4 Set off operators with spaces. eslint: space-infix-ops 12345// badconst x=y+5;// goodconst x = y + 5; 19.5 End files with a single newline character. eslint: eol-last 1234// badimport { es6 } from './AirbnbStyleGuide'; // ...export default es6; 12345// badimport { es6 } from './AirbnbStyleGuide'; // ...export default es6;↵↵ 1234// goodimport { es6 } from './AirbnbStyleGuide'; // ...export default es6;↵ 19.6 Use indentation when making long method chains (more than 2 method chains). Use a leading dot, whichemphasizes that the line is a method call, not a new statement. eslint: newline-per-chained-call no-whitespace-before-property 1234567891011121314151617181920212223242526272829303132333435363738394041// bad$('#items').find('.selected').highlight().end().find('.open').updateCount();// bad$('#items'). find('.selected'). highlight(). end(). find('.open'). updateCount();// good$('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount();// badconst leds = stage.selectAll('.led').data(data).enter().append('svg:svg').classed('led', true) .attr('width', (radius + margin) * 2).append('svg:g') .attr('transform', `translate(${radius + margin},${radius + margin})`) .call(tron.led);// goodconst leds = stage.selectAll('.led') .data(data) .enter().append('svg:svg') .classed('led', true) .attr('width', (radius + margin) * 2) .append('svg:g') .attr('transform', `translate(${radius + margin},${radius + margin})`) .call(tron.led);// goodconst leds = stage.selectAll('.led').data(data);const svg = leds.enter().append('svg:svg');svg.classed('led', true).attr('width', (radius + margin) * 2);const g = svg.append('svg:g');g.attr('transform', `translate(${radius + margin},${radius + margin})`).call(tron.led); 19.7 Leave a blank line after blocks and before the next statement. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// badif (foo) { return bar;}return baz;// goodif (foo) { return bar;}return baz;// badconst obj = { foo() { }, bar() { },};return obj;// goodconst obj = { foo() { }, bar() { },};return obj;// badconst arr = [ function foo() { }, function bar() { },];return arr;// goodconst arr = [ function foo() { }, function bar() { },];return arr; 19.8 Do not pad your blocks with blank lines. eslint: padded-blocks 1234567891011121314151617181920212223242526272829303132333435// badfunction bar() { console.log(foo);}// badif (baz) { console.log(qux);} else { console.log(foo);}// badclass Foo { constructor(bar) { this.bar = bar; }}// goodfunction bar() { console.log(foo);}// goodif (baz) { console.log(qux);} else { console.log(foo);} 19.9 Do not use multiple blank lines to pad your code. eslint: no-multiple-empty-lines 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// badclass Person { constructor(fullName, email, birthday) { this.fullName = fullName; this.email = email; this.setAge(birthday); } setAge(birthday) { const today = new Date(); const age = this.getAge(today, birthday); this.age = age; } getAge(today, birthday) { // .. }}// goodclass Person { constructor(fullName, email, birthday) { this.fullName = fullName; this.email = email; this.setAge(birthday); } setAge(birthday) { const today = new Date(); const age = getAge(today, birthday); this.age = age; } getAge(today, birthday) { // .. }} 19.10 Do not add spaces inside parentheses. eslint: space-in-parens 12345678910111213141516171819// badfunction bar( foo ) { return foo;}// goodfunction bar(foo) { return foo;}// badif ( foo ) { console.log(foo);}// goodif (foo) { console.log(foo);} 19.11 Do not add spaces inside brackets. eslint: array-bracket-spacing 1234567// badconst foo = [ 1, 2, 3 ];console.log(foo[ 0 ]);// goodconst foo = [1, 2, 3];console.log(foo[0]); 19.12 Add spaces inside curly braces. eslint: object-curly-spacing 12345// badconst foo = {clark: 'kent'};// goodconst foo = { clark: 'kent' }; 19.13 Avoid having lines of code that are longer than 100 characters (including whitespace). Note: per above, long strings are exempt from this rule, and should not be broken up. eslint: max-len Why? This ensures readability and maintainability. 12345678910111213141516171819202122// badconst foo = jsonData &amp;&amp; jsonData.foo &amp;&amp; jsonData.foo.bar &amp;&amp; jsonData.foo.bar.baz &amp;&amp; jsonData.foo.bar.baz.quux &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy;// bad$.ajax({ method: 'POST', url: 'https://airbnb.com/', data: { name: 'John' } }).done(() =&gt; console.log('Congratulations!')).fail(() =&gt; console.log('You have failed this city.'));// goodconst foo = jsonData &amp;&amp; jsonData.foo &amp;&amp; jsonData.foo.bar &amp;&amp; jsonData.foo.bar.baz &amp;&amp; jsonData.foo.bar.baz.quux &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy;// good$.ajax({ method: 'POST', url: 'https://airbnb.com/', data: { name: 'John' },}) .done(() =&gt; console.log('Congratulations!')) .fail(() =&gt; console.log('You have failed this city.')); 19.14 Require consistent spacing inside an open block token and the next token on the same line. This rule also enforces consistent spacing inside a close block token and previous token on the same line. eslint: block-spacing 1234567// badfunction foo() {return true;}if (foo) { bar = 0;}// goodfunction foo() { return true; }if (foo) { bar = 0; } 19.15 Avoid spaces before commas and require a space after commas. eslint: comma-spacing 1234567// badvar foo = 1,bar = 2;var arr = [1 , 2];// goodvar foo = 1, bar = 2;var arr = [1, 2]; 19.16 Enforce spacing inside of computed property brackets. eslint: computed-property-spacing 1234567891011// badobj[foo ]obj[ 'foo']var x = {[ b ]: a}obj[foo[ bar ]]// goodobj[foo]obj['foo']var x = { [b]: a }obj[foo[bar]] 19.17 Avoid spaces between functions and their invocations. eslint: func-call-spacing 12345678// badfunc ();func();// goodfunc(); 19.18 Enforce spacing between keys and values in object literal properties. eslint: key-spacing 123456// badvar obj = { foo : 42 };var obj2 = { foo:42 };// goodvar obj = { foo: 42 }; 19.19 Avoid trailing spaces at the end of lines. eslint: no-trailing-spaces 19.20 Avoid multiple empty lines, only allow one newline at the end of files, and avoid a newline at the beginning of files. eslint: no-multiple-empty-lines 1234567891011121314151617181920// bad - multiple empty linesvar x = 1;var y = 2;// bad - 2+ newlines at end of filevar x = 1;var y = 2;// bad - 1+ newline(s) at beginning of filevar x = 1;var y = 2;// goodvar x = 1;var y = 2; Commas 20.1 Leading commas: Nope. eslint: comma-style 1234567891011121314151617181920212223242526272829// badconst story = [ once , upon , aTime];// goodconst story = [ once, upon, aTime,];// badconst hero = { firstName: 'Ada' , lastName: 'Lovelace' , birthYear: 1815 , superPower: 'computers'};// goodconst hero = { firstName: 'Ada', lastName: 'Lovelace', birthYear: 1815, superPower: 'computers',}; 20.2 Additional trailing comma: Yup. eslint: comma-dangle Why? This leads to cleaner git diffs. Also, transpilers like Babel will remove the additional trailing comma in the transpiled code which means you don’t have to worry about the trailing comma problem in legacy browsers. 1234567891011121314// bad - git diff without trailing commaconst hero = { firstName: 'Florence',- lastName: 'Nightingale'+ lastName: 'Nightingale',+ inventorOf: ['coxcomb chart', 'modern nursing']};// good - git diff with trailing commaconst hero = { firstName: 'Florence', lastName: 'Nightingale',+ inventorOf: ['coxcomb chart', 'modern nursing'],}; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// badconst hero = { firstName: 'Dana', lastName: 'Scully'};const heroes = [ 'Batman', 'Superman'];// goodconst hero = { firstName: 'Dana', lastName: 'Scully',};const heroes = [ 'Batman', 'Superman',];// badfunction createHero( firstName, lastName, inventorOf) { // does nothing}// goodfunction createHero( firstName, lastName, inventorOf,) { // does nothing}// good (note that a comma must not appear after a &quot;rest&quot; element)function createHero( firstName, lastName, inventorOf, ...heroArgs) { // does nothing}// badcreateHero( firstName, lastName, inventorOf);// goodcreateHero( firstName, lastName, inventorOf,);// good (note that a comma must not appear after a &quot;rest&quot; element)createHero( firstName, lastName, inventorOf, ...heroArgs); Semicolons 21.1 Yup. eslint: semi Why? When JavaScript encounters a line break without a semicolon, it uses a set of rules called Automatic Semicolon Insertion to determine whether or not it should regard that line break as the end of a statement, and (as the name implies) place a semicolon into your code before the line break if it thinks so. ASI contains a few eccentric behaviors, though, and your code will break if JavaScript misinterprets your line break. These rules will become more complicated as new features become a part of JavaScript. Explicitly terminating your statements and configuring your linter to catch missing semicolons will help prevent you from encountering issues. 123456789101112131415161718192021222324252627282930313233343536// bad - raises exceptionconst luke = {}const leia = {}[luke, leia].forEach((jedi) =&gt; jedi.father = 'vader')// bad - raises exceptionconst reaction = &quot;No! That’s impossible!&quot;(async function meanwhileOnTheFalcon() { // handle `leia`, `lando`, `chewie`, `r2`, `c3p0` // ...}())// bad - returns `undefined` instead of the value on the next line - always happens when `return` is on a line by itself because of ASI!function foo() { return 'search your feelings, you know it to be foo'}// goodconst luke = {};const leia = {};[luke, leia].forEach((jedi) =&gt; { jedi.father = 'vader';});// goodconst reaction = &quot;No! That’s impossible!&quot;;(async function meanwhileOnTheFalcon() { // handle `leia`, `lando`, `chewie`, `r2`, `c3p0` // ...}());// goodfunction foo() { return 'search your feelings, you know it to be foo';} Read more. Type Casting &amp; Coercion 22.1 Perform type coercion at the beginning of the statement. 22.2 Strings: eslint: no-new-wrappers 12345678910111213// =&gt; this.reviewScore = 9;// badconst totalScore = new String(this.reviewScore); // typeof totalScore is &quot;object&quot; not &quot;string&quot;// badconst totalScore = this.reviewScore + ''; // invokes this.reviewScore.valueOf()// badconst totalScore = this.reviewScore.toString(); // isn’t guaranteed to return a string// goodconst totalScore = String(this.reviewScore); 22.3 Numbers: Use Number for type casting and parseInt always with a radix for parsing strings. eslint: radix no-new-wrappers Why? The parseInt function produces an integer value dictated by interpretation of the contents of the string argument according to the specified radix. Leading whitespace in string is ignored. If radix is undefined or 0, it is assumed to be 10 except when the number begins with the character pairs 0x or 0X, in which case a radix of 16 is assumed. This differs from ECMAScript 3, which merely discouraged (but allowed) octal interpretation. Many implementations have not adopted this behavior as of 2013. And, because older browsers must be supported, always specify a radix. 12345678910111213141516171819const inputValue = '4';// badconst val = new Number(inputValue);// badconst val = +inputValue;// badconst val = inputValue &gt;&gt; 0;// badconst val = parseInt(inputValue);// goodconst val = Number(inputValue);// goodconst val = parseInt(inputValue, 10); 22.4 If for whatever reason you are doing something wild and parseInt is your bottleneck and need to use Bitshift for performance reasons, leave a comment explaining why and what you’re doing. 1234567// good/** * parseInt was the reason my code was slow. * Bitshifting the String to coerce it to a * Number made it a lot faster. */const val = inputValue &gt;&gt; 0; 22.5 Note: Be careful when using bitshift operations. Numbers are represented as 64-bit values, but bitshift operations always return a 32-bit integer (source). Bitshift can lead to unexpected behavior for integer values larger than 32 bits. Discussion. Largest signed 32-bit Int is 2,147,483,647: 1232147483647 &gt;&gt; 0; // =&gt; 21474836472147483648 &gt;&gt; 0; // =&gt; -21474836482147483649 &gt;&gt; 0; // =&gt; -2147483647 22.6 Booleans: eslint: no-new-wrappers 12345678910const age = 0;// badconst hasAge = new Boolean(age);// goodconst hasAge = Boolean(age);// bestconst hasAge = !!age; Naming Conventions 23.1 Avoid single letter names. Be descriptive with your naming. eslint: id-length 123456789// badfunction q() { // ...}// goodfunction query() { // ...} 23.2 Use camelCase when naming objects, functions, and instances. eslint: camelcase 12345678// badconst OBJEcttsssss = {};const this_is_my_object = {};function c() {}// goodconst thisIsMyObject = {};function thisIsMyFunction() {} 23.3 Use PascalCase only when naming constructors or classes. eslint: new-cap 12345678910111213141516171819// badfunction user(options) { this.name = options.name;}const bad = new user({ name: 'nope',});// goodclass User { constructor(options) { this.name = options.name; }}const good = new User({ name: 'yup',}); 23.4 Do not use trailing or leading underscores. eslint: no-underscore-dangle Why? JavaScript does not have the concept of privacy in terms of properties or methods. Although a leading underscore is a common convention to mean “private”, in fact, these properties are fully public, and as such, are part of your public API contract. This convention might lead developers to wrongly think that a change won’t count as breaking, or that tests aren’t needed. tl;dr: if you want something to be “private”, it must not be observably present. 123456789101112// badthis.__firstName__ = 'Panda';this.firstName_ = 'Panda';this._firstName = 'Panda';// goodthis.firstName = 'Panda';// good, in environments where WeakMaps are available// see https://kangax.github.io/compat-table/es6/#test-WeakMapconst firstNames = new WeakMap();firstNames.set(this, 'Panda'); 23.5 Don’t save references to this. Use arrow functions or Function#bind. 12345678910111213141516171819202122// badfunction foo() { const self = this; return function () { console.log(self); };}// badfunction foo() { const that = this; return function () { console.log(that); };}// goodfunction foo() { return () =&gt; { console.log(this); };} 23.6 A base filename should exactly match the name of its default export. 123456789101112131415161718192021222324252627282930// file 1 contentsclass CheckBox { // ...}export default CheckBox;// file 2 contentsexport default function fortyTwo() { return 42; }// file 3 contentsexport default function insideDirectory() {}// in some other file// badimport CheckBox from './checkBox'; // PascalCase import/export, camelCase filenameimport FortyTwo from './FortyTwo'; // PascalCase import/filename, camelCase exportimport InsideDirectory from './InsideDirectory'; // PascalCase import/filename, camelCase export// badimport CheckBox from './check_box'; // PascalCase import/export, snake_case filenameimport forty_two from './forty_two'; // snake_case import/filename, camelCase exportimport inside_directory from './inside_directory'; // snake_case import, camelCase exportimport index from './inside_directory/index'; // requiring the index file explicitlyimport insideDirectory from './insideDirectory/index'; // requiring the index file explicitly// goodimport CheckBox from './CheckBox'; // PascalCase export/import/filenameimport fortyTwo from './fortyTwo'; // camelCase export/import/filenameimport insideDirectory from './insideDirectory'; // camelCase export/import/directory name/implicit &quot;index&quot;// ^ supports both insideDirectory.js and insideDirectory/index.js 23.7 Use camelCase when you export-default a function. Your filename should be identical to your function’s name. 12345function makeStyleGuide() { // ...}export default makeStyleGuide; 23.8 Use PascalCase when you export a constructor / class / singleton / function library / bare object. 123456const AirbnbStyleGuide = { es6: { },};export default AirbnbStyleGuide; 23.9 Acronyms and initialisms should always be all uppercased, or all lowercased. Why? Names are for readability, not to appease a computer algorithm. 12345678910111213141516171819202122232425262728// badimport SmsContainer from './containers/SmsContainer';// badconst HttpRequests = [ // ...];// goodimport SMSContainer from './containers/SMSContainer';// goodconst HTTPRequests = [ // ...];// also goodconst httpRequests = [ // ...];// bestimport TextMessageContainer from './containers/TextMessageContainer';// bestconst requests = [ // ...]; 23.10 You may optionally uppercase a constant only if it (1) is exported, (2) is a const (it can not be reassigned), and (3) the programmer can trust it (and its nested properties) to never change. Why? This is an additional tool to assist in situations where the programmer would be unsure if a variable might ever change. UPPERCASE_VARIABLES are letting the programmer know that they can trust the variable (and its properties) not to change.* What about all const variables? - This is unnecessary, so uppercasing should not be used for constants within a file. It should be used for exported constants however. What about exported objects? - Uppercase at the top level of export (e.g. EXPORTED_OBJECT.key) and maintain that all nested properties do not change. 12345678910111213141516171819202122232425262728// badconst PRIVATE_VARIABLE = 'should not be unnecessarily uppercased within a file';// badexport const THING_TO_BE_CHANGED = 'should obviously not be uppercased';// badexport let REASSIGNABLE_VARIABLE = 'do not use let with uppercase variables';// ---// allowed but does not supply semantic valueexport const apiKey = 'SOMEKEY';// better in most casesexport const API_KEY = 'SOMEKEY';// ---// bad - unnecessarily uppercases key while adding no semantic valueexport const MAPPING = { KEY: 'value'};// goodexport const MAPPING = { key: 'value'}; Accessors 24.1 Accessor functions for properties are not required. 24.2 Do not use JavaScript getters/setters as they cause unexpected side effects and are harder to test, maintain, and reason about. Instead, if you do make accessor functions, use getVal() and setVal('hello'). 123456789101112131415161718192021// badclass Dragon { get age() { // ... } set age(value) { // ... }}// goodclass Dragon { getAge() { // ... } setAge(value) { // ... }} 24.3 If the property/method is a boolean, use isVal() or hasVal(). 123456789// badif (!dragon.age()) { return false;}// goodif (!dragon.hasAge()) { return false;} 24.4 It’s okay to create get() and set() functions, but be consistent. 1234567891011121314class Jedi { constructor(options = {}) { const lightsaber = options.lightsaber || 'blue'; this.set('lightsaber', lightsaber); } set(key, val) { this[key] = val; } get(key) { return this[key]; }} Events 25.1 When attaching data payloads to events (whether DOM events or something more proprietary like Backbone events), pass an object literal (also known as a “hash”) instead of a raw value. This allows a subsequent contributor to add more data to the event payload without finding and updating every handler for the event. For example, instead of: 12345678// bad$(this).trigger('listingUpdated', listing.id);// ...$(this).on('listingUpdated', (e, listingID) =&gt; { // do something with listingID}); prefer: 12345678// good$(this).trigger('listingUpdated', { listingID: listing.id });// ...$(this).on('listingUpdated', (e, data) =&gt; { // do something with data.listingID}); jQuery 26.1 Prefix jQuery object variables with a $. 12345678// badconst sidebar = $('.sidebar');// goodconst $sidebar = $('.sidebar');// goodconst $sidebarBtn = $('.sidebar-btn'); 26.2 Cache jQuery lookups. 12345678910111213141516171819202122// badfunction setSidebar() { $('.sidebar').hide(); // ... $('.sidebar').css({ 'background-color': 'pink', });}// goodfunction setSidebar() { const $sidebar = $('.sidebar'); $sidebar.hide(); // ... $sidebar.css({ 'background-color': 'pink', });} 26.3 For DOM queries use Cascading $('.sidebar ul') or parent &gt; child $('.sidebar &gt; ul'). jsPerf 26.4 Use find with scoped jQuery object queries. 1234567891011121314// bad$('ul', '.sidebar').hide();// bad$('.sidebar').find('ul').hide();// good$('.sidebar ul').hide();// good$('.sidebar &gt; ul').hide();// good$sidebar.find('ul').hide(); ECMAScript 5 Compatibility 27.1 Refer to Kangax’s ES5 compatibility table. ECMAScript 6+ (ES 2015+) Styles 28.1 This is a collection of links to the various ES6+ features. Arrow Functions Classes Object Shorthand Object Concise Object Computed Properties Template Strings Destructuring Default Parameters Rest Array Spreads Let and Const Exponentiation Operator Iterators and Generators Modules 28.2 Do not use TC39 proposals that have not reached stage 3. Why? They are not finalized, and they are subject to change or to be withdrawn entirely. We want to use JavaScript, and proposals are not JavaScript yet. Standard LibraryThe Standard Librarycontains utilities that are functionally broken but remain for legacy reasons. 29.1 Use Number.isNaN instead of global isNaN.eslint: no-restricted-globals Why? The global isNaN coerces non-numbers to numbers, returning true for anything that coerces to NaN.If this behavior is desired, make it explicit. 1234567// badisNaN('1.2'); // falseisNaN('1.2.3'); // true// goodNumber.isNaN('1.2.3'); // falseNumber.isNaN(Number('1.2.3')); // true 29.2 Use Number.isFinite instead of global isFinite.eslint: no-restricted-globals Why? The global isFinite coerces non-numbers to numbers, returning true for anything that coerces to a finite number.If this behavior is desired, make it explicit. 123456// badisFinite('2e3'); // true// goodNumber.isFinite('2e3'); // falseNumber.isFinite(parseInt('2e3', 10)); // true Testing 30.1 Yup. 123function foo() { return true;} #javascript","link":"/2021/04/07/javascript/a88d33c225/"}],"tags":[{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"interview","slug":"interview","link":"/tags/interview/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"closure","slug":"closure","link":"/tags/closure/"},{"name":"other","slug":"other","link":"/tags/other/"},{"name":"question","slug":"question","link":"/tags/question/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"vue","slug":"vue","link":"/tags/vue/"}],"categories":[{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"css","slug":"css","link":"/categories/css/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"interview","slug":"interview","link":"/categories/interview/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"other","slug":"other","link":"/categories/other/"},{"name":"question","slug":"question","link":"/categories/question/"},{"name":"typescript","slug":"typescript","link":"/categories/typescript/"},{"name":"vue","slug":"vue","link":"/categories/vue/"}]}
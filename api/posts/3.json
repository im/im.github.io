{"total":64,"pageSize":10,"pageCount":7,"data":[{"title":" JavaScript里的循环方法：forEach，for-in，for-of","slug":"javascript/cbbeb436fb","date":"2021-04-03T02:02:28.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/cbbeb436fb.json","excerpt":"<p>JavaScript诞生已经有20多年了，我们一直使用的用来循环一个数组的方法是这样的：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> index = <span class=\"hljs-number\">0</span>; index &lt; myArray.length; index++) &#123;\n  <span class=\"hljs-built_in\">console</span>.log(myArray[index]);\n&#125;</code></pre>\n\n<p>自从JavaScript5起，我们开始可以使用内置的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\">forEach</a> 方法：</p>\n<pre><code class=\"hljs js\">myArray.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;\n  <span class=\"hljs-built_in\">console</span>.log(value);\n&#125;);</code></pre>\n\n<p>写法简单了许多，但也有短处：你不能中断循环(使用break语句或使用return语句。<br>JavaScript里还有一种循环方法：for–in。<br>for-in 循环实际是为循环<strong>enumerable</strong>对象而设计的：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> obj = &#123;<span class=\"hljs-attr\">a</span>:<span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>:<span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">c</span>:<span class=\"hljs-number\">3</span>&#125;;\n    \n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> prop <span class=\"hljs-keyword\">in</span> obj) &#123;\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;obj.&quot;</span> + prop + <span class=\"hljs-string\">&quot; = &quot;</span> + obj[prop]);\n&#125;\n\n<span class=\"hljs-comment\">// 输出:</span>\n<span class=\"hljs-comment\">// &quot;obj.a = 1&quot;</span>\n<span class=\"hljs-comment\">// &quot;obj.b = 2&quot;</span>\n<span class=\"hljs-comment\">// &quot;obj.c = 3&quot;</span></code></pre>\n\n<p>你也可以用它来循环一个数组：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> index <span class=\"hljs-keyword\">in</span> myArray) &#123;    <span class=\"hljs-comment\">// 不推荐这样</span>\n  <span class=\"hljs-built_in\">console</span>.log(myArray[index]);\n&#125;</code></pre>\n\n<p>不推荐用for-in来循环一个数组，因为，不像对象，数组的index跟普通的对象属性不一样，是重要的数值序列指标。<br>总之，for–in是用来循环带有字符串key的对象的方法。</p>","keywords":null,"cover":null,"content":null,"text":"JavaScript诞生已经有20多年了，我们一直使用的用来循环一个数组的方法是这样的：for (var index = 0; index &lt; myArray.length; index++) &#123;  console.log(myArray[index]);&#12","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" nodejs 搭建本地服务器 展示文件夹","slug":"javascript/51fcfc72c9","date":"2021-04-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/51fcfc72c9.json","excerpt":"","keywords":null,"cover":null,"content":"<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;express&#x27;</span>)\n<span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;http&#x27;</span>)\n<span class=\"hljs-keyword\">const</span> app = express()\n<span class=\"hljs-keyword\">const</span> port = <span class=\"hljs-number\">80</span>\n<span class=\"hljs-keyword\">var</span> serveIndex = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;serve-index&#x27;</span>)\n\napp.use(express.static(<span class=\"hljs-string\">&#x27;../&#x27;</span>))\napp.use(serveIndex(<span class=\"hljs-string\">&#x27;../&#x27;</span>))\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getIPAdress</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">let</span> interfaces = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;os&#x27;</span>).networkInterfaces()\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> devName <span class=\"hljs-keyword\">in</span> interfaces) &#123;\n        <span class=\"hljs-keyword\">var</span> iface = interfaces[devName]\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; iface.length; i++) &#123;\n            <span class=\"hljs-keyword\">let</span> alias = iface[i]\n            <span class=\"hljs-keyword\">if</span> (\n                alias.family === <span class=\"hljs-string\">&#x27;IPv4&#x27;</span> &amp;&amp;\n                alias.address !== <span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span> &amp;&amp;\n                !alias.internal\n            ) &#123;\n                <span class=\"hljs-comment\">// console.log(alias.address);</span>\n\n                <span class=\"hljs-keyword\">return</span> alias.address\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n<span class=\"hljs-keyword\">var</span> server = http.createServer(app)\n\nserver.listen(port, <span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Example app listening at http://<span class=\"hljs-subst\">$&#123;getIPAdress()&#125;</span>:<span class=\"hljs-subst\">$&#123;port&#125;</span>`</span>)\n&#125;)</code></pre>\n\n","text":"const express = require(&#x27;express&#x27;)const http = require(&#x27;http&#x27;)const app = express()const port = 80var serveIndex = requi","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"},{"name":"nodejs","slug":"nodejs","count":2,"path":"api/tags/nodejs.json"}]},{"title":" 字面量类型","slug":"typescript/8f287486e1","date":"2021-04-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/typescript/8f287486e1.json","excerpt":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>一个字面量是一个集体类型中更为具体的一种子类型。意思是：<code>&quot;Hello World&quot;</code> 是一个 <code>string</code>，但是一个 <code>string</code> 不是类型系统中的 <code>&quot;Hello World&quot;</code>。</p>\n<p>目前 TypeScript 中有三种可用的字面量类型集合，分别是：字符串、数字和布尔值。通过使用字面量类型，你可以规定一个字符串、数字或布尔值必须含有的确定值。</p>","keywords":null,"cover":null,"content":null,"text":"介绍一个字面量是一个集体类型中更为具体的一种子类型。意思是：&quot;Hello World&quot; 是一个 string，但是一个 string 不是类型系统中的 &quot;Hello World&quot;。目前 TypeScript 中有三种可用的字面量类型集合，分","link":"","raw":null,"photos":[],"categories":[{"name":"typescript","slug":"typescript","count":8,"path":"api/categories/typescript.json"}],"tags":[{"name":"typescript","slug":"typescript","count":8,"path":"api/tags/typescript.json"}]},{"title":" 你不知道的浏览器渲染原理","slug":"javascript/419340c52c","date":"2021-03-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/419340c52c.json","excerpt":"<p>在我们面试过程中，面试官经常会问到这么一个问题，那就是从在浏览器地址栏中输入URL到页面显示，浏览器到底发生了什么？这个问题看起来是老生常谈，但是这个问题回答的好坏，确实可以很好的反映出面试者知识的广度和深度。<br>本文从浏览器角度来告诉你，URL后输入后按回车，浏览器内部究竟发生了什么，读完本文后，你将了解到：</p>\n<ul>\n<li><p>浏览器内有哪些进程，这些进程都有些什么作用</p>\n</li>\n<li><p>浏览器地址输入URL后，内部的进程、线程都做了哪些事</p>\n</li>\n<li><p>我们与浏览器交互时，内部进程是怎么处理这些交互事件的</p>\n</li>\n</ul>","keywords":null,"cover":"/images/_640.jpeg","content":null,"text":"在我们面试过程中，面试官经常会问到这么一个问题，那就是从在浏览器地址栏中输入URL到页面显示，浏览器到底发生了什么？这个问题看起来是老生常谈，但是这个问题回答的好坏，确实可以很好的反映出面试者知识的广度和深度。<br>本文从浏览器角度来告诉你，URL后输入后按回车，浏览器内部究竟","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" 揭开在线协作的神秘面纱 – OT 算法","slug":"javascript/9e1f204749","date":"2021-03-01T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/9e1f204749.json","excerpt":"<p>相信大家或多或少都有使用过在线文档，国内的像我们在做的 <a href=\"http://https//docs.qq.com/desktop/\">腾讯文档</a> 还有其他家的很多类似产品。今天主要为大家揭开在线协作的神秘面纱，那就是 OT 算法。</p>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>在线文档，抽象一下，这些产品的模式都是富文本编辑器+后台，富文本编辑器产生内容，展示内容，然后后台负责保存。<br>富文本编辑器现在业界已经有很多成熟的产品，像 <a href=\"https://codemirror.net/\">codeMirror</a> ，这一块本身也是很复杂的一块，也不是咱们这次关注的重点方向。<br>不知道大家平常在用这些产品的时候有没有思考过一个问题，在线文档编辑的时候产生冲突怎么办？</p>","keywords":null,"cover":"/images/0973dffd-399c-48e9-8fcf-77ff3a6809e6-272x300.png","content":null,"text":"相信大家或多或少都有使用过在线文档，国内的像我们在做的 腾讯文档 还有其他家的很多类似产品。今天主要为大家揭开在线协作的神秘面纱，那就是 OT 算法。背景在线文档，抽象一下，这些产品的模式都是富文本编辑器+后台，富文本编辑器产生内容，展示内容，然后后台负责保存。<br>富文本编辑","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" 函数柯里化","slug":"javascript/9b990bb119","date":"2021-02-27T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/9b990bb119.json","excerpt":"<blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96\">柯里化 - 维基百科，自由的百科全书</a><br>把接受多个<code>参数</code>的<code>函数</code>变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。  </p>\n</blockquote>\n<h2 id=\"柯里化有3个常见作用：\"><a href=\"#柯里化有3个常见作用：\" class=\"headerlink\" title=\"柯里化有3个常见作用：\"></a>柯里化有3个常见作用：</h2><ol>\n<li>参数复用</li>\n<li>提前确定</li>\n<li>延迟计算/运行</li>\n</ol>\n<h2 id=\"基本实现\"><a href=\"#基本实现\" class=\"headerlink\" title=\"基本实现\"></a>基本实现</h2><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a</span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">b</span>) </span>&#123;\n        <span class=\"hljs-keyword\">return</span> a * a + b * b;\n    &#125;\n&#125;</code></pre>\n\n<p>调用上述函数：<code>(foo(3))(4)</code>，或直接<code>foo(3)(4)</code></p>","keywords":null,"cover":null,"content":null,"text":"柯里化 - 维基百科，自由的百科全书<br>把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。  柯里化有3个常见作用：参数复用提前确定延迟计算/运行基本实现var foo = function(a) &#","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" 数组扁平化","slug":"javascript/fa59b4bb32","date":"2021-02-03T05:36:57.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/fa59b4bb32.json","excerpt":"<h1 id=\"Array-prototype-flat\"><a href=\"#Array-prototype-flat\" class=\"headerlink\" title=\"Array.prototype.flat()\"></a>Array.prototype.flat()</h1><p><strong>flat()</strong> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> arr1 = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]];\n\n<span class=\"hljs-built_in\">console</span>.log(arr1.flat());\n<span class=\"hljs-comment\">// expected output: [0, 1, 2, 3, 4]</span>\n\n<span class=\"hljs-keyword\">const</span> arr2 = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, [[[<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]]]];\n\n<span class=\"hljs-built_in\">console</span>.log(arr2.flat(<span class=\"hljs-number\">2</span>));\n<span class=\"hljs-comment\">// expected output: [0, 1, 2, [3, 4]]</span>\n</code></pre>","keywords":null,"cover":null,"content":null,"text":"Array.prototype.flat()flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。const arr1 = [0, 1, 2, [3, 4]];console.log(arr1.flat());// exp","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" 你是哪种程序员？","slug":"other/a4323ac2b0","date":"2021-02-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/other/a4323ac2b0.json","excerpt":"","keywords":null,"cover":"/images/__640.jpeg","content":"<p><strong>1.对待需求的态度</strong></p>\n<p><strong>优秀程序员</strong> ：在有需求与任务时，会不断的询问需求与任务，并且多次确认想要的结果，再动手写代码。</p>\n<p><strong>一般程序员</strong> ：接到任务就闷头写代码，反<br>正做错了也是你们要求的，不是我的锅。</p>\n<p><img src=\"/images/__640.jpeg\"></p>\n<p><strong>2.编码习惯</strong></p>\n<p><strong>优秀程序员</strong> ：他的代码读起来是赏心悦目的，若遇到难理解的实现点时，他也会写下清晰的注释来帮助后来人理解。</p>\n<p><strong>一般程序员</strong> ：我有我的代码风格，我看得懂就行了。几个月后我也看不懂了，那就重写一遍吧。</p>\n<p><img src=\"/images/___640.jpeg\"></p>\n<p><strong>3. 善于学习</strong></p>\n<p><strong>优秀程序员</strong> ：遇到没接触过的技术时，他会主动搜索资料去学习钻研，并以此为乐趣。</p>\n<p><strong>一般程序员</strong> ：疯狂地找插件，类库和框架，常常做代码搬运工，安慰自己不要造轮子。</p>\n<p><img src=\"/images/____640.jpeg\"></p>\n<p><strong>4. 对工作精益求精</strong></p>\n<p><strong>优秀程序员</strong> ：会抽时间review自己的代码，并思考如何提高性能。</p>\n<p><strong>一般程序员</strong> ：只喜欢开发新项目，不喜欢维护旧项目，万一搞崩了呢？</p>\n<p><img src=\"/images/_____640.jpeg\"></p>\n<p><strong>5. 有钻研精神</strong></p>\n<p><strong>优秀程序员</strong> ：遇到问题，会考虑独立寻求解决办法，提升自己处理问题的能力。</p>\n<p><strong>一般程序员</strong> ：喜欢把问题交给别人，把代码发给被人，让别人帮他找问题。</p>\n<p><img src=\"/images/______640.jpeg\"></p>\n<p><strong>6. 良好的情绪管理</strong></p>\n<p><strong>优秀程序员</strong> ：理解需求是会不断变化的，不会把消极情绪表达出来，能控制好情绪，能跟产品经理和谐愉快沟通。</p>\n<p><strong>一般程序员</strong> ：因为需求反复修改就索性说这个代码实现不了。</p>\n<p><img src=\"/images/_______640.jpeg\"></p>\n<p><strong>7. 态度很谦虚</strong></p>\n<p><strong>优秀程序员</strong> ：对新的技术敏感度，保持学习的热情，而且为人很谦虚，不觉得自己有多牛。</p>\n<p><strong>一般程序员</strong> ：生怕别人不觉得他是大牛，到处瞎逼逼。</p>\n<p><img src=\"/images/________640.jpeg\"></p>\n","text":"1.对待需求的态度优秀程序员 ：在有需求与任务时，会不断的询问需求与任务，并且多次确认想要的结果，再动手写代码。一般程序员 ：接到任务就闷头写代码，反<br>正做错了也是你们要求的，不是我的锅。 [Figure] ","link":"","raw":null,"photos":[],"categories":[{"name":"other","slug":"other","count":4,"path":"api/categories/other.json"}],"tags":[{"name":"other","slug":"other","count":4,"path":"api/tags/other.json"}]},{"title":" 函数","slug":"typescript/64fffd4364","date":"2021-01-28T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/typescript/64fffd4364.json","excerpt":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>函数是JavaScript应用程序的基础。 它帮助你实现抽象层，模拟类，信息隐藏和模块。 在TypeScript里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义_行为_的地方。 TypeScript为JavaScript函数添加了额外的功能，让我们可以更容易地使用。</p>","keywords":null,"cover":null,"content":null,"text":"介绍函数是JavaScript应用程序的基础。 它帮助你实现抽象层，模拟类，信息隐藏和模块。 在TypeScript里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义_行为_的地方。 TypeScript为JavaScript函数添加了额外的功能，让我们可以更容易地使用。","link":"","raw":null,"photos":[],"categories":[{"name":"typescript","slug":"typescript","count":8,"path":"api/categories/typescript.json"}],"tags":[{"name":"typescript","slug":"typescript","count":8,"path":"api/tags/typescript.json"}]},{"title":" 实时协同编辑的实现","slug":"javascript/18a23f4c21","date":"2021-01-22T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/18a23f4c21.json","excerpt":"<p>在最近某个项目中打算使用协同编辑来解决冲突问题，因此抽空调研了现有的实现方案，结果发现要想做完美是很难的，但我们可以低成本地做到不错的效果，本文将介绍几种实现方法，大家在项目中如果有需要可以参考。</p>\n<h2 id=\"什么是实时协同编辑\"><a href=\"#什么是实时协同编辑\" class=\"headerlink\" title=\"什么是实时协同编辑\"></a>什么是实时协同编辑</h2><p>这里所说的实时协同编辑，是指多人同时编辑一个文档，最典型的例子是 Google Docs，你可以实时看到别人做出的修改，不用手动刷新页面。</p>\n<p>要实现实时编辑，我们需要解决两个技术点：实时通信问题、编辑冲突问题，其中实时通信问题比较好解决，可以使用 long pull 或 WebSocket，所以这里就不过多讨论了，重点将放在如何解决编辑冲突问题上。</p>\n<h2 id=\"可选方案\"><a href=\"#可选方案\" class=\"headerlink\" title=\"可选方案\"></a>可选方案</h2><p>接下来将从易至难的顺序来介绍几种可行的方案，分别是：「编辑锁」、「GNU diff-patch」、「Myer’s diff-patch」、「Operational Transformation」和「分布式 Operational Transformation」。</p>","keywords":null,"cover":"/images/merge.png","content":null,"text":"在最近某个项目中打算使用协同编辑来解决冲突问题，因此抽空调研了现有的实现方案，结果发现要想做完美是很难的，但我们可以低成本地做到不错的效果，本文将介绍几种实现方法，大家在项目中如果有需要可以参考。什么是实时协同编辑这里所说的实时协同编辑，是指多人同时编辑一个文档，最典型的例子是 ","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]}]}
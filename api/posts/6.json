{"total":64,"pageSize":10,"pageCount":7,"data":[{"title":" Object.assign 是浅拷贝还是深拷贝？实现深拷贝的方法有哪些？","slug":"javascript/f81ce9141d","date":"2019-06-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/f81ce9141d.json","excerpt":"<blockquote>\n<p>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。  </p>\n</blockquote>\n<ul>\n<li><p>如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。</p>\n</li>\n<li><p>Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。</p>\n</li>\n<li><p>String类型和 Symbol 类型的属性都会被拷贝。</p>\n</li>\n<li><p>在出现错误的情况下，例如，如果属性不可写，会引发TypeError，如果在引发错误之前添加了任何属性，则可以更改target对象。</p>\n</li>\n<li><p>Object.assign 不会在那些source对象值为 <code>null</code> 或 <code>undefined</code> 的时候抛出错误。</p>\n</li>\n<li><p>针对 <strong>深拷贝</strong> ，需要使用其他办法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。也就是说，如果对象的属性值为简单类型（如string， number），通过Object.assign({},srcObj);得到的新对象为 <code>深拷贝</code> ；如果属性值为对象或其它引用类型，那对于这个对象而言其实是 <code>浅拷贝</code> 的。</p>","keywords":null,"cover":null,"content":null,"text":"Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。  如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。Object.assign 方法只会拷贝源对象自身","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" Mac 设置环境变量 path 的几种方法","slug":"other/4a3b3f2e02","date":"2019-06-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/other/4a3b3f2e02.json","excerpt":"<p>Mac系统的环境变量，加载顺序为：</p>\n<ol>\n<li>系统<ul>\n<li>/etc/profile</li>\n<li>/etc/paths</li>\n</ul>\n</li>\n</ol>\n<p><code>/etc/profile</code> 和 <code>/etc/paths</code> 是系统级别的，系统启动就会加载</p>\n<ol start=\"2\">\n<li>用户<ul>\n<li>~/.bash_profile </li>\n<li>~/.bash_login </li>\n<li>~/.profile </li>\n<li>~/.bashrc</li>\n</ul>\n</li>\n</ol>\n<p>按照从前往后的顺序读取，如果 <code>~/.bash_profile</code> 文件存在，则后面的几个文件就会被忽略不读了，如果 <code>~/.bash_profile</code> 文件不存在，才会以此类推读取后面的文件。<code>~/.bashrc</code> 没有上述规则，它是 <code>bash shell</code> 打开的时候载入的</p>\n<p>如果没特殊说明,设置PATH的语法都为：</p>\n<pre><code class=\"hljs elixir\">export PATH=<span class=\"hljs-variable\">$PATH</span><span class=\"hljs-symbol\">:&lt;PATH</span> <span class=\"hljs-number\">1</span>&gt;<span class=\"hljs-symbol\">:&lt;PATH</span> <span class=\"hljs-number\">2</span>&gt;<span class=\"hljs-symbol\">:&lt;PATH</span> <span class=\"hljs-number\">3</span>&gt;<span class=\"hljs-symbol\">:------</span><span class=\"hljs-symbol\">:&lt;PATH</span> N&gt;</code></pre>","keywords":null,"cover":null,"content":null,"text":"Mac系统的环境变量，加载顺序为：系统/etc/profile/etc/paths/etc/profile 和 /etc/paths 是系统级别的，系统启动就会加载用户~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc按照从前往后","link":"","raw":null,"photos":[],"categories":[{"name":"other","slug":"other","count":4,"path":"api/categories/other.json"}],"tags":[{"name":"other","slug":"other","count":4,"path":"api/tags/other.json"}]},{"title":" 占位图","slug":"other/5051f46252","date":"2019-06-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/other/5051f46252.json","excerpt":"","keywords":null,"cover":"/images/?random~","content":"<p>写页面的有时候需要一些临时的占位符图片，下面是常用的几种免费占位图片网站</p>\n<h2 id=\"picsum-photos-https-picsum-photos\"><a href=\"#picsum-photos-https-picsum-photos\" class=\"headerlink\" title=\"picsum.photos (https://picsum.photos/)\"></a>picsum.photos (<a href=\"https://picsum.photos/\">https://picsum.photos/</a>)</h2><p><code>支持https, 而且图片特别多, 随机图片, 模糊图片, 宽高, 唯一的缺点就是感觉请求有点慢</code></p>\n<table>\n<thead>\n<tr>\n<th>图片地址</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://picsum.photos/list\">https://picsum.photos/list</a></td>\n<td align=\"left\">查看所有图片</td>\n</tr>\n<tr>\n<td><a href=\"https://picsum.photos/200\">https://picsum.photos/200</a></td>\n<td align=\"left\">正方形图片 只想要一个值</td>\n</tr>\n<tr>\n<td><a href=\"https://picsum.photos/200/300\">https://picsum.photos/200/300</a></td>\n<td align=\"left\">设置宽高</td>\n</tr>\n<tr>\n<td><a href=\"https://picsum.photos/500/300/?random\">https://picsum.photos/500/300/?random</a></td>\n<td align=\"left\">随机获取图片</td>\n</tr>\n<tr>\n<td><a href=\"https://picsum.photos/id/0/200/300\">https://picsum.photos/id/0/200/300</a></td>\n<td align=\"left\">指定特定图片</td>\n</tr>\n<tr>\n<td><a href=\"https://picsum.photos/g/200/300\">https://picsum.photos/g/200/300</a></td>\n<td align=\"left\">将图片变成灰色 只需要加一个 /g/</td>\n</tr>\n<tr>\n<td><a href=\"https://picsum.photos/200/300/?blur\">https://picsum.photos/200/300/?blur</a></td>\n<td align=\"left\">模糊图片</td>\n</tr>\n</tbody></table>\n<pre><code class=\"hljs markdown\">![](/images/?random~)</code></pre>\n\n<p><img src=\"/images/?random~\"></p>\n<h2 id=\"fakeimg-pl-https-fakeimg-pl\"><a href=\"#fakeimg-pl-https-fakeimg-pl\" class=\"headerlink\" title=\"fakeimg.pl(https://fakeimg.pl)\"></a>fakeimg.pl(<a href=\"https://fakeimg.pl/\">https://fakeimg.pl</a>)</h2><p><code>如果你只需要使用文字，这个就特别好用了， 支持背景颜色，文字颜色，文字样式， 他的访问速度还很快</code></p>\n<table>\n<thead>\n<tr>\n<th>图片地址</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://fakeimg.pl/400x300\">https://fakeimg.pl/400x300</a></td>\n<td align=\"left\">设置宽高</td>\n</tr>\n<tr>\n<td><a href=\"https://fakeimg.pl/400x300/ba8f6c/FFFFFF/\">https://fakeimg.pl/400x300/ba8f6c/FFFFFF/</a></td>\n<td align=\"left\">设置背景颜色 字体颜色</td>\n</tr>\n<tr>\n<td><a href=\"https://fakeimg.pl/400x300/ba8f6c/FFFFFF/?text=text\">https://fakeimg.pl/400x300/ba8f6c/FFFFFF/?text=text</a></td>\n<td align=\"left\">设置显示的文字</td>\n</tr>\n<tr>\n<td><a href=\"https://fakeimg.pl/400x300/ba8f6c/FFFFFF/?text=RegExp&amp;font=noto\">https://fakeimg.pl/400x300/ba8f6c/FFFFFF/?text=RegExp&amp;font=noto</a></td>\n<td align=\"left\">设置字体样式 font=lobster</td>\n</tr>\n</tbody></table>\n<pre><code class=\"hljs markdown\">![](/images/?text=糖小米&amp;font=noto~)</code></pre>\n\n<p><img src=\"/images/?text=%E7%B3%96%E5%B0%8F%E7%B1%B3&font=noto~\"></p>\n","text":"写页面的有时候需要一些临时的占位符图片，下面是常用的几种免费占位图片网站picsum.photos (https://picsum.photos/)支持https, 而且图片特别多, 随机图片, 模糊图片, 宽高, 唯一的缺点就是感觉请求有点慢图片地址说明https://pics","link":"","raw":null,"photos":[],"categories":[{"name":"other","slug":"other","count":4,"path":"api/categories/other.json"}],"tags":[{"name":"other","slug":"other","count":4,"path":"api/tags/other.json"}]},{"title":" git rebase -i","slug":"git/516fccc759","date":"2019-05-12T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/git/516fccc759.json","excerpt":"<h2 id=\"变基时有六个命令可用：\"><a href=\"#变基时有六个命令可用：\" class=\"headerlink\" title=\"变基时有六个命令可用：\"></a>变基时有六个命令可用：</h2><ul>\n<li><p>pick<br>pick只是意味着包括提交。重新进行命令时，重新安排pick命令的顺序会更改提交的顺序。如果选择不包括提交，则应删除整行。</p>\n</li>\n<li><p>reword<br>该reword命令与相似pick，但是使用后，重新设置过程将暂停并为您提供更改提交消息的机会。提交所做的任何更改均不受影响。</p>\n</li>\n<li><p>edit<br>如果您选择edit提交，则将有机会修改提交，这意味着您可以完全添加或更改提交。您还可以进行更多提交，然后再继续进行变基。这使您可以将大型提交拆分为较小的提交，或者删除在提交中所做的错误更改。</p>\n</li>\n<li><p>squash<br>该命令使您可以将两个或多个提交合并为一个提交。提交被压缩到其上方的提交中。Git使您有机会编写描述这两个更改的新提交消息。</p>\n</li>\n<li><p>fixup<br>这类似于squash，但是要合并的提交已丢弃其消息。提交仅合并到其上方的提交中，并且较早提交的消息用于描述这两个更改。</p>\n</li>\n<li><p>exec<br>这使您可以对提交运行任意的Shell命令。</p>\n</li>\n</ul>","keywords":null,"cover":"/images/aHR0cHM6Ly9naXRlZS5jb20vcmVuc2hlbl8wNTIvbXlOb3RlLWltZy9yYXcvbWFzdGVyL2ltYWdlLzIwMjAwMzA4MTkzNTQxLTQzOTMucG5n.png","content":null,"text":"变基时有六个命令可用：pick<br>pick只是意味着包括提交。重新进行命令时，重新安排pick命令的顺序会更改提交的顺序。如果选择不包括提交，则应删除整行。reword<br>该reword命令与相似pick，但是使用后，重新设置过程将暂停并为您提供更改提交消息的机会。提交所","link":"","raw":null,"photos":[],"categories":[{"name":"git","slug":"git","count":6,"path":"api/categories/git.json"}],"tags":[{"name":"git","slug":"git","count":6,"path":"api/tags/git.json"}]},{"title":" JavaScript 实现前端下载图片","slug":"javascript/0eec0217cd","date":"2019-05-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/0eec0217cd.json","excerpt":"<h2 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h2><ul>\n<li>  将图片装换成 Data URLs</li>\n<li>  下载图片</li>\n</ul>\n<h4 id=\"Data-URLs\"><a href=\"#Data-URLs\" class=\"headerlink\" title=\"Data URLs\"></a>Data URLs</h4><blockquote>\n<p>Data URLs，即前缀为 data: 协议的的 URL，其允许内容创建者向文档中嵌入小文件。<br>Data URLs 由四个部分组成：前缀(data:)、指示数据类型的 MIME 类型、如果非文本则为可选的 base64 标记、数据本身：<br>data:[<mediatype>][;base64],<data><br>mediative 是个 MIME 类型的字符串，例如 “image/jpeg” 表示 JPEG 图像文件。如果被省略，则默认值为 text/plain;charset=US-ASCII<br>如果数据是文本类型，你可以直接将文本嵌入 (根据文档类型，使用合适的实体字符或转义字符)。如果是二进制数据，你可以将数据进行 base64 编码之后再进行嵌入。  </p>\n</blockquote>\n<p>详细请看 MDN 对 <a href=\"~https://developer.mozilla.org/zh-CN/docs/Web/HTTP/data_URIs~\">Data URLs</a> 的解释。</p>","keywords":null,"cover":null,"content":null,"text":"实现思路  将图片装换成 Data URLs  下载图片Data URLsData URLs，即前缀为 data: 协议的的 URL，其允许内容创建者向文档中嵌入小文件。<br>Data URLs 由四个部分组成：前缀(data:)、指示数据类型的 MIME 类型、如果非文本则为","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" JavaScript 内存泄漏教程","slug":"javascript/23d05c6dd2","date":"2019-04-29T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/23d05c6dd2.json","excerpt":"<p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。</p>\n<p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p>\n<p><img src=\"/images/bg2017041701-1.png\"><br>不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。</p>\n<p>有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。</p>\n<pre><code class=\"hljs c\"><span class=\"hljs-keyword\">char</span> * buffer;\nbuffer = (<span class=\"hljs-keyword\">char</span>*) <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">42</span>);\n\n<span class=\"hljs-comment\">// Do something with buffer</span>\n\n<span class=\"hljs-built_in\">free</span>(buffer);</code></pre>\n\n<p>上面是 C 语言代码， <code>malloc</code> 方法用来申请内存，使用完毕之后，必须自己用 <code>free</code> 方法释放内存。</p>\n<p>这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”（<strong>garbage collector</strong>）。</p>","keywords":null,"cover":"/images/bg2017041701-1.png","content":null,"text":"程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 [Figure] 下面以 WeakMap 为例，看看它是怎么","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" git submodule","slug":"git/38399f8bee","date":"2019-04-09T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/git/38399f8bee.json","excerpt":"<h3 id=\"添加\"><a href=\"#添加\" class=\"headerlink\" title=\"添加\"></a>添加</h3><pre><code class=\"hljs bash\">git submodule add -b [指定分支] [仓库地址] [路径]\n\nexample:\n\ngit submodule add -b icarus https://github.com/im/hexo-theme.git themes/icarus</code></pre>\n\n<p>命令执行完成，会在当前工程根路径下生成一个名为 <code>.gitmodules</code> 的文件，其中记录了子模块的信息。</p>\n<h3 id=\"gitmodules\"><a href=\"#gitmodules\" class=\"headerlink\" title=\".gitmodules\"></a>.gitmodules</h3><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[submodule &quot;themes/icarus&quot;]</span>\n    <span class=\"hljs-attr\">path</span> = themes/icarus\n    <span class=\"hljs-attr\">url</span> = https://github.com/im/hexo-theme.git\n    <span class=\"hljs-attr\">branch</span> = icarus</code></pre>","keywords":null,"cover":null,"content":null,"text":"添加git submodule add -b [指定分支] [仓库地址] [路径]example:git submodule add -b icarus https://github.com/im/hexo-theme.git themes/icarus命令执行完成，会在当前工程","link":"","raw":null,"photos":[],"categories":[{"name":"git","slug":"git","count":6,"path":"api/categories/git.json"}],"tags":[{"name":"git","slug":"git","count":6,"path":"api/tags/git.json"}]},{"title":" 基础类型","slug":"typescript/687b81d520","date":"2019-03-24T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/typescript/687b81d520.json","excerpt":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p>","keywords":null,"cover":null,"content":null,"text":"介绍为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。Boolean最基本的数据类型就是简单的true/false值，在JavaScrip","link":"","raw":null,"photos":[],"categories":[{"name":"typescript","slug":"typescript","count":8,"path":"api/categories/typescript.json"}],"tags":[{"name":"typescript","slug":"typescript","count":8,"path":"api/tags/typescript.json"}]},{"title":" git 修改远程仓库地址","slug":"git/c4b1781fcc","date":"2019-03-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/git/c4b1781fcc.json","excerpt":"<h2 id=\"命令直接修改\"><a href=\"#命令直接修改\" class=\"headerlink\" title=\"命令直接修改\"></a>命令直接修改</h2><pre><code class=\"hljs bash\">git remote set-url origin [url]</code></pre>\n\n<h2 id=\"先删后加\"><a href=\"#先删后加\" class=\"headerlink\" title=\"先删后加\"></a>先删后加</h2><pre><code class=\"hljs bash\">git remote rm origin\ngit remote add origin [url]</code></pre>","keywords":null,"cover":null,"content":null,"text":"命令直接修改git remote set-url origin [url]先删后加git remote rm origingit remote add origin [url]直接修改配置文件cd .gitvim config[core]    repositoryformatv","link":"","raw":null,"photos":[],"categories":[{"name":"git","slug":"git","count":6,"path":"api/categories/git.json"}],"tags":[{"name":"git","slug":"git","count":6,"path":"api/tags/git.json"}]},{"title":" JS - CommonJS、ES2015、AMD、CMD模块规范对比与介绍","slug":"javascript/465c78e370","date":"2019-03-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/465c78e370.json","excerpt":"<h3 id=\"CommonJS-基本介绍\"><a href=\"#CommonJS-基本介绍\" class=\"headerlink\" title=\"CommonJS 基本介绍\"></a>CommonJS 基本介绍</h3><ol>\n<li>CommonJS 是一种思想，它是为 JS 的表现来制定规范。由于 JS 没有模块系统、标准库较少、缺乏包管理工具，因此 CommonJS 应运而生。</li>\n<li>CommonJS 的目标是希望 JS 可以在任何地方运行，不只是浏览器中。只要我们的 JavaScript 是根据 CommonJS API 编写的，那么就可以在与 CommonJS 兼容的系统上运行。</li>\n<li>根据 CommonJS API 编写的 JavaScript 可以做下面这些事情：<ul>\n<li>编写服务端应用</li>\n<li>编写命令行工具</li>\n<li>编写基于 GUI 的桌面应用</li>\n</ul>\n</li>\n<li>CommonJS 规范有很多实现，最有名要数 NodeJS 了。</li>\n</ol>\n<h3 id=\"CommonJS-的模块规范\"><a href=\"#CommonJS-的模块规范\" class=\"headerlink\" title=\"CommonJS 的模块规范\"></a>CommonJS 的模块规范</h3><p>一个文件就是一个模块，拥有单独的作用域。普通方式定义的变量、函数、对象都属于该模块内。<br>    * 通过 require 来加载模块。<br>    * 通过 exports 和 modul.exports 来暴露模块中的内容。</p>","keywords":null,"cover":"/images/2017052214293263636.png","content":null,"text":"CommonJS 基本介绍CommonJS 是一种思想，它是为 JS 的表现来制定规范。由于 JS 没有模块系统、标准库较少、缺乏包管理工具，因此 CommonJS 应运而生。CommonJS 的目标是希望 JS 可以在任何地方运行，不只是浏览器中。只要我们的 JavaScrip","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]}]}
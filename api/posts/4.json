{"total":64,"pageSize":10,"pageCount":7,"data":[{"title":" 偏函数","slug":"javascript/31cb92dd1f","date":"2021-01-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/31cb92dd1f.json","excerpt":"<p>偏函数是 [[函数柯里化]]  运算的一种特定应用场景。简单描述，就是把一个函数的某些参数先固化，也就是设置默认值，返回一个新的函数，在新函数中继续接收剩余参数，这样调用这个新函数会更简单。</p>\n<p><strong>下面是一个类型检测函数，接收两个参数，第 1 个表示类型字符串，第 2 个表示检测的数据。</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> isType = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">type, obj</span>) </span>&#123;  <span class=\"hljs-comment\">//偏函数</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Object</span>.prototype.toString.call(obj) == <span class=\"hljs-string\">&#x27;[object &#x27;</span> + type + <span class=\"hljs-string\">&#x27;]&#x27;</span>;\n&#125;</code></pre>","keywords":null,"cover":null,"content":null,"text":"偏函数是 [[函数柯里化]]  运算的一种特定应用场景。简单描述，就是把一个函数的某些参数先固化，也就是设置默认值，返回一个新的函数，在新函数中继续接收剩余参数，这样调用这个新函数会更简单。下面是一个类型检测函数，接收两个参数，第 1 个表示类型字符串，第 2 个表示检测的数据。","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" JS事件循环（Event Loop）","slug":"javascript/ef320f6e2a","date":"2021-01-02T01:49:36.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/ef320f6e2a.json","excerpt":"<blockquote>\n<p>众所周知，JavaScript 是一门单线程语言，虽然在 html5 中提出了 Web-Worker ，但这并未改变 JavaScript 是单线程这一核心,，可是浏览器又能很好的处理异步请求，那么到底是为什么呢？  </p>\n</blockquote>\n<p><strong>浏览器执行线程</strong></p>\n<blockquote>\n<p>在解释事件循环之前首先先解释一下浏览器的执行线程：<br>浏览器是多进程的，浏览器每一个 tab 标签都代表一个独立的进程，其中浏览器渲染进程（浏览器内核）属于浏览器多进程中的一种，主要负责页面渲染，脚本执行，事件处理等<br>其包含的线程有：GUI 渲染线程（负责渲染页面，解析 HTML，CSS 构成 DOM 树）、JS 引擎线程、事件触发线程、定时器触发线程、http 请求线程等主要线程  </p>\n</blockquote>","keywords":null,"cover":"/images/v2-1337770fcc29d10325ee4eb127496fff_1440w.jpg","content":null,"text":"众所周知，JavaScript 是一门单线程语言，虽然在 html5 中提出了 Web-Worker ，但这并未改变 JavaScript 是单线程这一核心,，可是浏览器又能很好的处理异步请求，那么到底是为什么呢？  浏览器执行线程在解释事件循环之前首先先解释一下浏览器的执行线程","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" 1. 页面导入样式时，使用link和@import有什么区别？","slug":"interview/d9026b0618","date":"2020-12-16T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/interview/d9026b0618.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>  页面导入样式时，使用link和@import有什么区别？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>link 是HTML标签，@import 是 css 提供的。</li>\n<li>link 引入的样式页面加载时同时加载，@import 引入的样式需等页面加载完成后再加载。</li>\n<li>link 没有兼容性问题，@import 不兼容 ie5 以下。</li>\n<li>link 可以通过 js 操作 DOM 动态引入样式表改变样式，而 @import 不可以。</li>\n</ol>\n","text":"描述  页面导入样式时，使用link和@import有什么区别？解答link 是HTML标签，@import 是 css 提供的。link 引入的样式页面加载时同时加载，@import 引入的样式需等页面加载完成后再加载。link 没有兼容性问题，@import 不兼容 ie5 ","link":"","raw":null,"photos":[],"categories":[{"name":"interview","slug":"interview","count":9,"path":"api/categories/interview.json"}],"tags":[{"name":"interview","slug":"interview","count":9,"path":"api/tags/interview.json"},{"name":"everyday","slug":"everyday","count":7,"path":"api/tags/everyday.json"}]},{"title":" 3. 用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值","slug":"interview/362e778681","date":"2020-12-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/interview/362e778681.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>这是一道大题目，把考点拆成了4个小项；需要侯选人用递归算法实现（限制15行代码以内实现；限制时间10分钟内完成）： </p>\n<ul>\n<li>生成一个长度为5的空数组 <code>arr</code> 。 </li>\n<li>生成一个（2－32）之间的随机整数 <code>rand</code>。</li>\n<li>把随机数 <code>rand</code> 插入到数组 <code>arr</code> 内，如果数组arr内已存在与 <code>rand</code> 相同的数字，则重新生成随机数<code>rand</code>并插入到<code>arr</code>内[需要使用递归实现，不能使用 <code>for/while</code> 等循环] </li>\n<li>最终输出一个长度为5，且内容不重复的数组 <code>arr</code> 。</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(<span class=\"hljs-number\">5</span>);\n<span class=\"hljs-keyword\">const</span> randomNum = <span class=\"hljs-function\">() =&gt;</span> (<span class=\"hljs-built_in\">Math</span>.floor(<span class=\"hljs-built_in\">Math</span>.random() * <span class=\"hljs-number\">31</span> + <span class=\"hljs-number\">2</span>))\n<span class=\"hljs-keyword\">const</span> randomArr = <span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (n === <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> arr;\n    <span class=\"hljs-keyword\">const</span> num = randomNum();\n    <span class=\"hljs-keyword\">if</span> (arr.includes(num)) <span class=\"hljs-keyword\">return</span> randomArr(n)\n    arr[n -<span class=\"hljs-number\">1</span>] = num;\n    <span class=\"hljs-keyword\">return</span> randomArr(n - <span class=\"hljs-number\">1</span>)\n&#125;;\nrandomArr(arr.length)\n</code></pre>\n\n","text":"描述这是一道大题目，把考点拆成了4个小项；需要侯选人用递归算法实现（限制15行代码以内实现；限制时间10分钟内完成）： 生成一个长度为5的空数组 arr 。 生成一个（2－32）之间的随机整数 rand。把随机数 rand 插入到数组 arr 内，如果数组arr内已存在与 ran","link":"","raw":null,"photos":[],"categories":[{"name":"interview","slug":"interview","count":9,"path":"api/categories/interview.json"}],"tags":[{"name":"interview","slug":"interview","count":9,"path":"api/tags/interview.json"},{"name":"everyday","slug":"everyday","count":7,"path":"api/tags/everyday.json"}]},{"title":" 2. 圣杯布局和双飞翼布局的理解和区别，并用代码实现","slug":"interview/82674f606e","date":"2020-11-10T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/interview/82674f606e.json","excerpt":"<h2 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h2><p>圣杯布局和双飞翼布局都是为了解决两边定宽，中间自适应且优先渲染的布局需求，那么为了自适应且优先渲染，必须要把中间的 <code>dom</code> 放在最顶端，以保证主要内容能最先被浏览器解析</p>\n<h2 id=\"圣杯布局\"><a href=\"#圣杯布局\" class=\"headerlink\" title=\"圣杯布局\"></a>圣杯布局</h2><p>为了中间 <code>div</code> 内容不被遮挡，将中间 <code>div</code> 设置了左右 <code>padding-left</code> 和 <code>padding-right</code> 后，将左右两个 <code>div</code> 用相对布局 <code>position: relative</code> 并分别配合 <code>right</code> 和 <code>left</code> 属性，以便左右两栏 <code>div</code> 移动后不遮挡中间 <code>div</code></p>\n<h3 id=\"html\"><a href=\"#html\" class=\"headerlink\" title=\"html\"></a>html</h3><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;hd&quot;</span>&gt;</span>header<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;bd&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;middle&quot;</span>&gt;</span>middle<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;left&quot;</span>&gt;</span>left<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;right&quot;</span>&gt;</span>right<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;footer&quot;</span>&gt;</span>footer<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span></code></pre>","keywords":null,"cover":null,"content":null,"text":"理解圣杯布局和双飞翼布局都是为了解决两边定宽，中间自适应且优先渲染的布局需求，那么为了自适应且优先渲染，必须要把中间的 dom 放在最顶端，以保证主要内容能最先被浏览器解析圣杯布局为了中间 div 内容不被遮挡，将中间 div 设置了左右 padding-left 和 paddi","link":"","raw":null,"photos":[],"categories":[{"name":"interview","slug":"interview","count":9,"path":"api/categories/interview.json"}],"tags":[{"name":"interview","slug":"interview","count":9,"path":"api/tags/interview.json"},{"name":"everyday","slug":"everyday","count":7,"path":"api/tags/everyday.json"}]},{"title":" 4. html的元素有哪些（包含H5）？","slug":"interview/1d841137c9","date":"2020-09-14T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/interview/1d841137c9.json","excerpt":"<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>区分出行内元素、块级元素、空元素并在后面简要标注下作用</p>","keywords":null,"cover":null,"content":null,"text":"描述区分出行内元素、块级元素、空元素并在后面简要标注下作用行内元素abspanstrongiembuttoninputlabelbrtextareaselect块元素divph1-h6olullitabletbodytdtrtheaddldtddH5新增元素section  标签","link":"","raw":null,"photos":[],"categories":[{"name":"interview","slug":"interview","count":9,"path":"api/categories/interview.json"}],"tags":[{"name":"interview","slug":"interview","count":9,"path":"api/tags/interview.json"},{"name":"everyday","slug":"everyday","count":7,"path":"api/tags/everyday.json"}]},{"title":" 6 . 写一个方法去掉字符串中的空格","slug":"interview/8d5ea4ab3d","date":"2020-08-11T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/interview/8d5ea4ab3d.json","excerpt":"<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>写一个方法去掉字符串中的空格，要求传入不同的类型分别能去掉前、后、前后、中间的空格 </p>","keywords":null,"cover":null,"content":null,"text":"描述写一个方法去掉字符串中的空格，要求传入不同的类型分别能去掉前、后、前后、中间的空格 解答const str = &quot;  s t  r  &quot;;const POSITION = Object.freeze(&#123;    left: Symbol(),   ","link":"","raw":null,"photos":[],"categories":[{"name":"interview","slug":"interview","count":9,"path":"api/categories/interview.json"}],"tags":[{"name":"interview","slug":"interview","count":9,"path":"api/tags/interview.json"},{"name":"everyday","slug":"everyday","count":7,"path":"api/tags/everyday.json"}]},{"title":" 7. HTML全局属性(global attribute)有哪些（包含H5）？","slug":"interview/09a7ebb8b8","date":"2020-07-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/interview/09a7ebb8b8.json","excerpt":"","keywords":null,"cover":null,"content":"<p><code>accesskey</code>   设置快捷键<br><code>class</code>  为元素设置类标识<br><code>contenteditable</code>  指定元素内容是否可编辑<br><code>contextmenu</code>  自定义鼠标右键弹出上下文菜单内容（仅firefox支持）<br><code>data-*</code>  为元素增加自定义属性<br>dir：设置元素文本方向（默认ltr；rtl）<br><code>draggable</code>  设置元素是否可拖拽<br><code>dropzone</code>  设置元素拖放类型（copy|move|link,H5新属性，主流均不支持）<br><code>hidden</code>  规定元素仍未或不在相关<br><code>id</code>  元素id，文档内唯一<br><code>lang</code>  元素内容的语言<br><code>spellcheck</code>  是否启动拼写和语法检查<br><code>style</code>  行内css样式<br><code>tabindex</code>  设置元素可以获得焦点，通过tab导航<br><code>title</code>  规定元素有关的额外信息</p>\n<blockquote>\n<p>相关链接：<a href=\"~https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes~\">Global attributes</a>  </p>\n</blockquote>\n","text":"accesskey   设置快捷键<br>class  为元素设置类标识<br>contenteditable  指定元素内容是否可编辑<br>contextmenu  自定义鼠标右键弹出上下文菜单内容（仅firefox支持）<br>data-*  为元素增加自定义属性<br>d","link":"","raw":null,"photos":[],"categories":[{"name":"interview","slug":"interview","count":9,"path":"api/categories/interview.json"}],"tags":[{"name":"interview","slug":"interview","count":9,"path":"api/tags/interview.json"},{"name":"everyday","slug":"everyday","count":7,"path":"api/tags/everyday.json"}]},{"title":" 高阶函数","slug":"javascript/f76abd1baa","date":"2020-06-01T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/f76abd1baa.json","excerpt":"<p>JavaScript的函数可以指向某个变量，变量也可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为<code>高阶函数</code>。</p>\n<h2 id=\"简单的高阶函数\"><a href=\"#简单的高阶函数\" class=\"headerlink\" title=\"简单的高阶函数\"></a>简单的高阶函数</h2><pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\">x, y, f</span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> f(x) + f(y);\n&#125;\n<span class=\"hljs-comment\">//当调用add(-5, 6, Math.abs)时，参数x，y和f分别接收-5，6和函数Math.abs，根据函数定义，可以推导计算过程为：</span>\n<span class=\"hljs-comment\">//x = -5;</span>\n<span class=\"hljs-comment\">//y = 6;</span>\n<span class=\"hljs-comment\">//f = Math.abs;</span>\n<span class=\"hljs-comment\">//f(x) + f(y) ==&gt; Math.abs(-5) + Math.abs(6) ==&gt; 11;</span>\n<span class=\"hljs-comment\">//return 11;</span>\n\n<span class=\"hljs-comment\">//用代码验证一下：</span>\nadd(-<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-built_in\">Math</span>.abs); <span class=\"hljs-comment\">// 11</span></code></pre>","keywords":null,"cover":null,"content":null,"text":"JavaScript的函数可以指向某个变量，变量也可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。简单的高阶函数function add(x, y, f) &#123;    return f(x) + f(y);&#125","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" 编写JavaScript的10个小技巧","slug":"javascript/23752932d8","date":"2020-04-05T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/23752932d8.json","excerpt":"<h2 id=\"简化条件表达式\"><a href=\"#简化条件表达式\" class=\"headerlink\" title=\"简化条件表达式\"></a>简化条件表达式</h2><p>经常碰到这种情况，要判断某个变量是否为指定的某些值，用常规的逻辑表达式会很长。我的做法是把这些值放进数组里：</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 太长的逻辑表达式</span>\n<span class=\"hljs-keyword\">if</span> (x === <span class=\"hljs-string\">&#x27;abc&#x27;</span> || x === <span class=\"hljs-string\">&#x27;def&#x27;</span> || x === <span class=\"hljs-string\">&#x27;ghi&#x27;</span> || x ===<span class=\"hljs-string\">&#x27;jkl&#x27;</span>) &#123;\n    <span class=\"hljs-comment\">//其他逻辑</span>\n&#125;\n<span class=\"hljs-comment\">// 简写</span>\n<span class=\"hljs-keyword\">if</span> ([<span class=\"hljs-string\">&#x27;abc&#x27;</span>, <span class=\"hljs-string\">&#x27;def&#x27;</span>, <span class=\"hljs-string\">&#x27;ghi&#x27;</span>, <span class=\"hljs-string\">&#x27;jkl&#x27;</span>].includes(x)) &#123;\n   <span class=\"hljs-comment\">//其他逻辑</span>\n&#125;</code></pre>","keywords":null,"cover":null,"content":null,"text":"简化条件表达式经常碰到这种情况，要判断某个变量是否为指定的某些值，用常规的逻辑表达式会很长。我的做法是把这些值放进数组里：// 太长的逻辑表达式if (x === &#x27;abc&#x27; || x === &#x27;def&#x27; || x === &#x27;gh","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]}]}
{"total":64,"pageSize":10,"pageCount":7,"data":[{"title":" 详解valueOf() 与toString()是做什么的以及其在各种情况下的应用","slug":"javascript/1543294b3a","date":"2021-06-17T07:24:35.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/1543294b3a.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>各种引用对象都继承或最终继承于 Object ，使用着Object的原型，所以它们不管何时都有 toString() 和 valueOf() 方法，只不过有些类型的原型重写了这两个方法，比如 Function 实例的原型就重写了 toString() 方法，按照原型链的规则，如果方法和属性在原型链的各原型中有重名，则优先使用最近的方法和属性。</p>\n<hr>\n<p>先看看常用的引用类型重写了这两个方法的情况</p>\n<ul>\n<li>Function 重写了 toString()</li>\n<li>Date 重写了 toString() 也重写了 valueOf()</li>\n<li>Array 重写了 toString()</li>\n<li><h2 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h2>对于不同的引用对象，使用的toString()也不一定相同<br>我们来看看其对三个最常见的引用对象的处理。</li>\n</ul>\n<h3 id=\"Function\"><a href=\"#Function\" class=\"headerlink\" title=\"Function\"></a>Function</h3><p>很简单，就是function本身的样子</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;\n<span class=\"hljs-built_in\">console</span>.log(fn == <span class=\"hljs-string\">&#x27;function () &#123;&#125;&#x27;</span>) <span class=\"hljs-comment\">//true</span>\n<span class=\"hljs-comment\">//上一篇讲到如果用双等号的一边是引用类型</span>\n<span class=\"hljs-comment\">//（除了Date直接用toString（）转换）则先将元素进行valueOf()转换，再把它用toString()转换后进行比较</span>\n<span class=\"hljs-comment\">//https://blog.csdn.net/weixin_42476799/article/details/89296873</span></code></pre>\n\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>) &#125;\n<span class=\"hljs-built_in\">console</span>.log(fn == <span class=\"hljs-string\">&#x27;function() &#123; console.log(1) &#125;&#x27;</span>)<span class=\"hljs-comment\">//true</span></code></pre>\n\n<p>这时候问题来了</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)&#125;<span class=\"hljs-comment\">//这边末尾大括号前缺了个空格</span>\n<span class=\"hljs-built_in\">console</span>.log(fn == <span class=\"hljs-string\">&#x27;function() &#123; console.log(1) &#125;&#x27;</span>)<span class=\"hljs-comment\">//它是true呢还是false呢</span></code></pre>\n\n<p>结果是false<br>也就是说function进行了toString()转换后与我们书写的function完全一样，多个空格少个空格都不行</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<span class=\"hljs-comment\">//没有空格</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)\n&#125;\n<span class=\"hljs-built_in\">console</span>.log(fn == <span class=\"hljs-string\">&#x27;function() &#123;\\nconsole.log(1)\\n&#125;&#x27;</span>)<span class=\"hljs-comment\">//它是true呢还是false呢</span></code></pre>\n\n<p>false,这又是为什么呢，因为toString()时会把注释也给加进去。。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<span class=\"hljs-comment\">//没有空格</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)\n&#125;\n<span class=\"hljs-built_in\">console</span>.log(fn == <span class=\"hljs-string\">&#x27;function() &#123;//没有空格\\nconsole.log(1)\\n&#125;&#x27;</span>)<span class=\"hljs-comment\">//true</span></code></pre>\n\n<p>所以现在可以得出结论了function对象的toString()到底做了些什么呢，把我们写function内容完完全全复制成为了字符串。<br>如果你觉得写一些\\n什么的麻烦，可以试试es6的``,也就是模板字符串。比如：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<span class=\"hljs-comment\">//没有空格</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)\n&#125;\n<span class=\"hljs-built_in\">console</span>.log(fn == <span class=\"hljs-string\">`function() &#123;//没有空格</span>\n<span class=\"hljs-string\">console.log(1)</span>\n<span class=\"hljs-string\">&#125;`</span>)<span class=\"hljs-comment\">//true</span></code></pre>\n\n<h3 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h3><p>我们先来看一下 Array 是怎样的</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">5</span>]\n<span class=\"hljs-built_in\">console</span>.log(arr == <span class=\"hljs-string\">&#x27;1,2,3,4,5,2,1,5,2,1,5&#x27;</span>)<span class=\"hljs-comment\">//true</span></code></pre>\n\n<p>它就简单多了我们再来看看它会不会出现function那种要与原函数写得完全一样</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">5</span>]\n<span class=\"hljs-built_in\">console</span>.log(arr == <span class=\"hljs-string\">&#x27;1,2,3,4,5,2,1,5,2,1,5&#x27;</span>)<span class=\"hljs-comment\">//true</span></code></pre>\n\n<p>所以就可以得出结论了arr.toString()就是将每个元素用逗号隔开类似于arr.join(’,’)</p>\n<h3 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h3><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> date = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-string\">&#x27;1998-02-23&#x27;</span>)\n<span class=\"hljs-built_in\">console</span>.log(date == <span class=\"hljs-string\">&#x27;Mon Feb 23 1998 08:00:00 GMT+0800 (中国标准时间)&#x27;</span>)<span class=\"hljs-comment\">//true</span></code></pre>\n\n<p>它也比较直接，只要你传的值是它能解析的日期格式，toString()后给你的是和上边格式一样的字符串</p>\n<h3 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h3><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> obj1 = &#123;&#125;,obj2 = &#123;<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&#x27;name&#x27;</span>&#125;\n<span class=\"hljs-built_in\">console</span>.log(obj2 == <span class=\"hljs-string\">&#x27;[object Object]&#x27;</span>)<span class=\"hljs-comment\">//true</span>\n<span class=\"hljs-built_in\">console</span>.log(obj1 == <span class=\"hljs-string\">&#x27;[object Object]&#x27;</span>)<span class=\"hljs-comment\">//true</span></code></pre>\n\n<p>Object不管写成啥样，都会变成’[object Object]’这个字符串</p>\n<h2 id=\"valueOf-NaN\"><a href=\"#valueOf-NaN\" class=\"headerlink\" title=\"valueOf()\"></a>valueOf()</h2><h3 id=\"Function-1\"><a href=\"#Function-1\" class=\"headerlink\" title=\"Function\"></a>Function</h3><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;\n<span class=\"hljs-built_in\">console</span>.log(fn.valueOf() === fn)<span class=\"hljs-comment\">//true</span></code></pre>\n\n<p>也就是说fn.valueOf()返回的是fn本身。是不是很无聊。</p>\n<h3 id=\"Array-1\"><a href=\"#Array-1\" class=\"headerlink\" title=\"Array\"></a>Array</h3><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">5</span>]\n<span class=\"hljs-built_in\">console</span>.log(arr.valueOf() === arr)<span class=\"hljs-comment\">//Array也是返回自身</span></code></pre>\n\n<h3 id=\"Object-1\"><a href=\"#Object-1\" class=\"headerlink\" title=\"Object\"></a>Object</h3><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> obj = &#123;&#125;\n<span class=\"hljs-built_in\">console</span>.log(obj.valueOf() === obj)<span class=\"hljs-comment\">//Object也是返回自身</span></code></pre>\n\n<h3 id=\"Date-1\"><a href=\"#Date-1\" class=\"headerlink\" title=\"Date\"></a>Date</h3><p>难道date也是返回自身吗</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> date = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-string\">&#x27;1998-02-23&#x27;</span>)\n<span class=\"hljs-built_in\">console</span>.log(date.valueOf() === date)<span class=\"hljs-comment\">//false</span></code></pre>\n\n<p>前文提到，三个常用的引用对象中只有Date重写了valueOf()方法，那肯定有它的独到之处，我们来看看它是什么</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> date = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-string\">&#x27;1998-02-23&#x27;</span>)\n<span class=\"hljs-built_in\">console</span>.log(date.valueOf() === <span class=\"hljs-number\">888192000000</span> )<span class=\"hljs-comment\">//true</span></code></pre>\n\n<p>原来它是返回从 1970 年 1 月 1 日午夜开始计的毫秒数。</p>\n<p>我们现在知道了这四个引用对象用上toString和valueOf后会变成啥样，但我们还不知道它们各自在什么时候使用<br>那我们来看看</p>\n<p>从上一篇中我们发现，双等号一边如果是引用类型的话首先会使用valueOf(),再使用toString()</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = []\narr.toString = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;arrtoString&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>&#125;\narr.valueOf = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;arrvalueOf&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span> &#125;\n<span class=\"hljs-built_in\">console</span>.log(arr)<span class=\"hljs-comment\">//直接返回arr本身，不进行转换</span>\nalert(arr)<span class=\"hljs-comment\">//只用toString</span>\n<span class=\"hljs-built_in\">Number</span>(arr)<span class=\"hljs-comment\">//先用valueOf再用toString</span>\n<span class=\"hljs-built_in\">String</span>(arr)<span class=\"hljs-comment\">//只用toString</span>\n<span class=\"hljs-built_in\">console</span>.log(+arr)<span class=\"hljs-comment\">//先用valueOf再用toString</span></code></pre>\n\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;&#125;\nfn.toString = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;fntoString&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>&#125;\nfn.valueOf = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;fnvalueOf&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>&#125;\n<span class=\"hljs-built_in\">console</span>.log(fn)<span class=\"hljs-comment\">//先用toString再用valueOf</span>\nalert(fn)<span class=\"hljs-comment\">//用toString</span>\n<span class=\"hljs-built_in\">Number</span>(fn)<span class=\"hljs-comment\">//先用valueOf再用toString</span>\n<span class=\"hljs-built_in\">String</span>(fn)<span class=\"hljs-comment\">//只用toString</span>\n<span class=\"hljs-built_in\">console</span>.log(+fn)<span class=\"hljs-comment\">//先用valueOf再用toString</span></code></pre>\n\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> date = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()\ndate.toString = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;datetoString&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>&#125;\ndate.valueOf = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;datevalueOf&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>&#125;\n<span class=\"hljs-built_in\">console</span>.log(date)<span class=\"hljs-comment\">//执行两次toString(),不太明白</span>\nalert(date)<span class=\"hljs-comment\">//用一次toString</span>\n<span class=\"hljs-built_in\">Number</span>(date)<span class=\"hljs-comment\">//先用valueOf再用toString</span>\n<span class=\"hljs-built_in\">String</span>(date)<span class=\"hljs-comment\">//只用toString</span>\n<span class=\"hljs-built_in\">console</span>.log(+date)<span class=\"hljs-comment\">//先用valueOf再用toString</span></code></pre>\n\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> obj = &#123;&#125;\nobj.toString = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;objtoString&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>&#125;\nobj.valueOf = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;objvalueOf&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>&#125;\n<span class=\"hljs-built_in\">console</span>.log(obj)<span class=\"hljs-comment\">//直接展现，不用任何转换</span>\nalert(obj)<span class=\"hljs-comment\">//用一次toString</span>\n<span class=\"hljs-built_in\">Number</span>(obj)<span class=\"hljs-comment\">//先用valueOf再用toString</span>\n<span class=\"hljs-built_in\">String</span>(obj)<span class=\"hljs-comment\">//只用toString</span>\n<span class=\"hljs-built_in\">console</span>.log(+obj)<span class=\"hljs-comment\">//先用valueOf再用toString</span></code></pre>\n\n<p>所以可以得出结论了，</p>\n<ul>\n<li>console.log()直接打印的话中除了object直接打印、date执行两次toString,其余都toString再用valueOf,</li>\n<li>alert(),String()中都只使用了toString()，</li>\n<li>如果需要进行运算，都是先进行valueOf再toString</li>\n<li>总而言之，与数字、运算有关的用valueOf优先,其他都是toString优先</li>\n</ul>\n","text":"前言各种引用对象都继承或最终继承于 Object ，使用着Object的原型，所以它们不管何时都有 toString() 和 valueOf() 方法，只不过有些类型的原型重写了这两个方法，比如 Function 实例的原型就重写了 toString() 方法，按照原型链的规则，","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" Mac怎么刷新DNS缓存","slug":"macos/579cc29de2","date":"2021-06-08T09:04:03.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/macos/579cc29de2.json","excerpt":"","keywords":null,"cover":null,"content":"<p>请使用以下“终端”命令来还原 DNS 缓存设置：</p>\n<pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">sudo killall -HUP mDNSResponder</span></code></pre>\n\n","text":"请使用以下“终端”命令来还原 DNS 缓存设置：sudo killall -HUP mDNSResponder","link":"","raw":null,"photos":[],"categories":[{"name":"macos","slug":"macos","count":3,"path":"api/categories/macos.json"}],"tags":[{"name":"macos","slug":"macos","count":3,"path":"api/tags/macos.json"}]},{"title":" 从 Event Loop 角度解读 Vue NextTick 源码","slug":"vue/cdb7936afb","date":"2021-06-08T09:04:03.000Z","updated":"2021-06-17T11:25:09.051Z","comments":true,"path":"api/articles/vue/cdb7936afb.json","excerpt":"","keywords":null,"cover":"/images/640.gif","content":"<h2 id=\"解读背景\"><a href=\"#解读背景\" class=\"headerlink\" title=\"解读背景\"></a>解读背景</h2><ol>\n<li>在学习 <strong>vue</strong> 源码，<strong>nextTick</strong> 方法借助了浏览器的 <strong>event loop</strong> 事件循环做到了异步更新。</li>\n<li>在公司面试的时候，笔试题最喜欢出关于 <strong>JavaScript</strong> 运行机制，<strong>Promise/A+</strong> 等关于 <strong>event loop</strong> 线程的题目。</li>\n<li>学会 <strong>nextTick</strong> 原理帮助定位 <strong>BUG</strong> , 使用 <strong>Vue</strong> 会更加灵活。</li>\n</ol>\n<h2 id=\"什么是-event-loop\"><a href=\"#什么是-event-loop\" class=\"headerlink\" title=\"什么是 event loop\"></a>什么是 event loop</h2><p><img src=\"/images/640.gif\"></p>\n<ol>\n<li>先执行同步阻塞任务，同步任务会等待上一个执行完毕以后执行下一个，当同步任务执行完毕，再执行异步任务，遇到异步任务会将异步任务的回调函数注册在异步任务队列里。注意，如果主线程上没有同步任务会直接调用异步任务的微任务。</li>\n<li>执行宏任务，遇到微任务将都添加到微任务队列里。</li>\n<li>开始执行微任务队列，当宏任务执行完后执行微任务队列，直到微任务队列全部执行完，微任务队列为空。</li>\n<li>执行宏任务，如果在执行宏任务期间有微任务，将微任务添加到微任务队列里，执行完宏任务之后执行微任务，直到微任务队列全部执行完。</li>\n<li>继续执行宏任务队列。</li>\n</ol>\n<p><strong>重复2, 3, 4，5……直到宏微任务为空。</strong></p>\n<h2 id=\"nextTick-的实现原理\"><a href=\"#nextTick-的实现原理\" class=\"headerlink\" title=\"$nextTick 的实现原理\"></a>$nextTick 的实现原理</h2><p>从字面意思理解，<strong>next</strong> 下一个，<strong>tick</strong> 滴答（钟表）来源于定时器的周期性中断（输出脉冲），一次中断表示一个 <strong>tick</strong>，也被称做一个“时钟滴答”），<strong>nextTick</strong> 顾名思义就是下一个时钟滴答。看源码，在 <strong>Vue 2.x</strong> 版本中，<strong>nextTick</strong> 在 <strong>src\\core\\util</strong> 中的一个单独的文件 <strong>next-tick.js</strong> ，可见 <strong>nextTick</strong> 的重要性，虽然短短 <strong>200</strong> 多行，尤大却单独创建一个文件去维护。<br>接下来我们来看整个文件。</p>\n<ol>\n<li>声明了三个全局变量，<strong>callbacks: [] ，pending: Boolean，timerFunc: undefined</strong>。</li>\n<li>声明了一个函数 <strong>flushCallbacks</strong>。</li>\n<li>一堆 **if，else if **判断。</li>\n<li>抛出了一个函数 <strong>nextTick</strong>。</li>\n</ol>\n<h2 id=\"nextTick-函数\"><a href=\"#nextTick-函数\" class=\"headerlink\" title=\"nextTick 函数\"></a>nextTick 函数</h2><p><img src=\"/images/640.png\"></p>\n<ol>\n<li>声明一个局部变量 <strong>_resolve</strong> 。</li>\n<li>把所有回调函数压进 <strong>callbacks</strong> 中，以栈的形式的存储所有 <strong>callback</strong>。</li>\n<li>当 <strong>pending</strong> 为 <strong>false</strong> 时，执行 <strong>timerFunc</strong> 函数。</li>\n<li>当没有 <strong>callback</strong> 的时候，返回一个 <strong>Promise</strong> 的调用方式，可以用 <strong>.then</strong> 接收。</li>\n</ol>\n<h2 id=\"timerFunc-函数\"><a href=\"#timerFunc-函数\" class=\"headerlink\" title=\"timerFunc 函数\"></a>timerFunc 函数</h2><p>我们开始说了，timerFunc 为全局变量，现在调用 timerFunc ，timerFunc 是什么时候被赋值为一个函数，并且函数里执行代码又是什么？</p>\n<p><img src=\"/images/640%202.png\"></p>\n<p>我们看到，这段判断代码总共有四个分支，四个分支里对 timerFunc 有不同的赋值，我们先来看第一个分支。</p>\n<h3 id=\"Promise-分支\"><a href=\"#Promise-分支\" class=\"headerlink\" title=\"Promise 分支\"></a>Promise 分支</h3><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Promise</span> !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class=\"hljs-built_in\">Promise</span>)) &#123;\n  <span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-built_in\">Promise</span>.resolve()\n  timerFunc = <span class=\"hljs-function\">() =&gt;</span> &#123;\n    p.then(flushCallbacks)\n    <span class=\"hljs-comment\">// In problematic UIWebViews, Promise.then doesn&#x27;t completely break, but</span>\n    <span class=\"hljs-comment\">// it can get stuck in a weird state where callbacks are pushed into the</span>\n    <span class=\"hljs-comment\">// microtask queue but the queue isn&#x27;t being flushed, until the browser</span>\n    <span class=\"hljs-comment\">// needs to do some other work, e.g. handle a timer. Therefore we can</span>\n    <span class=\"hljs-comment\">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span>\n    <span class=\"hljs-keyword\">if</span> (isIOS) <span class=\"hljs-built_in\">setTimeout</span>(noop)\n  &#125;\n  isUsingMicroTask = <span class=\"hljs-literal\">true</span>\n&#125;</code></pre>\n\n<ol>\n<li>判断环境是否支持 Promise 并且 <strong>Promise</strong> 是否为原生。</li>\n<li>使用 <strong>Promise</strong> 异步调用 <strong>flushCallbacks</strong> 函数。</li>\n<li>当执行环境是 <strong>iPhone</strong> 等，使用 <strong>setTimeout</strong> 异步调用 <strong>noop</strong> ，<strong>iOS</strong> <strong>中在一些异常的webview</strong> 中，<strong>promise</strong> 结束后任务队列并没有刷新所以强制执行 <strong>setTimeout</strong> 刷新任务队列。</li>\n</ol>\n<h3 id=\"MutationObserver-分支\"><a href=\"#MutationObserver-分支\" class=\"headerlink\" title=\"MutationObserver 分支\"></a>MutationObserver 分支</h3><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!isIE &amp;&amp; <span class=\"hljs-keyword\">typeof</span> MutationObserver !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span> &amp;&amp; (\n  isNative(MutationObserver) ||\n  <span class=\"hljs-comment\">// PhantomJS and iOS 7.x</span>\n  MutationObserver.toString() === <span class=\"hljs-string\">&#x27;[object MutationObserverConstructor]&#x27;</span>\n)) &#123;\n  <span class=\"hljs-comment\">// Use MutationObserver where native Promise is not available,</span>\n  <span class=\"hljs-comment\">// e.g. PhantomJS, iOS7, Android 4.4</span>\n  <span class=\"hljs-comment\">// (#6466 MutationObserver is unreliable in IE11)</span>\n  <span class=\"hljs-keyword\">let</span> counter = <span class=\"hljs-number\">1</span>\n  <span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> MutationObserver(flushCallbacks)\n  <span class=\"hljs-keyword\">const</span> textNode = <span class=\"hljs-built_in\">document</span>.createTextNode(<span class=\"hljs-built_in\">String</span>(counter))\n  observer.observe(textNode, &#123;\n    <span class=\"hljs-attr\">characterData</span>: <span class=\"hljs-literal\">true</span>\n  &#125;)\n  timerFunc = <span class=\"hljs-function\">() =&gt;</span> &#123;\n    counter = (counter + <span class=\"hljs-number\">1</span>) % <span class=\"hljs-number\">2</span>\n    textNode.data = <span class=\"hljs-built_in\">String</span>(counter)\n  &#125;\n  isUsingMicroTask = <span class=\"hljs-literal\">true</span>\n&#125;</code></pre>\n\n<ol>\n<li>对非IE浏览器和是否可以使用 <strong>HTML5</strong> 新特性 <strong>MutationObserver</strong> 进行判断。</li>\n<li>实例一个 <strong>MutationObserver</strong> 对象，这个对象主要是对浏览器 <strong>DOM</strong> 变化进行监听，当实例化 <strong>MutationObserver</strong> 对象并且执行对象 <strong>observe</strong>，设置 <strong>DOM</strong> 节点发生改变时自动触发回调。</li>\n<li>把 <strong>timerFunc</strong> 赋值为一个改变 <strong>DOM</strong> 节点的方法，当 <strong>DOM</strong> 节点发生改变，触发 <strong>flushCallbacks</strong> 。（这里其实就是想用利用 <strong>MutationObserver</strong> 的特性进行异步操作）</li>\n</ol>\n<h3 id=\"setImmediate-分支\"><a href=\"#setImmediate-分支\" class=\"headerlink\" title=\"setImmediate 分支\"></a>setImmediate 分支</h3><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> setImmediate !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;\n  <span class=\"hljs-comment\">// Fallback to setImmediate.</span>\n  <span class=\"hljs-comment\">// Technically it leverages the (macro) task queue,</span>\n  <span class=\"hljs-comment\">// but it is still a better choice than setTimeout.</span>\n  timerFunc = <span class=\"hljs-function\">() =&gt;</span> &#123;\n    setImmediate(flushCallbacks)\n  &#125;\n&#125;</code></pre>\n\n<ol>\n<li>判断 <strong>setImmediate</strong> 是否存在，<strong>setImmediate</strong> 是高版本 <strong>IE</strong> （IE10+） 和 <strong>edge</strong> 才支持的。</li>\n<li>如果存在，传入 <strong>flushCallbacks</strong> 执行 <strong>setImmediate</strong> 。</li>\n</ol>\n<h3 id=\"setTimeout-分支\"><a href=\"#setTimeout-分支\" class=\"headerlink\" title=\"setTimeout 分支\"></a>setTimeout 分支</h3><pre><code class=\"hljs coffeescript\"><span class=\"hljs-keyword\">else</span> &#123;\n  <span class=\"hljs-regexp\">//</span> Fallback to <span class=\"hljs-built_in\">setTimeout</span>.\n<span class=\"hljs-function\">  <span class=\"hljs-title\">timerFunc</span> = <span class=\"hljs-params\">()</span> =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">setTimeout</span>(flushCallbacks, <span class=\"hljs-number\">0</span>)\n  &#125;\n&#125;</code></pre>\n\n<ol>\n<li>当以上所有分支异步 <strong>api</strong> 都不支持的时候，使用 <strong>macro</strong> <strong>task</strong> （宏任务）的 <strong>setTimeout</strong> 执行 <strong>flushCallbacks</strong> 。</li>\n</ol>\n<h3 id=\"执行降级\"><a href=\"#执行降级\" class=\"headerlink\" title=\"执行降级\"></a>执行降级</h3><p>我们可以发现，给 timerFunc 赋值是一个降级的过程。为什么呢，因为 Vue 在执行的过程中，执行环境不同，所以要适配环境。</p>\n<p><img src=\"/images/640%203.png\"></p>\n<p>这张图便于我们更清晰的了解到降级的过程。</p>\n<h2 id=\"flushCallbacks-函数\"><a href=\"#flushCallbacks-函数\" class=\"headerlink\" title=\"flushCallbacks 函数\"></a>flushCallbacks 函数</h2><pre><code class=\"hljs nix\">function flushCallbacks () &#123;\n  <span class=\"hljs-attr\">pending</span> = <span class=\"hljs-literal\">false</span>\n  const <span class=\"hljs-attr\">copies</span> = callbacks.slice(<span class=\"hljs-number\">0</span>)\n  callbacks.<span class=\"hljs-attr\">length</span> = <span class=\"hljs-number\">0</span>\n  for (<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">i</span> = <span class=\"hljs-number\">0</span>; i &lt; copies.length; i++) &#123;\n    copies[i]()\n  &#125;\n&#125;</code></pre>\n\n<p>循环遍历，按照 <strong>队列</strong> 数据结构 <strong>“先进先出”</strong> 的原则，逐一执行所有 <strong>callback</strong> 。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>到这里就全部讲完了，<strong>nextTick</strong> 的原理就是利用 <strong>Event</strong> <strong>loop</strong> 事件线程去异步重新渲染，分支判断首要选择 <strong>Promise</strong> 的原因是当同步JS代码执行完毕，执行栈清空会首先查看 <strong>micro</strong> <strong>task</strong> （微任务）队列是否为空，不为空首先执行微任务。在我们 <strong>DOM</strong> 依赖数据发生变化的时候，会异步重新渲染 <strong>DOM</strong> ，但是比如像 <strong>echarts</strong> ，<strong>canvas</strong>……这些 <strong>Vue</strong> 无法在初始状态下收集依赖的 <strong>DOM</strong> ，我们就需要手动执行 <strong>nextTick</strong> 方法使其重新渲染。</p>\n","text":"解读背景在学习 vue 源码，nextTick 方法借助了浏览器的 event loop 事件循环做到了异步更新。在公司面试的时候，笔试题最喜欢出关于 JavaScript 运行机制，Promise/A+ 等关于 event loop 线程的题目。学会 nextTick 原理帮助","link":"","raw":null,"photos":[],"categories":[{"name":"vue","slug":"vue","count":2,"path":"api/categories/vue.json"}],"tags":[{"name":"vue","slug":"vue","count":2,"path":"api/tags/vue.json"}]},{"title":" 如何实现浏览器内多个标签页之间的通信？","slug":"interview/0bab1e5161","date":"2021-06-07T02:47:41.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/interview/0bab1e5161.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>本题主要考察数据存储的知识，数据存储有本地和服务器存储两种方式。这里主要讲解用本地存储方式解决。即调用 localStorage、Cookie等本地存储方式。  </p>\n</blockquote>\n<h2 id=\"第一种-调用localStorage\"><a href=\"#第一种-调用localStorage\" class=\"headerlink\" title=\"第一种 调用localStorage\"></a>第一种 调用localStorage</h2><p>在一个标签页里面使用 localStorage.setItem(key,value)添加（修改、删除）内容；<br>在另一个标签页里面监听 storage 事件。<br>即可得到 localstorge 存储的值，实现不同标签页之间的通信。</p>\n<p>标签页1：</p>\n<pre><code class=\"hljs js\">&lt;input id=<span class=\"hljs-string\">&quot;name&quot;</span>&gt;  \n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;button&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;btn&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;提交&quot;</span>&gt;</span>  </span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"javascript\">  </span></span>\n<span class=\"javascript\"><span class=\"xml\">    $(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;    </span></span>\n<span class=\"javascript\"><span class=\"xml\">        $(<span class=\"hljs-string\">&quot;#btn&quot;</span>).click(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;    </span></span>\n<span class=\"javascript\"><span class=\"xml\">            <span class=\"hljs-keyword\">var</span> name=$(<span class=\"hljs-string\">&quot;#name&quot;</span>).val();    </span></span>\n<span class=\"javascript\"><span class=\"xml\">            <span class=\"hljs-built_in\">localStorage</span>.setItem(<span class=\"hljs-string\">&quot;name&quot;</span>, name);   </span></span>\n<span class=\"javascript\"><span class=\"xml\">        &#125;);    </span></span>\n<span class=\"javascript\"><span class=\"xml\">    &#125;);    </span></span>\n<span class=\"javascript\"><span class=\"xml\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>  </span></code></pre>\n\n<p>标签页2：</p>\n<pre><code class=\"hljs js\">&lt;script type=<span class=\"hljs-string\">&quot;text/javascript&quot;</span>&gt;  \n    $(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;   \n        <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">&quot;storage&quot;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>)</span>&#123;    \n            <span class=\"hljs-built_in\">console</span>.log(event.key + <span class=\"hljs-string\">&quot;=&quot;</span> + event.newValue);    \n        &#125;);     \n    &#125;);  \n&lt;/script&gt;</code></pre>\n\n<h2 id=\"第二种-调用cookie-setInterval\"><a href=\"#第二种-调用cookie-setInterval\" class=\"headerlink\" title=\"第二种 调用cookie+setInterval()\"></a>第二种 调用cookie+setInterval()</h2><p>将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息。</p>\n<p>页面1：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;name&quot;</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;button&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;btn&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;提交&quot;</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"javascript\">  </span>\n<span class=\"javascript\">    $(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;    </span>\n<span class=\"javascript\">        $(<span class=\"hljs-string\">&quot;#btn&quot;</span>).click(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;    </span>\n<span class=\"javascript\">            <span class=\"hljs-keyword\">var</span> name=$(<span class=\"hljs-string\">&quot;#name&quot;</span>).val();    </span>\n<span class=\"javascript\">            <span class=\"hljs-built_in\">document</span>.cookie=<span class=\"hljs-string\">&quot;name=&quot;</span>+name;    </span>\n<span class=\"javascript\">        &#125;);    </span>\n<span class=\"javascript\">    &#125;);    </span>\n<span class=\"javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n\n<p>页面2：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"javascript\">  </span>\n<span class=\"javascript\">    $(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;   </span>\n<span class=\"javascript\">        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getCookie</span>(<span class=\"hljs-params\">key</span>) </span>&#123;    </span>\n<span class=\"javascript\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">JSON</span>.parse(<span class=\"hljs-string\">&quot;&#123;\\&quot;&quot;</span> + <span class=\"hljs-built_in\">document</span>.cookie.replace(<span class=\"hljs-regexp\">/;\\s+/gim</span>,<span class=\"hljs-string\">&quot;\\&quot;,\\&quot;&quot;</span>).replace(<span class=\"hljs-regexp\">/=/gim</span>, <span class=\"hljs-string\">&quot;\\&quot;:\\&quot;&quot;</span>) + <span class=\"hljs-string\">&quot;\\&quot;&#125;&quot;</span>)[key];    </span>\n<span class=\"javascript\">        &#125;     </span>\n<span class=\"javascript\">        <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;    </span>\n<span class=\"javascript\">            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;name=&quot;</span> + getCookie(<span class=\"hljs-string\">&quot;name&quot;</span>));    </span>\n<span class=\"javascript\">        &#125;, <span class=\"hljs-number\">10000</span>);    </span>\n<span class=\"javascript\">    &#125;);  </span>\n<span class=\"javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n\n\n","text":"本题主要考察数据存储的知识，数据存储有本地和服务器存储两种方式。这里主要讲解用本地存储方式解决。即调用 localStorage、Cookie等本地存储方式。  第一种 调用localStorage在一个标签页里面使用 localStorage.setItem(key,value","link":"","raw":null,"photos":[],"categories":[{"name":"Interview","slug":"Interview","count":3,"path":"api/categories/Interview.json"}],"tags":[{"name":"Interview","slug":"Interview","count":3,"path":"api/tags/Interview.json"},{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" HTML5的文件离线储存怎么使用，工作原理是什么？","slug":"interview/de0df6d619","date":"2021-06-07T02:31:02.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/interview/de0df6d619.json","excerpt":"","keywords":null,"cover":null,"content":"<p>HTML5离线存储存储功能非常强大，它的作用是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，自动更新缓存数据。</p>\n<h2 id=\"原理：\"><a href=\"#原理：\" class=\"headerlink\" title=\"原理：\"></a>原理：</h2><p>HTML5的离线存储是基于一个新建的.appcache文件的，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p>\n<h2 id=\"怎么用：\"><a href=\"#怎么用：\" class=\"headerlink\" title=\"怎么用：\"></a>怎么用：</h2><p>首先，在html页面头部加入一个manifest的属性:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">HTML</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">manifest</span> = <span class=\"hljs-string\">&quot;cache.manifest&quot;</span>&gt;</span>\n...\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span></code></pre>\n\n<p>然后书写cache.manifest文件：</p>\n<pre><code class=\"hljs avrasm\">CACHE MANIFEST\n<span class=\"hljs-meta\">#v0.11</span>\n\n<span class=\"hljs-symbol\">CACHE:</span>\njs/app.js\ncss/style.css\n\n<span class=\"hljs-symbol\">NETWORK:</span>\nresourse/logo.png\n\n<span class=\"hljs-symbol\">FALLBACK:</span>\n/ /offline.html</code></pre>\n\n<p>manifest （即 .appcache 文件）文件是简单的文本文件，可分为三个部分：</p>\n<h2 id=\"CACHE-：\"><a href=\"#CACHE-：\" class=\"headerlink\" title=\"CACHE ：\"></a>CACHE ：</h2><p>在此标题下列出的文件将在首次下载后进行缓存。（由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来）</p>\n<h2 id=\"NETWORK-：\"><a href=\"#NETWORK-：\" class=\"headerlink\" title=\"NETWORK ：\"></a>NETWORK ：</h2><p>在此标题下列出的文件需要与服务器的连接，且不会被缓存，离线时无法使用。 <br>可以使用 “*” 来指示所有其他资源/文件都需要因特网连接：</p>\n<pre><code class=\"hljs avrasm\"><span class=\"hljs-symbol\">NETWORK:</span> *</code></pre>\n\n<p>如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。</p>\n<h2 id=\"FALLBACK：\"><a href=\"#FALLBACK：\" class=\"headerlink\" title=\"FALLBACK：\"></a>FALLBACK：</h2><p>在此标题下列出的文件规定当页面无法访问时的回退页面。比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html。</p>\n<h2 id=\"浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\"><a href=\"#浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\" class=\"headerlink\" title=\"浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\"></a>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</h2><p>在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。<br>离线的情况下，浏览器就直接使用离线存储的资源。</p>\n","text":"HTML5离线存储存储功能非常强大，它的作用是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，自动更新缓存数据。原理：HTML5的离线存储是基于一个新建的.appcache文件的，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储","link":"","raw":null,"photos":[],"categories":[{"name":"interview","slug":"interview","count":9,"path":"api/categories/interview.json"}],"tags":[{"name":"interview","slug":"interview","count":9,"path":"api/tags/interview.json"},{"name":"html","slug":"html","count":2,"path":"api/tags/html.json"}]},{"title":" sessionStorage 、localStorage 和 cookie 之间的区别","slug":"interview/a6f7da3b77","date":"2021-06-07T02:23:33.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/interview/a6f7da3b77.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"共同点\"><a href=\"#共同点\" class=\"headerlink\" title=\"共同点\"></a>共同点</h2><p>都是保存在浏览器端，且同源的。</p>\n<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><ul>\n<li>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。</li>\n<li>存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>\n<li>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。</li>\n<li>作用域不同，sessionStorage<strong>不在</strong>不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。</li>\n<li>Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。</li>\n<li>Web Storage 的 api 接口使用更方便。</li>\n</ul>\n","text":"共同点都是保存在浏览器端，且同源的。区别cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概","link":"","raw":null,"photos":[],"categories":[{"name":"Interview","slug":"Interview","count":3,"path":"api/categories/Interview.json"}],"tags":[{"name":"Interview","slug":"Interview","count":3,"path":"api/tags/Interview.json"},{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" src 与 href 的区别","slug":"interview/f426fb17e9","date":"2021-06-07T02:13:24.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/interview/f426fb17e9.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"src\"><a href=\"#src\" class=\"headerlink\" title=\"src\"></a>src</h2><ul>\n<li>src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。</li>\n<li>src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素</li>\n</ul>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span> =<span class=\"hljs-string\">&quot;js.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n\n<p>  当浏览器解析到该元素时，<strong>会暂停其他资源的下载和处理</strong>，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。<strong>这也是为什么将js脚本放在底部而不是头部</strong> </p>\n<h2 id=\"href\"><a href=\"#href\" class=\"headerlink\" title=\"href\"></a>href</h2><ul>\n<li>href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加</li>\n</ul>\n<pre><code class=\"hljs routeros\">&lt;link <span class=\"hljs-attribute\">href</span>=<span class=\"hljs-string\">&quot;common.css&quot;</span> <span class=\"hljs-attribute\">rel</span>=<span class=\"hljs-string\">&quot;stylesheet&quot;</span>/&gt;</code></pre>\n\n<ul>\n<li> 那么浏览器会识别该文档为css文件，就会并行下载资源并且<strong>不会</strong>停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式</li>\n</ul>\n","text":"srcsrc用于替换当前元素，href用于在当前文档和引用资源之间确立联系。src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素&lt;scri","link":"","raw":null,"photos":[],"categories":[{"name":"interview","slug":"interview","count":9,"path":"api/categories/interview.json"}],"tags":[{"name":"interview","slug":"interview","count":9,"path":"api/tags/interview.json"},{"name":"html","slug":"html","count":2,"path":"api/tags/html.json"}]},{"title":" vue3.0 是如何变快的？","slug":"vue3/ac6163e9d3","date":"2021-06-06T07:53:03.000Z","updated":"2021-06-17T11:25:09.051Z","comments":true,"path":"api/articles/vue3/ac6163e9d3.json","excerpt":"<h2 id=\"diff算法优化\"><a href=\"#diff算法优化\" class=\"headerlink\" title=\"diff算法优化\"></a>diff算法优化</h2><blockquote>\n<p>Vue2中的虚拟 <code>dom</code> 是进行全量的对比<br>Vue3新增了静态标记<code>(PatchFlag)</code><br>在与上次虚拟节点进行对比时候,只对比带有 <code>patch flash</code> 的节点<br>并且可以通过 <code>flag</code> 的信息得知当前节点要对比的具体内容  </p>\n</blockquote>","keywords":null,"cover":"/images/20210120113952295.png","content":null,"text":"diff算法优化Vue2中的虚拟 dom 是进行全量的对比<br>Vue3新增了静态标记(PatchFlag)<br>在与上次虚拟节点进行对比时候,只对比带有 patch flash 的节点<br>并且可以通过 flag 的信息得知当前节点要对比的具体内容   [Figure] ","link":"","raw":null,"photos":[],"categories":[{"name":"vue3","slug":"vue3","count":2,"path":"api/categories/vue3.json"}],"tags":[{"name":"vue3","slug":"vue3","count":2,"path":"api/tags/vue3.json"}]},{"title":" vue3.0 六大亮点","slug":"vue3/11682f46f1","date":"2021-06-06T07:36:37.000Z","updated":"2021-06-17T11:25:09.051Z","comments":true,"path":"api/articles/vue3/11682f46f1.json","excerpt":"","keywords":null,"cover":null,"content":"<ol>\n<li>performance: 性能比vue2.x块1.2~2倍;</li>\n<li>Tree shaking support: 按需编译，体积比vue2.x更小;</li>\n<li>Composition API: 组合API（类似React Hooks）;</li>\n<li>Better TypeScript support: 更好的 ts 支持;</li>\n<li>Custom Render API: 暴露了自定义渲染的API ;</li>\n<li>Fragment, Teleport(Protal): 更先进的组件 ;</li>\n</ol>\n","text":"performance: 性能比vue2.x块1.2~2倍;Tree shaking support: 按需编译，体积比vue2.x更小;Composition API: 组合API（类似React Hooks）;Better TypeScript support: 更好的 ts","link":"","raw":null,"photos":[],"categories":[{"name":"vue3","slug":"vue3","count":2,"path":"api/categories/vue3.json"}],"tags":[{"name":"vue3","slug":"vue3","count":2,"path":"api/tags/vue3.json"}]},{"title":" 修改 hosts","slug":"macos/c6ecda4c57","date":"2021-06-05T06:51:22.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/macos/c6ecda4c57.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"Windows系统\"><a href=\"#Windows系统\" class=\"headerlink\" title=\"Windows系统\"></a>Windows系统</h2><ul>\n<li>打开目录：C:/Windows/System32/drivers/etc/</li>\n<li>找到hosts文件，使用管理员模式打开记事本</li>\n<li>将hosts文件拖到管理员模式下的记事本中，然后在文件尾部添加以下文本：<pre><code class=\"hljs accesslog\"><span class=\"hljs-number\">151.101.0.133</span> raw.githubusercontent.com</code></pre></li>\n<li>保存文件（可能还要重启一下计算机？），就解决了。</li>\n</ul>\n<h2 id=\"Mac-OS-系统\"><a href=\"#Mac-OS-系统\" class=\"headerlink\" title=\"Mac OS 系统\"></a>Mac OS 系统</h2><ul>\n<li>打开终端（Terminal），默认位置在 启动台 –&gt; 其它 –&gt; 终端</li>\n<li>在终端中，输入以下命令，使用vim修改hosts文件（会要求输入计算机密码）：<pre><code class=\"hljs awk\">sudo vi <span class=\"hljs-regexp\">/etc/</span>hosts</code></pre></li>\n<li>确保输入法为英文模式，按一下键盘上的 i 键</li>\n<li>使用方向键，将光标移动至文本尾部，然后再文件尾部添加以下文本：<pre><code class=\"hljs accesslog\"><span class=\"hljs-number\">151.101.0.133</span> raw.githubusercontent.com</code></pre></li>\n<li>按一下esc，然后输入 :wq! ,然后回车</li>\n<li>关闭终端，问题解决。</li>\n</ul>\n<h2 id=\"Linux-系统\"><a href=\"#Linux-系统\" class=\"headerlink\" title=\"Linux 系统\"></a>Linux 系统</h2><ul>\n<li>和Mac下操作基本一致。。。。</li>\n</ul>\n","text":"Windows系统打开目录：C:/Windows/System32/drivers/etc/找到hosts文件，使用管理员模式打开记事本将hosts文件拖到管理员模式下的记事本中，然后在文件尾部添加以下文本：151.101.0.133 raw.githubusercontent.","link":"","raw":null,"photos":[],"categories":[{"name":"macos","slug":"macos","count":3,"path":"api/categories/macos.json"}],"tags":[{"name":"macos","slug":"macos","count":3,"path":"api/tags/macos.json"}]}]}
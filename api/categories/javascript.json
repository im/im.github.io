{"name":"javascript","slug":"javascript","count":21,"postlist":[{"title":" JavaScript 实现前端下载图片","slug":"javascript/0eec0217cd","date":"2019-05-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/0eec0217cd.json","excerpt":"<h2 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h2><ul>\n<li>  将图片装换成 Data URLs</li>\n<li>  下载图片</li>\n</ul>\n<h4 id=\"Data-URLs\"><a href=\"#Data-URLs\" class=\"headerlink\" title=\"Data URLs\"></a>Data URLs</h4><blockquote>\n<p>Data URLs，即前缀为 data: 协议的的 URL，其允许内容创建者向文档中嵌入小文件。<br>Data URLs 由四个部分组成：前缀(data:)、指示数据类型的 MIME 类型、如果非文本则为可选的 base64 标记、数据本身：<br>data:[<mediatype>][;base64],<data><br>mediative 是个 MIME 类型的字符串，例如 “image/jpeg” 表示 JPEG 图像文件。如果被省略，则默认值为 text/plain;charset=US-ASCII<br>如果数据是文本类型，你可以直接将文本嵌入 (根据文档类型，使用合适的实体字符或转义字符)。如果是二进制数据，你可以将数据进行 base64 编码之后再进行嵌入。  </p>\n</blockquote>\n<p>详细请看 MDN 对 <a href=\"~https://developer.mozilla.org/zh-CN/docs/Web/HTTP/data_URIs~\">Data URLs</a> 的解释。</p>","keywords":null,"cover":null,"content":null,"text":"实现思路  将图片装换成 Data URLs  下载图片Data URLsData URLs，即前缀为 data: 协议的的 URL，其允许内容创建者向文档中嵌入小文件。<br>Data URLs 由四个部分组成：前缀(data:)、指示数据类型的 MIME 类型、如果非文本则为","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" 详解valueOf() 与toString()是做什么的以及其在各种情况下的应用","slug":"javascript/1543294b3a","date":"2021-06-17T07:24:35.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/1543294b3a.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>各种引用对象都继承或最终继承于 Object ，使用着Object的原型，所以它们不管何时都有 toString() 和 valueOf() 方法，只不过有些类型的原型重写了这两个方法，比如 Function 实例的原型就重写了 toString() 方法，按照原型链的规则，如果方法和属性在原型链的各原型中有重名，则优先使用最近的方法和属性。</p>\n<hr>\n<p>先看看常用的引用类型重写了这两个方法的情况</p>\n<ul>\n<li>Function 重写了 toString()</li>\n<li>Date 重写了 toString() 也重写了 valueOf()</li>\n<li>Array 重写了 toString()</li>\n<li><h2 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h2>对于不同的引用对象，使用的toString()也不一定相同<br>我们来看看其对三个最常见的引用对象的处理。</li>\n</ul>\n<h3 id=\"Function\"><a href=\"#Function\" class=\"headerlink\" title=\"Function\"></a>Function</h3><p>很简单，就是function本身的样子</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;\n<span class=\"hljs-built_in\">console</span>.log(fn == <span class=\"hljs-string\">&#x27;function () &#123;&#125;&#x27;</span>) <span class=\"hljs-comment\">//true</span>\n<span class=\"hljs-comment\">//上一篇讲到如果用双等号的一边是引用类型</span>\n<span class=\"hljs-comment\">//（除了Date直接用toString（）转换）则先将元素进行valueOf()转换，再把它用toString()转换后进行比较</span>\n<span class=\"hljs-comment\">//https://blog.csdn.net/weixin_42476799/article/details/89296873</span></code></pre>\n\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>) &#125;\n<span class=\"hljs-built_in\">console</span>.log(fn == <span class=\"hljs-string\">&#x27;function() &#123; console.log(1) &#125;&#x27;</span>)<span class=\"hljs-comment\">//true</span></code></pre>\n\n<p>这时候问题来了</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)&#125;<span class=\"hljs-comment\">//这边末尾大括号前缺了个空格</span>\n<span class=\"hljs-built_in\">console</span>.log(fn == <span class=\"hljs-string\">&#x27;function() &#123; console.log(1) &#125;&#x27;</span>)<span class=\"hljs-comment\">//它是true呢还是false呢</span></code></pre>\n\n<p>结果是false<br>也就是说function进行了toString()转换后与我们书写的function完全一样，多个空格少个空格都不行</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<span class=\"hljs-comment\">//没有空格</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)\n&#125;\n<span class=\"hljs-built_in\">console</span>.log(fn == <span class=\"hljs-string\">&#x27;function() &#123;\\nconsole.log(1)\\n&#125;&#x27;</span>)<span class=\"hljs-comment\">//它是true呢还是false呢</span></code></pre>\n\n<p>false,这又是为什么呢，因为toString()时会把注释也给加进去。。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<span class=\"hljs-comment\">//没有空格</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)\n&#125;\n<span class=\"hljs-built_in\">console</span>.log(fn == <span class=\"hljs-string\">&#x27;function() &#123;//没有空格\\nconsole.log(1)\\n&#125;&#x27;</span>)<span class=\"hljs-comment\">//true</span></code></pre>\n\n<p>所以现在可以得出结论了function对象的toString()到底做了些什么呢，把我们写function内容完完全全复制成为了字符串。<br>如果你觉得写一些\\n什么的麻烦，可以试试es6的``,也就是模板字符串。比如：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<span class=\"hljs-comment\">//没有空格</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)\n&#125;\n<span class=\"hljs-built_in\">console</span>.log(fn == <span class=\"hljs-string\">`function() &#123;//没有空格</span>\n<span class=\"hljs-string\">console.log(1)</span>\n<span class=\"hljs-string\">&#125;`</span>)<span class=\"hljs-comment\">//true</span></code></pre>\n\n<h3 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h3><p>我们先来看一下 Array 是怎样的</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">5</span>]\n<span class=\"hljs-built_in\">console</span>.log(arr == <span class=\"hljs-string\">&#x27;1,2,3,4,5,2,1,5,2,1,5&#x27;</span>)<span class=\"hljs-comment\">//true</span></code></pre>\n\n<p>它就简单多了我们再来看看它会不会出现function那种要与原函数写得完全一样</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">5</span>]\n<span class=\"hljs-built_in\">console</span>.log(arr == <span class=\"hljs-string\">&#x27;1,2,3,4,5,2,1,5,2,1,5&#x27;</span>)<span class=\"hljs-comment\">//true</span></code></pre>\n\n<p>所以就可以得出结论了arr.toString()就是将每个元素用逗号隔开类似于arr.join(’,’)</p>\n<h3 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h3><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> date = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-string\">&#x27;1998-02-23&#x27;</span>)\n<span class=\"hljs-built_in\">console</span>.log(date == <span class=\"hljs-string\">&#x27;Mon Feb 23 1998 08:00:00 GMT+0800 (中国标准时间)&#x27;</span>)<span class=\"hljs-comment\">//true</span></code></pre>\n\n<p>它也比较直接，只要你传的值是它能解析的日期格式，toString()后给你的是和上边格式一样的字符串</p>\n<h3 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h3><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> obj1 = &#123;&#125;,obj2 = &#123;<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&#x27;name&#x27;</span>&#125;\n<span class=\"hljs-built_in\">console</span>.log(obj2 == <span class=\"hljs-string\">&#x27;[object Object]&#x27;</span>)<span class=\"hljs-comment\">//true</span>\n<span class=\"hljs-built_in\">console</span>.log(obj1 == <span class=\"hljs-string\">&#x27;[object Object]&#x27;</span>)<span class=\"hljs-comment\">//true</span></code></pre>\n\n<p>Object不管写成啥样，都会变成’[object Object]’这个字符串</p>\n<h2 id=\"valueOf-NaN\"><a href=\"#valueOf-NaN\" class=\"headerlink\" title=\"valueOf()\"></a>valueOf()</h2><h3 id=\"Function-1\"><a href=\"#Function-1\" class=\"headerlink\" title=\"Function\"></a>Function</h3><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;\n<span class=\"hljs-built_in\">console</span>.log(fn.valueOf() === fn)<span class=\"hljs-comment\">//true</span></code></pre>\n\n<p>也就是说fn.valueOf()返回的是fn本身。是不是很无聊。</p>\n<h3 id=\"Array-1\"><a href=\"#Array-1\" class=\"headerlink\" title=\"Array\"></a>Array</h3><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">5</span>]\n<span class=\"hljs-built_in\">console</span>.log(arr.valueOf() === arr)<span class=\"hljs-comment\">//Array也是返回自身</span></code></pre>\n\n<h3 id=\"Object-1\"><a href=\"#Object-1\" class=\"headerlink\" title=\"Object\"></a>Object</h3><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> obj = &#123;&#125;\n<span class=\"hljs-built_in\">console</span>.log(obj.valueOf() === obj)<span class=\"hljs-comment\">//Object也是返回自身</span></code></pre>\n\n<h3 id=\"Date-1\"><a href=\"#Date-1\" class=\"headerlink\" title=\"Date\"></a>Date</h3><p>难道date也是返回自身吗</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> date = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-string\">&#x27;1998-02-23&#x27;</span>)\n<span class=\"hljs-built_in\">console</span>.log(date.valueOf() === date)<span class=\"hljs-comment\">//false</span></code></pre>\n\n<p>前文提到，三个常用的引用对象中只有Date重写了valueOf()方法，那肯定有它的独到之处，我们来看看它是什么</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> date = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-string\">&#x27;1998-02-23&#x27;</span>)\n<span class=\"hljs-built_in\">console</span>.log(date.valueOf() === <span class=\"hljs-number\">888192000000</span> )<span class=\"hljs-comment\">//true</span></code></pre>\n\n<p>原来它是返回从 1970 年 1 月 1 日午夜开始计的毫秒数。</p>\n<p>我们现在知道了这四个引用对象用上toString和valueOf后会变成啥样，但我们还不知道它们各自在什么时候使用<br>那我们来看看</p>\n<p>从上一篇中我们发现，双等号一边如果是引用类型的话首先会使用valueOf(),再使用toString()</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = []\narr.toString = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;arrtoString&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>&#125;\narr.valueOf = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;arrvalueOf&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span> &#125;\n<span class=\"hljs-built_in\">console</span>.log(arr)<span class=\"hljs-comment\">//直接返回arr本身，不进行转换</span>\nalert(arr)<span class=\"hljs-comment\">//只用toString</span>\n<span class=\"hljs-built_in\">Number</span>(arr)<span class=\"hljs-comment\">//先用valueOf再用toString</span>\n<span class=\"hljs-built_in\">String</span>(arr)<span class=\"hljs-comment\">//只用toString</span>\n<span class=\"hljs-built_in\">console</span>.log(+arr)<span class=\"hljs-comment\">//先用valueOf再用toString</span></code></pre>\n\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;&#125;\nfn.toString = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;fntoString&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>&#125;\nfn.valueOf = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;fnvalueOf&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>&#125;\n<span class=\"hljs-built_in\">console</span>.log(fn)<span class=\"hljs-comment\">//先用toString再用valueOf</span>\nalert(fn)<span class=\"hljs-comment\">//用toString</span>\n<span class=\"hljs-built_in\">Number</span>(fn)<span class=\"hljs-comment\">//先用valueOf再用toString</span>\n<span class=\"hljs-built_in\">String</span>(fn)<span class=\"hljs-comment\">//只用toString</span>\n<span class=\"hljs-built_in\">console</span>.log(+fn)<span class=\"hljs-comment\">//先用valueOf再用toString</span></code></pre>\n\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> date = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()\ndate.toString = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;datetoString&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>&#125;\ndate.valueOf = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;datevalueOf&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>&#125;\n<span class=\"hljs-built_in\">console</span>.log(date)<span class=\"hljs-comment\">//执行两次toString(),不太明白</span>\nalert(date)<span class=\"hljs-comment\">//用一次toString</span>\n<span class=\"hljs-built_in\">Number</span>(date)<span class=\"hljs-comment\">//先用valueOf再用toString</span>\n<span class=\"hljs-built_in\">String</span>(date)<span class=\"hljs-comment\">//只用toString</span>\n<span class=\"hljs-built_in\">console</span>.log(+date)<span class=\"hljs-comment\">//先用valueOf再用toString</span></code></pre>\n\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> obj = &#123;&#125;\nobj.toString = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;objtoString&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>&#125;\nobj.valueOf = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;objvalueOf&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>&#125;\n<span class=\"hljs-built_in\">console</span>.log(obj)<span class=\"hljs-comment\">//直接展现，不用任何转换</span>\nalert(obj)<span class=\"hljs-comment\">//用一次toString</span>\n<span class=\"hljs-built_in\">Number</span>(obj)<span class=\"hljs-comment\">//先用valueOf再用toString</span>\n<span class=\"hljs-built_in\">String</span>(obj)<span class=\"hljs-comment\">//只用toString</span>\n<span class=\"hljs-built_in\">console</span>.log(+obj)<span class=\"hljs-comment\">//先用valueOf再用toString</span></code></pre>\n\n<p>所以可以得出结论了，</p>\n<ul>\n<li>console.log()直接打印的话中除了object直接打印、date执行两次toString,其余都toString再用valueOf,</li>\n<li>alert(),String()中都只使用了toString()，</li>\n<li>如果需要进行运算，都是先进行valueOf再toString</li>\n<li>总而言之，与数字、运算有关的用valueOf优先,其他都是toString优先</li>\n</ul>\n","text":"前言各种引用对象都继承或最终继承于 Object ，使用着Object的原型，所以它们不管何时都有 toString() 和 valueOf() 方法，只不过有些类型的原型重写了这两个方法，比如 Function 实例的原型就重写了 toString() 方法，按照原型链的规则，","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" 编写JavaScript的10个小技巧","slug":"javascript/23752932d8","date":"2020-04-05T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/23752932d8.json","excerpt":"<h2 id=\"简化条件表达式\"><a href=\"#简化条件表达式\" class=\"headerlink\" title=\"简化条件表达式\"></a>简化条件表达式</h2><p>经常碰到这种情况，要判断某个变量是否为指定的某些值，用常规的逻辑表达式会很长。我的做法是把这些值放进数组里：</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 太长的逻辑表达式</span>\n<span class=\"hljs-keyword\">if</span> (x === <span class=\"hljs-string\">&#x27;abc&#x27;</span> || x === <span class=\"hljs-string\">&#x27;def&#x27;</span> || x === <span class=\"hljs-string\">&#x27;ghi&#x27;</span> || x ===<span class=\"hljs-string\">&#x27;jkl&#x27;</span>) &#123;\n    <span class=\"hljs-comment\">//其他逻辑</span>\n&#125;\n<span class=\"hljs-comment\">// 简写</span>\n<span class=\"hljs-keyword\">if</span> ([<span class=\"hljs-string\">&#x27;abc&#x27;</span>, <span class=\"hljs-string\">&#x27;def&#x27;</span>, <span class=\"hljs-string\">&#x27;ghi&#x27;</span>, <span class=\"hljs-string\">&#x27;jkl&#x27;</span>].includes(x)) &#123;\n   <span class=\"hljs-comment\">//其他逻辑</span>\n&#125;</code></pre>","keywords":null,"cover":null,"content":null,"text":"简化条件表达式经常碰到这种情况，要判断某个变量是否为指定的某些值，用常规的逻辑表达式会很长。我的做法是把这些值放进数组里：// 太长的逻辑表达式if (x === &#x27;abc&#x27; || x === &#x27;def&#x27; || x === &#x27;gh","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" JavaScript 内存泄漏教程","slug":"javascript/23d05c6dd2","date":"2019-04-29T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/23d05c6dd2.json","excerpt":"<p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。</p>\n<p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p>\n<p><img src=\"/images/bg2017041701-1.png\"><br>不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。</p>\n<p>有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。</p>\n<pre><code class=\"hljs c\"><span class=\"hljs-keyword\">char</span> * buffer;\nbuffer = (<span class=\"hljs-keyword\">char</span>*) <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">42</span>);\n\n<span class=\"hljs-comment\">// Do something with buffer</span>\n\n<span class=\"hljs-built_in\">free</span>(buffer);</code></pre>\n\n<p>上面是 C 语言代码， <code>malloc</code> 方法用来申请内存，使用完毕之后，必须自己用 <code>free</code> 方法释放内存。</p>\n<p>这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”（<strong>garbage collector</strong>）。</p>","keywords":null,"cover":"/images/bg2017041701-1.png","content":null,"text":"程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 [Figure] 下面以 WeakMap 为例，看看它是怎么","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" 偏函数","slug":"javascript/31cb92dd1f","date":"2021-01-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/31cb92dd1f.json","excerpt":"<p>偏函数是 [[函数柯里化]]  运算的一种特定应用场景。简单描述，就是把一个函数的某些参数先固化，也就是设置默认值，返回一个新的函数，在新函数中继续接收剩余参数，这样调用这个新函数会更简单。</p>\n<p><strong>下面是一个类型检测函数，接收两个参数，第 1 个表示类型字符串，第 2 个表示检测的数据。</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> isType = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">type, obj</span>) </span>&#123;  <span class=\"hljs-comment\">//偏函数</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Object</span>.prototype.toString.call(obj) == <span class=\"hljs-string\">&#x27;[object &#x27;</span> + type + <span class=\"hljs-string\">&#x27;]&#x27;</span>;\n&#125;</code></pre>","keywords":null,"cover":null,"content":null,"text":"偏函数是 [[函数柯里化]]  运算的一种特定应用场景。简单描述，就是把一个函数的某些参数先固化，也就是设置默认值，返回一个新的函数，在新函数中继续接收剩余参数，这样调用这个新函数会更简单。下面是一个类型检测函数，接收两个参数，第 1 个表示类型字符串，第 2 个表示检测的数据。","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" JS - CommonJS、ES2015、AMD、CMD模块规范对比与介绍","slug":"javascript/465c78e370","date":"2019-03-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/465c78e370.json","excerpt":"<h3 id=\"CommonJS-基本介绍\"><a href=\"#CommonJS-基本介绍\" class=\"headerlink\" title=\"CommonJS 基本介绍\"></a>CommonJS 基本介绍</h3><ol>\n<li>CommonJS 是一种思想，它是为 JS 的表现来制定规范。由于 JS 没有模块系统、标准库较少、缺乏包管理工具，因此 CommonJS 应运而生。</li>\n<li>CommonJS 的目标是希望 JS 可以在任何地方运行，不只是浏览器中。只要我们的 JavaScript 是根据 CommonJS API 编写的，那么就可以在与 CommonJS 兼容的系统上运行。</li>\n<li>根据 CommonJS API 编写的 JavaScript 可以做下面这些事情：<ul>\n<li>编写服务端应用</li>\n<li>编写命令行工具</li>\n<li>编写基于 GUI 的桌面应用</li>\n</ul>\n</li>\n<li>CommonJS 规范有很多实现，最有名要数 NodeJS 了。</li>\n</ol>\n<h3 id=\"CommonJS-的模块规范\"><a href=\"#CommonJS-的模块规范\" class=\"headerlink\" title=\"CommonJS 的模块规范\"></a>CommonJS 的模块规范</h3><p>一个文件就是一个模块，拥有单独的作用域。普通方式定义的变量、函数、对象都属于该模块内。<br>    * 通过 require 来加载模块。<br>    * 通过 exports 和 modul.exports 来暴露模块中的内容。</p>","keywords":null,"cover":"/images/2017052214293263636.png","content":null,"text":"CommonJS 基本介绍CommonJS 是一种思想，它是为 JS 的表现来制定规范。由于 JS 没有模块系统、标准库较少、缺乏包管理工具，因此 CommonJS 应运而生。CommonJS 的目标是希望 JS 可以在任何地方运行，不只是浏览器中。只要我们的 JavaScrip","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" nodejs 搭建本地服务器 展示文件夹","slug":"javascript/51fcfc72c9","date":"2021-04-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/51fcfc72c9.json","excerpt":"","keywords":null,"cover":null,"content":"<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;express&#x27;</span>)\n<span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;http&#x27;</span>)\n<span class=\"hljs-keyword\">const</span> app = express()\n<span class=\"hljs-keyword\">const</span> port = <span class=\"hljs-number\">80</span>\n<span class=\"hljs-keyword\">var</span> serveIndex = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;serve-index&#x27;</span>)\n\napp.use(express.static(<span class=\"hljs-string\">&#x27;../&#x27;</span>))\napp.use(serveIndex(<span class=\"hljs-string\">&#x27;../&#x27;</span>))\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getIPAdress</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">let</span> interfaces = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;os&#x27;</span>).networkInterfaces()\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> devName <span class=\"hljs-keyword\">in</span> interfaces) &#123;\n        <span class=\"hljs-keyword\">var</span> iface = interfaces[devName]\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; iface.length; i++) &#123;\n            <span class=\"hljs-keyword\">let</span> alias = iface[i]\n            <span class=\"hljs-keyword\">if</span> (\n                alias.family === <span class=\"hljs-string\">&#x27;IPv4&#x27;</span> &amp;&amp;\n                alias.address !== <span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span> &amp;&amp;\n                !alias.internal\n            ) &#123;\n                <span class=\"hljs-comment\">// console.log(alias.address);</span>\n\n                <span class=\"hljs-keyword\">return</span> alias.address\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n<span class=\"hljs-keyword\">var</span> server = http.createServer(app)\n\nserver.listen(port, <span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Example app listening at http://<span class=\"hljs-subst\">$&#123;getIPAdress()&#125;</span>:<span class=\"hljs-subst\">$&#123;port&#125;</span>`</span>)\n&#125;)</code></pre>\n\n","text":"const express = require(&#x27;express&#x27;)const http = require(&#x27;http&#x27;)const app = express()const port = 80var serveIndex = requi","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"},{"name":"nodejs","slug":"nodejs","count":2,"path":"api/tags/nodejs.json"}]},{"title":" JavaScript 实现复制粘贴","slug":"javascript/54c2aafa7a","date":"2019-06-25T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/54c2aafa7a.json","excerpt":"<h2 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h2><h2 id=\"html\"><a href=\"#html\" class=\"headerlink\" title=\"html:\"></a>html:</h2><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onclick</span>=<span class=\"hljs-string\">&quot;copyToClip(&#x27;内容&#x27;)&quot;</span>&gt;</span>Copy<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n\n<h2 id=\"javascript\"><a href=\"#javascript\" class=\"headerlink\" title=\"javascript:\"></a>javascript:</h2><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\"> * 复制内容到粘贴板</span>\n<span class=\"hljs-comment\"> * content : 需要复制的内容</span>\n<span class=\"hljs-comment\"> * message : 复制完后的提示，不传则默认提示&quot;复制成功&quot;</span>\n<span class=\"hljs-comment\"> */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">copyToClip</span>(<span class=\"hljs-params\">content, message</span>) </span>&#123;\n    <span class=\"hljs-keyword\">var</span> aux = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">&#x27;input&#x27;</span>)\n    aux.setAttribute(<span class=\"hljs-string\">&#x27;value&#x27;</span>, content)\n    <span class=\"hljs-built_in\">document</span>.body.appendChild(aux)\n    aux.select()\n    <span class=\"hljs-built_in\">document</span>.execCommand(<span class=\"hljs-string\">&#x27;copy&#x27;</span>)\n    <span class=\"hljs-built_in\">document</span>.body.removeChild(aux)\n    <span class=\"hljs-keyword\">if</span> (message == <span class=\"hljs-literal\">null</span>) &#123;\n        alert(<span class=\"hljs-string\">&#x27;复制成功&#x27;</span>)\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n        alert(mesage)\n    &#125;\n&#125;</code></pre>","keywords":null,"cover":null,"content":null,"text":"实现思路html:&lt;button onclick=&quot;copyToClip(&#x27;内容&#x27;)&quot;&gt;Copy&lt;/button&gt;javascript:/** * 复制内容到粘贴板 * content : 需要复制的内容 * mes","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" JavaScript 的静态作用域链与“动态”闭包链","slug":"javascript/8bd3b1ab2f","date":"2019-09-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/8bd3b1ab2f.json","excerpt":"<p>读完本文会解答你以下疑问：</p>\n<ul>\n<li>静态作用域链和动态作用域链的区别</li>\n<li>为什么会有闭包</li>\n<li>闭包什么时候创建的</li>\n<li>[[scopes]] 属性是什么</li>\n<li>闭包保存什么内容</li>\n<li>闭包存储在哪</li>\n<li>为什么 eval 性能不好</li>\n<li>eval 什么情况下会创建闭包</li>\n</ul>\n<p>在 JavaScript 里面，函数、块、模块都可以形成作用域（一个存放变量的独立空间），他们之间可以相互嵌套，作用域之间会形成引用关系，这条链叫做作用域链。</p>\n<p>作用域链具体是什么样呢？</p>","keywords":null,"cover":"/images/72f12fc7e7164cc0af23f3e16f03bb06~tplv-k3u1fbpfcp-watermark.image.png","content":null,"text":"读完本文会解答你以下疑问：静态作用域链和动态作用域链的区别为什么会有闭包闭包什么时候创建的[[scopes]] 属性是什么闭包保存什么内容闭包存储在哪为什么 eval 性能不好eval 什么情况下会创建闭包在 JavaScript 里面，函数、块、模块都可以形成作用域（一个存放变","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"},{"name":"closure","slug":"closure","count":1,"path":"api/tags/closure.json"}]},{"title":" HTML5 Canvas生成粒子效果","slug":"javascript/8fe0756f8c","date":"2019-02-10T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/8fe0756f8c.json","excerpt":"<h2 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h2><p><a href=\"~https://cdn.jsdelivr.net/gh/im/oss@master/js/breathing-halftone.pkgd.min.js~\">breathing-halftone.pkgd.min.js</a></p>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// get the image</span>\n<span class=\"hljs-comment\">// jquery</span>\n<span class=\"hljs-keyword\">var</span> img = $(<span class=\"hljs-string\">&#x27;#hero img&#x27;</span>)[<span class=\"hljs-number\">0</span>]\n<span class=\"hljs-comment\">// or vanilla JS</span>\n<span class=\"hljs-keyword\">var</span> img = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;#hero img&#x27;</span>)\n\n<span class=\"hljs-comment\">// init halftone</span>\n<span class=\"hljs-keyword\">new</span> BreathingHalftone(img, &#123;\n    <span class=\"hljs-comment\">// options...</span>\n&#125;)</code></pre>","keywords":null,"cover":null,"content":null,"text":"Installbreathing-halftone.pkgd.min.jsUsage// get the image// jqueryvar img = $(&#x27;#hero img&#x27;)[0]// or vanilla JSvar img = document.q","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" 函数柯里化","slug":"javascript/9b990bb119","date":"2021-02-27T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/9b990bb119.json","excerpt":"<blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96\">柯里化 - 维基百科，自由的百科全书</a><br>把接受多个<code>参数</code>的<code>函数</code>变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。  </p>\n</blockquote>\n<h2 id=\"柯里化有3个常见作用：\"><a href=\"#柯里化有3个常见作用：\" class=\"headerlink\" title=\"柯里化有3个常见作用：\"></a>柯里化有3个常见作用：</h2><ol>\n<li>参数复用</li>\n<li>提前确定</li>\n<li>延迟计算/运行</li>\n</ol>\n<h2 id=\"基本实现\"><a href=\"#基本实现\" class=\"headerlink\" title=\"基本实现\"></a>基本实现</h2><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a</span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">b</span>) </span>&#123;\n        <span class=\"hljs-keyword\">return</span> a * a + b * b;\n    &#125;\n&#125;</code></pre>\n\n<p>调用上述函数：<code>(foo(3))(4)</code>，或直接<code>foo(3)(4)</code></p>","keywords":null,"cover":null,"content":null,"text":"柯里化 - 维基百科，自由的百科全书<br>把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。  柯里化有3个常见作用：参数复用提前确定延迟计算/运行基本实现var foo = function(a) &#","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" 揭开在线协作的神秘面纱 – OT 算法","slug":"javascript/9e1f204749","date":"2021-03-01T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/9e1f204749.json","excerpt":"<p>相信大家或多或少都有使用过在线文档，国内的像我们在做的 <a href=\"http://https//docs.qq.com/desktop/\">腾讯文档</a> 还有其他家的很多类似产品。今天主要为大家揭开在线协作的神秘面纱，那就是 OT 算法。</p>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>在线文档，抽象一下，这些产品的模式都是富文本编辑器+后台，富文本编辑器产生内容，展示内容，然后后台负责保存。<br>富文本编辑器现在业界已经有很多成熟的产品，像 <a href=\"https://codemirror.net/\">codeMirror</a> ，这一块本身也是很复杂的一块，也不是咱们这次关注的重点方向。<br>不知道大家平常在用这些产品的时候有没有思考过一个问题，在线文档编辑的时候产生冲突怎么办？</p>","keywords":null,"cover":"/images/0973dffd-399c-48e9-8fcf-77ff3a6809e6-272x300.png","content":null,"text":"相信大家或多或少都有使用过在线文档，国内的像我们在做的 腾讯文档 还有其他家的很多类似产品。今天主要为大家揭开在线协作的神秘面纱，那就是 OT 算法。背景在线文档，抽象一下，这些产品的模式都是富文本编辑器+后台，富文本编辑器产生内容，展示内容，然后后台负责保存。<br>富文本编辑","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" Node.js的版本升级","slug":"javascript/b893a6f276","date":"2021-06-04T03:47:17.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/b893a6f276.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"查看本地node版本\"><a href=\"#查看本地node版本\" class=\"headerlink\" title=\"查看本地node版本\"></a>查看本地node版本</h2><pre><code class=\"hljs crmsh\"><span class=\"hljs-keyword\">node</span> <span class=\"hljs-title\">-v</span></code></pre>\n\n<h2 id=\"安装n模块\"><a href=\"#安装n模块\" class=\"headerlink\" title=\"安装n模块\"></a>安装n模块</h2><pre><code class=\"hljs cmake\">npm <span class=\"hljs-keyword\">install</span> -g n（mac需要在命令的前面加上sudo）</code></pre>\n\n<h2 id=\"升级到指定的版本-最新版本，升级之前，可以执行n-ls（查看可以升级的版本）\"><a href=\"#升级到指定的版本-最新版本，升级之前，可以执行n-ls（查看可以升级的版本）\" class=\"headerlink\" title=\"升级到指定的版本/最新版本，升级之前，可以执行n ls（查看可以升级的版本）\"></a>升级到指定的版本/最新版本，升级之前，可以执行n ls（查看可以升级的版本）</h2><pre><code class=\"hljs excel\"><span class=\"hljs-built_in\">n</span> <span class=\"hljs-number\">8.10</span>.<span class=\"hljs-number\">1</span>（版本号）\n或者你可以安装最新的稳定版本\n<span class=\"hljs-built_in\">n</span> stable</code></pre>\n\n<h2 id=\"4-安装完成以后，检查一下是否升级成功\"><a href=\"#4-安装完成以后，检查一下是否升级成功\" class=\"headerlink\" title=\"4.安装完成以后，检查一下是否升级成功\"></a>4.安装完成以后，检查一下是否升级成功</h2><pre><code class=\"hljs crmsh\"><span class=\"hljs-keyword\">node</span> <span class=\"hljs-title\">-v</span></code></pre>\n\n\n","text":"查看本地node版本node -v安装n模块npm install -g n（mac需要在命令的前面加上sudo）升级到指定的版本/最新版本，升级之前，可以执行n ls（查看可以升级的版本）n 8.10.1（版本号）或者你可以安装最新的稳定版本n stable4.安装完成以后，检","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"},{"name":"nodejs","slug":"nodejs","count":2,"path":"api/tags/nodejs.json"}]},{"title":" JavaScript里的循环方法：forEach，for-in，for-of","slug":"javascript/cbbeb436fb","date":"2021-04-03T02:02:28.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/cbbeb436fb.json","excerpt":"<p>JavaScript诞生已经有20多年了，我们一直使用的用来循环一个数组的方法是这样的：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> index = <span class=\"hljs-number\">0</span>; index &lt; myArray.length; index++) &#123;\n  <span class=\"hljs-built_in\">console</span>.log(myArray[index]);\n&#125;</code></pre>\n\n<p>自从JavaScript5起，我们开始可以使用内置的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\">forEach</a> 方法：</p>\n<pre><code class=\"hljs js\">myArray.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;\n  <span class=\"hljs-built_in\">console</span>.log(value);\n&#125;);</code></pre>\n\n<p>写法简单了许多，但也有短处：你不能中断循环(使用break语句或使用return语句。<br>JavaScript里还有一种循环方法：for–in。<br>for-in 循环实际是为循环<strong>enumerable</strong>对象而设计的：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> obj = &#123;<span class=\"hljs-attr\">a</span>:<span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>:<span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">c</span>:<span class=\"hljs-number\">3</span>&#125;;\n    \n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> prop <span class=\"hljs-keyword\">in</span> obj) &#123;\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;obj.&quot;</span> + prop + <span class=\"hljs-string\">&quot; = &quot;</span> + obj[prop]);\n&#125;\n\n<span class=\"hljs-comment\">// 输出:</span>\n<span class=\"hljs-comment\">// &quot;obj.a = 1&quot;</span>\n<span class=\"hljs-comment\">// &quot;obj.b = 2&quot;</span>\n<span class=\"hljs-comment\">// &quot;obj.c = 3&quot;</span></code></pre>\n\n<p>你也可以用它来循环一个数组：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> index <span class=\"hljs-keyword\">in</span> myArray) &#123;    <span class=\"hljs-comment\">// 不推荐这样</span>\n  <span class=\"hljs-built_in\">console</span>.log(myArray[index]);\n&#125;</code></pre>\n\n<p>不推荐用for-in来循环一个数组，因为，不像对象，数组的index跟普通的对象属性不一样，是重要的数值序列指标。<br>总之，for–in是用来循环带有字符串key的对象的方法。</p>","keywords":null,"cover":null,"content":null,"text":"JavaScript诞生已经有20多年了，我们一直使用的用来循环一个数组的方法是这样的：for (var index = 0; index &lt; myArray.length; index++) &#123;  console.log(myArray[index]);&#12","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" JS事件循环（Event Loop）","slug":"javascript/ef320f6e2a","date":"2021-01-02T01:49:36.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/ef320f6e2a.json","excerpt":"<blockquote>\n<p>众所周知，JavaScript 是一门单线程语言，虽然在 html5 中提出了 Web-Worker ，但这并未改变 JavaScript 是单线程这一核心,，可是浏览器又能很好的处理异步请求，那么到底是为什么呢？  </p>\n</blockquote>\n<p><strong>浏览器执行线程</strong></p>\n<blockquote>\n<p>在解释事件循环之前首先先解释一下浏览器的执行线程：<br>浏览器是多进程的，浏览器每一个 tab 标签都代表一个独立的进程，其中浏览器渲染进程（浏览器内核）属于浏览器多进程中的一种，主要负责页面渲染，脚本执行，事件处理等<br>其包含的线程有：GUI 渲染线程（负责渲染页面，解析 HTML，CSS 构成 DOM 树）、JS 引擎线程、事件触发线程、定时器触发线程、http 请求线程等主要线程  </p>\n</blockquote>","keywords":null,"cover":"/images/v2-1337770fcc29d10325ee4eb127496fff_1440w.jpg","content":null,"text":"众所周知，JavaScript 是一门单线程语言，虽然在 html5 中提出了 Web-Worker ，但这并未改变 JavaScript 是单线程这一核心,，可是浏览器又能很好的处理异步请求，那么到底是为什么呢？  浏览器执行线程在解释事件循环之前首先先解释一下浏览器的执行线程","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" 高阶函数","slug":"javascript/f76abd1baa","date":"2020-06-01T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/f76abd1baa.json","excerpt":"<p>JavaScript的函数可以指向某个变量，变量也可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为<code>高阶函数</code>。</p>\n<h2 id=\"简单的高阶函数\"><a href=\"#简单的高阶函数\" class=\"headerlink\" title=\"简单的高阶函数\"></a>简单的高阶函数</h2><pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\">x, y, f</span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> f(x) + f(y);\n&#125;\n<span class=\"hljs-comment\">//当调用add(-5, 6, Math.abs)时，参数x，y和f分别接收-5，6和函数Math.abs，根据函数定义，可以推导计算过程为：</span>\n<span class=\"hljs-comment\">//x = -5;</span>\n<span class=\"hljs-comment\">//y = 6;</span>\n<span class=\"hljs-comment\">//f = Math.abs;</span>\n<span class=\"hljs-comment\">//f(x) + f(y) ==&gt; Math.abs(-5) + Math.abs(6) ==&gt; 11;</span>\n<span class=\"hljs-comment\">//return 11;</span>\n\n<span class=\"hljs-comment\">//用代码验证一下：</span>\nadd(-<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-built_in\">Math</span>.abs); <span class=\"hljs-comment\">// 11</span></code></pre>","keywords":null,"cover":null,"content":null,"text":"JavaScript的函数可以指向某个变量，变量也可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。简单的高阶函数function add(x, y, f) &#123;    return f(x) + f(y);&#125","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" Object.assign 是浅拷贝还是深拷贝？实现深拷贝的方法有哪些？","slug":"javascript/f81ce9141d","date":"2019-06-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/f81ce9141d.json","excerpt":"<blockquote>\n<p>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。  </p>\n</blockquote>\n<ul>\n<li><p>如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。</p>\n</li>\n<li><p>Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。</p>\n</li>\n<li><p>String类型和 Symbol 类型的属性都会被拷贝。</p>\n</li>\n<li><p>在出现错误的情况下，例如，如果属性不可写，会引发TypeError，如果在引发错误之前添加了任何属性，则可以更改target对象。</p>\n</li>\n<li><p>Object.assign 不会在那些source对象值为 <code>null</code> 或 <code>undefined</code> 的时候抛出错误。</p>\n</li>\n<li><p>针对 <strong>深拷贝</strong> ，需要使用其他办法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。也就是说，如果对象的属性值为简单类型（如string， number），通过Object.assign({},srcObj);得到的新对象为 <code>深拷贝</code> ；如果属性值为对象或其它引用类型，那对于这个对象而言其实是 <code>浅拷贝</code> 的。</p>","keywords":null,"cover":null,"content":null,"text":"Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。  如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。Object.assign 方法只会拷贝源对象自身","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" 数组扁平化","slug":"javascript/fa59b4bb32","date":"2021-02-03T05:36:57.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/fa59b4bb32.json","excerpt":"<h1 id=\"Array-prototype-flat\"><a href=\"#Array-prototype-flat\" class=\"headerlink\" title=\"Array.prototype.flat()\"></a>Array.prototype.flat()</h1><p><strong>flat()</strong> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> arr1 = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]];\n\n<span class=\"hljs-built_in\">console</span>.log(arr1.flat());\n<span class=\"hljs-comment\">// expected output: [0, 1, 2, 3, 4]</span>\n\n<span class=\"hljs-keyword\">const</span> arr2 = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, [[[<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]]]];\n\n<span class=\"hljs-built_in\">console</span>.log(arr2.flat(<span class=\"hljs-number\">2</span>));\n<span class=\"hljs-comment\">// expected output: [0, 1, 2, [3, 4]]</span>\n</code></pre>","keywords":null,"cover":null,"content":null,"text":"Array.prototype.flat()flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。const arr1 = [0, 1, 2, [3, 4]];console.log(arr1.flat());// exp","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" 实时协同编辑的实现","slug":"javascript/18a23f4c21","date":"2021-01-22T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/18a23f4c21.json","excerpt":"<p>在最近某个项目中打算使用协同编辑来解决冲突问题，因此抽空调研了现有的实现方案，结果发现要想做完美是很难的，但我们可以低成本地做到不错的效果，本文将介绍几种实现方法，大家在项目中如果有需要可以参考。</p>\n<h2 id=\"什么是实时协同编辑\"><a href=\"#什么是实时协同编辑\" class=\"headerlink\" title=\"什么是实时协同编辑\"></a>什么是实时协同编辑</h2><p>这里所说的实时协同编辑，是指多人同时编辑一个文档，最典型的例子是 Google Docs，你可以实时看到别人做出的修改，不用手动刷新页面。</p>\n<p>要实现实时编辑，我们需要解决两个技术点：实时通信问题、编辑冲突问题，其中实时通信问题比较好解决，可以使用 long pull 或 WebSocket，所以这里就不过多讨论了，重点将放在如何解决编辑冲突问题上。</p>\n<h2 id=\"可选方案\"><a href=\"#可选方案\" class=\"headerlink\" title=\"可选方案\"></a>可选方案</h2><p>接下来将从易至难的顺序来介绍几种可行的方案，分别是：「编辑锁」、「GNU diff-patch」、「Myer’s diff-patch」、「Operational Transformation」和「分布式 Operational Transformation」。</p>","keywords":null,"cover":"/images/merge.png","content":null,"text":"在最近某个项目中打算使用协同编辑来解决冲突问题，因此抽空调研了现有的实现方案，结果发现要想做完美是很难的，但我们可以低成本地做到不错的效果，本文将介绍几种实现方法，大家在项目中如果有需要可以参考。什么是实时协同编辑这里所说的实时协同编辑，是指多人同时编辑一个文档，最典型的例子是 ","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" 你不知道的浏览器渲染原理","slug":"javascript/419340c52c","date":"2021-03-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/419340c52c.json","excerpt":"<p>在我们面试过程中，面试官经常会问到这么一个问题，那就是从在浏览器地址栏中输入URL到页面显示，浏览器到底发生了什么？这个问题看起来是老生常谈，但是这个问题回答的好坏，确实可以很好的反映出面试者知识的广度和深度。<br>本文从浏览器角度来告诉你，URL后输入后按回车，浏览器内部究竟发生了什么，读完本文后，你将了解到：</p>\n<ul>\n<li><p>浏览器内有哪些进程，这些进程都有些什么作用</p>\n</li>\n<li><p>浏览器地址输入URL后，内部的进程、线程都做了哪些事</p>\n</li>\n<li><p>我们与浏览器交互时，内部进程是怎么处理这些交互事件的</p>\n</li>\n</ul>","keywords":null,"cover":"/images/_640.jpeg","content":null,"text":"在我们面试过程中，面试官经常会问到这么一个问题，那就是从在浏览器地址栏中输入URL到页面显示，浏览器到底发生了什么？这个问题看起来是老生常谈，但是这个问题回答的好坏，确实可以很好的反映出面试者知识的广度和深度。<br>本文从浏览器角度来告诉你，URL后输入后按回车，浏览器内部究竟","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]},{"title":" Airbnb JavaScript Style Guide","slug":"javascript/54108de862","date":"2019-07-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/54108de862.json","excerpt":"<h2 id=\"Types\"><a href=\"#Types\" class=\"headerlink\" title=\"Types\"></a>Types</h2><p><strong>1.1</strong> ::Primitives::: When you access a primitive type you work directly on its value.</p>\n<pre><code>* `string`\n* `number`\n* `boolean`\n* `null`\n* `undefined`\n* `symbol`\n* `bigint`\n</code></pre>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">let</span> bar = foo;\n\nbar = <span class=\"hljs-number\">9</span>;\n<span class=\"hljs-built_in\">console</span>.log(foo, bar); <span class=\"hljs-comment\">// =&gt; 1, 9</span></code></pre>\n\n<pre><code>* Symbols and BigInts cannot be faithfully polyfilled, so they should not be used when targeting browsers/environments that don’t support them natively.\n</code></pre>","keywords":null,"cover":null,"content":null,"text":"Types1.1 ::Primitives::: When you access a primitive type you work directly on its value.* `string`* `number`* `boolean`* `null`* `undefined","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]}]}
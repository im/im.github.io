{"sort":9,"title":" JavaScript 内存泄漏教程","slug":"javascript/23d05c6dd2","date":"2019-04-29T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/23d05c6dd2.json","photos":[],"link":"","excerpt":"程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 [Figure] 不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。char * buffer;buffer = (char*) malloc(42);// Do something with bufferfree(buffer);上面是 C 语言代码， malloc 方法用来申请内存，使用完毕之后，必须自己用 free 方法释放内存。这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”（garbage collector）。","covers":["/images/bg2017041701-1.png","/images/bg2017041703.png","/images/bg2017041704.png","/images/bg2017041705.png","/images/bg2017041706.png","/images/bg2017041702-1.png","/images/bg2017041707.jpg"],"content":"<p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。</p>\n<p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p>\n<p><img src=\"/images/bg2017041701-1.png\"><br>不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。</p>\n<p>有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。</p>\n<pre><code class=\"hljs c\"><span class=\"hljs-keyword\">char</span> * buffer;\nbuffer = (<span class=\"hljs-keyword\">char</span>*) <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">42</span>);\n\n<span class=\"hljs-comment\">// Do something with buffer</span>\n\n<span class=\"hljs-built_in\">free</span>(buffer);</code></pre>\n\n<p>上面是 C 语言代码， <code>malloc</code> 方法用来申请内存，使用完毕之后，必须自己用 <code>free</code> 方法释放内存。</p>\n<p>这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”（<strong>garbage collector</strong>）。</p>\n<a id=\"more\"></a>\n<h2 id=\"二、垃圾回收机制\"><a href=\"#二、垃圾回收机制\" class=\"headerlink\" title=\"二、垃圾回收机制\"></a>二、垃圾回收机制</h2><p>垃圾回收机制怎么知道，哪些内存不再需要呢？</p>\n<p>最常使用的方法叫做 <a href=\"https://en.wikipedia.org/wiki/Reference_counting\">“引用计数”</a> （reference counting）：语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是 <code>0</code> ，就表示这个值不再用到了，因此可以将这块内存释放。</p>\n<p><img src=\"/images/bg2017041703.png\"></p>\n<p>上图中，左下角的两个值，没有任何引用，所以可以释放。</p>\n<p>如果一个值不再需要了，引用数却不为 <code>0</code> ，垃圾回收机制无法释放这块内存，从而导致内存泄漏。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;hello world&#x27;</span>);</code></pre>\n\n<p>上面代码中，数组 <code>[1, 2, 3, 4]</code> 是一个值，会占用内存。变量 <code>arr</code> 是仅有的对这个值的引用，因此引用次数为 <code>1</code> 。尽管后面的代码没有用到 <code>arr</code> ，它还是会持续占用内存。</p>\n<p>如果增加一行代码，解除 <code>arr</code> 对 <code>[1, 2, 3, 4]</code> 引用，这块内存就可以被垃圾回收机制释放了。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;hello world&#x27;</span>);\narr = <span class=\"hljs-literal\">null</span>;</code></pre>\n\n<p>上面代码中， <code>arr</code> 重置为 <code>null</code> ，就解除了对 <code>[1, 2, 3, 4]</code> 的引用，引用次数变成了 <code>0</code> ，内存就可以释放出来了。</p>\n<p>因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。</p>\n<h2 id=\"三、内存泄漏的识别方法\"><a href=\"#三、内存泄漏的识别方法\" class=\"headerlink\" title=\"三、内存泄漏的识别方法\"></a>三、内存泄漏的识别方法</h2><p>怎样可以观察到内存泄漏呢？</p>\n<p><a href=\"https://www.toptal.com/nodejs/debugging-memory-leaks-node-js-applications\">经验法则</a> 是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。</p>\n<h3 id=\"3-1-浏览器\"><a href=\"#3-1-浏览器\" class=\"headerlink\" title=\"3.1 浏览器\"></a>3.1 浏览器</h3><p>Chrome 浏览器查看内存占用，按照以下步骤操作。</p>\n<p><img src=\"/images/bg2017041704.png\"></p>\n<ol>\n<li>打开开发者工具，选择 Timeline 面板</li>\n<li>在顶部的 <code>Capture</code> 字段里面勾选 Memory</li>\n<li>点击左上角的录制按钮。</li>\n<li>在页面上进行各种操作，模拟用户的使用情况。</li>\n<li>一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。</li>\n</ol>\n<p>如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。</p>\n<p><img src=\"/images/bg2017041705.png\"></p>\n<p>反之，就是内存泄漏了。</p>\n<p><img src=\"/images/bg2017041706.png\"></p>\n<h3 id=\"3-2-命令行\"><a href=\"#3-2-命令行\" class=\"headerlink\" title=\"3.2 命令行\"></a>3.2 命令行</h3><p>命令行可以使用 Node 提供的 <a href=\"https://nodejs.org/api/process.html#process_process_memoryusage\">process.memoryUsage</a> 方法。</p>\n<pre><code class=\"hljs awk\">console.log(process.memoryUsage());\n<span class=\"hljs-regexp\">//</span> &#123; rss: <span class=\"hljs-number\">27709440</span>,\n<span class=\"hljs-regexp\">//</span>  heapTotal: <span class=\"hljs-number\">5685248</span>,\n<span class=\"hljs-regexp\">//</span>  heapUsed: <span class=\"hljs-number\">3449392</span>,\n<span class=\"hljs-regexp\">//</span>  external: <span class=\"hljs-number\">8772</span> &#125;</code></pre>\n\n<p><code>process.memoryUsage</code> 返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，单位是字节， <a href=\"http://stackoverflow.com/questions/12023359/what-do-the-return-values-of-node-js-process-memoryusage-stand-for\">含义</a> 如下。</p>\n<p><img src=\"/images/bg2017041702-1.png\"></p>\n<ul>\n<li>rss（resident set size）：所有内存占用，包括指令区和堆栈。</li>\n<li>heapTotal：”堆”占用的内存，包括用到的和没用到的。</li>\n<li>heapUsed：用到的堆的部分。</li>\n<li>external： V8 引擎内部的 C++ 对象占用的内存。</li>\n</ul>\n<p>判断内存泄漏，以 <code>heapUsed</code> 字段为准。</p>\n<h2 id=\"四、WeakMap\"><a href=\"#四、WeakMap\" class=\"headerlink\" title=\"四、WeakMap\"></a>四、WeakMap</h2><p>前面说过，及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄漏。</p>\n<p>最好能有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。</p>\n<p>ES6 考虑到了这一点，推出了两种新的数据结构： <a href=\"http://es6.ruanyifeng.com/#docs/set-map#WeakSet\">WeakSet</a> 和 <a href=\"http://es6.ruanyifeng.com/#docs/set-map#WeakMap\">WeakMap</a> 。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个”Weak”，表示这是弱引用。</p>\n<p><img src=\"/images/bg2017041707.jpg\"></p>\n<p>下面以 WeakMap 为例，看看它是怎么解决内存泄漏的。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> wm = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakMap</span>();\n\n<span class=\"hljs-keyword\">const</span> element = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;example&#x27;</span>);\n\nwm.set(element, <span class=\"hljs-string\">&#x27;some information&#x27;</span>);\nwm.get(element) <span class=\"hljs-comment\">// &quot;some information&quot;</span></code></pre>\n\n<p>上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对 <code>element</code> 的引用就是弱引用，不会被计入垃圾回收机制。</p>\n<p>也就是说，DOM 节点对象的引用计数是 <code>1</code> ，而不是 <code>2</code> 。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。</p>\n<p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。</p>\n<h2 id=\"五、WeakMap-示例\"><a href=\"#五、WeakMap-示例\" class=\"headerlink\" title=\"五、WeakMap 示例\"></a>五、WeakMap 示例</h2><p>WeakMap 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 WeakMap 的键名了，导致无法证实那个键名是不是存在。</p>\n<p>我一直想不出办法，直到有一天贺师俊老师 <a href=\"https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292109104\">提示</a> ，如果引用所指向的值占用特别多的内存，就可以通过 <code>process.memoryUsage</code> 方法看出来。</p>\n<p>根据这个思路，网友 vtxf 补充了下面的 <a href=\"https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292451925\">例子</a> 。</p>\n<p>首先，打开 Node 命令行。</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> node --expose-gc</span></code></pre>\n\n<p>上面代码中， <code>--expose-gc</code> 参数表示允许手动执行垃圾回收机制。</p>\n<p>然后，执行下面的代码。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 手动执行一次垃圾回收，保证获取的内存使用状态准确</span>\n&gt; <span class=\"hljs-built_in\">global</span>.gc(); \n<span class=\"hljs-literal\">undefined</span>\n\n<span class=\"hljs-comment\">// 查看内存占用的初始状态，heapUsed 为 4M 左右</span>\n&gt; process.memoryUsage(); \n&#123; <span class=\"hljs-attr\">rss</span>: <span class=\"hljs-number\">21106688</span>,\n  <span class=\"hljs-attr\">heapTotal</span>: <span class=\"hljs-number\">7376896</span>,\n  <span class=\"hljs-attr\">heapUsed</span>: <span class=\"hljs-number\">4153936</span>,\n  <span class=\"hljs-attr\">external</span>: <span class=\"hljs-number\">9059</span> &#125;\n\n&gt; <span class=\"hljs-keyword\">let</span> wm = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakMap</span>();\n<span class=\"hljs-literal\">undefined</span>\n\n&gt; <span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Object</span>();\n<span class=\"hljs-literal\">undefined</span>\n\n&gt; <span class=\"hljs-built_in\">global</span>.gc();\n<span class=\"hljs-literal\">undefined</span>\n\n<span class=\"hljs-comment\">// 此时，heapUsed 仍然为 4M 左右</span>\n&gt; process.memoryUsage(); \n&#123; <span class=\"hljs-attr\">rss</span>: <span class=\"hljs-number\">20537344</span>,\n  <span class=\"hljs-attr\">heapTotal</span>: <span class=\"hljs-number\">9474048</span>,\n  <span class=\"hljs-attr\">heapUsed</span>: <span class=\"hljs-number\">3967272</span>,\n  <span class=\"hljs-attr\">external</span>: <span class=\"hljs-number\">8993</span> &#125;\n\n<span class=\"hljs-comment\">// 在 WeakMap 中添加一个键值对，</span>\n<span class=\"hljs-comment\">// 键名为对象 b，键值为一个 5*1024*1024 的数组  </span>\n&gt; wm.set(b, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(<span class=\"hljs-number\">5</span>*<span class=\"hljs-number\">1024</span>*<span class=\"hljs-number\">1024</span>));\n<span class=\"hljs-built_in\">WeakMap</span> &#123;&#125;\n\n<span class=\"hljs-comment\">// 手动执行一次垃圾回收</span>\n&gt; <span class=\"hljs-built_in\">global</span>.gc();\n<span class=\"hljs-literal\">undefined</span>\n\n<span class=\"hljs-comment\">// 此时，heapUsed 为 45M 左右</span>\n&gt; process.memoryUsage(); \n&#123; <span class=\"hljs-attr\">rss</span>: <span class=\"hljs-number\">62652416</span>,\n  <span class=\"hljs-attr\">heapTotal</span>: <span class=\"hljs-number\">51437568</span>,\n  <span class=\"hljs-attr\">heapUsed</span>: <span class=\"hljs-number\">45911664</span>,\n  <span class=\"hljs-attr\">external</span>: <span class=\"hljs-number\">8951</span> &#125;\n\n<span class=\"hljs-comment\">// 解除对象 b 的引用  </span>\n&gt; b = <span class=\"hljs-literal\">null</span>;\n<span class=\"hljs-literal\">null</span>\n\n<span class=\"hljs-comment\">// 再次执行垃圾回收</span>\n&gt; <span class=\"hljs-built_in\">global</span>.gc();\n<span class=\"hljs-literal\">undefined</span>\n\n<span class=\"hljs-comment\">// 解除 b 的引用以后，heapUsed 变回 4M 左右</span>\n<span class=\"hljs-comment\">// 说明 WeakMap 中的那个长度为 5*1024*1024 的数组被销毁了</span>\n&gt; process.memoryUsage(); \n&#123; <span class=\"hljs-attr\">rss</span>: <span class=\"hljs-number\">20639744</span>,\n  <span class=\"hljs-attr\">heapTotal</span>: <span class=\"hljs-number\">8425472</span>,\n  <span class=\"hljs-attr\">heapUsed</span>: <span class=\"hljs-number\">3979792</span>,\n  <span class=\"hljs-attr\">external</span>: <span class=\"hljs-number\">8956</span> &#125;</code></pre>\n\n<p>上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了它的帮助，解决内存泄漏就会简单很多。</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2017/04/memory-leak.html\">JavaScript 内存泄漏教程</a></p>\n","prev":{"title":" JavaScript 实现前端下载图片","slug":"javascript/0eec0217cd"},"next":{"title":" git submodule","slug":"git/38399f8bee"},"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]}
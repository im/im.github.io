{"sort":33,"title":" JS事件循环（Event Loop）","slug":"javascript/ef320f6e2a","date":"2021-01-02T01:49:36.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/javascript/ef320f6e2a.json","photos":[],"link":"","excerpt":"众所周知，JavaScript 是一门单线程语言，虽然在 html5 中提出了 Web-Worker ，但这并未改变 JavaScript 是单线程这一核心,，可是浏览器又能很好的处理异步请求，那么到底是为什么呢？  浏览器执行线程在解释事件循环之前首先先解释一下浏览器的执行线程：<br>浏览器是多进程的，浏览器每一个 tab 标签都代表一个独立的进程，其中浏览器渲染进程（浏览器内核）属于浏览器多进程中的一种，主要负责页面渲染，脚本执行，事件处理等<br>其包含的线程有：GUI 渲染线程（负责渲染页面，解析 HTML，CSS 构成 DOM 树）、JS 引擎线程、事件触发线程、定时器触发线程、http 请求线程等主要线程  ","covers":["/images/v2-1337770fcc29d10325ee4eb127496fff_1440w.jpg","/images/v2-a38ad24f9109e1a4cb7b49cc1b90cafe_1440w.jpg","/images/v2-a3ac02a230c49c9aa8c45af46eae2e1c_1440w.jpg"],"content":"<blockquote>\n<p>众所周知，JavaScript 是一门单线程语言，虽然在 html5 中提出了 Web-Worker ，但这并未改变 JavaScript 是单线程这一核心,，可是浏览器又能很好的处理异步请求，那么到底是为什么呢？  </p>\n</blockquote>\n<p><strong>浏览器执行线程</strong></p>\n<blockquote>\n<p>在解释事件循环之前首先先解释一下浏览器的执行线程：<br>浏览器是多进程的，浏览器每一个 tab 标签都代表一个独立的进程，其中浏览器渲染进程（浏览器内核）属于浏览器多进程中的一种，主要负责页面渲染，脚本执行，事件处理等<br>其包含的线程有：GUI 渲染线程（负责渲染页面，解析 HTML，CSS 构成 DOM 树）、JS 引擎线程、事件触发线程、定时器触发线程、http 请求线程等主要线程  </p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h3 id=\"关于执行中的线程：\"><a href=\"#关于执行中的线程：\" class=\"headerlink\" title=\"关于执行中的线程：\"></a>关于执行中的线程：</h3><p><strong>主线程</strong>：也就是 js 引擎执行的线程，这个线程只有一个，页面渲染、函数处理都在这个主线程上执行。<br><strong>工作线程</strong>：也称幕后线程，这个线程可能存在于浏览器或js引擎内，与主线程是分开的，处理文件读取、网络请求等异步事件。<br><strong>任务队列( Event Queue )</strong></p>\n<blockquote>\n<p>所有的任务可以分为同步任务和异步任务，同步任务，顾名思义，就是立即执行的任务，同步任务一般会直接进入到主线程中执行；而异步任务，就是异步执行的任务，比如ajax网络请求，setTimeout 定时函数等都属于异步任务，异步任务会通过任务队列的机制(先进先出的机制)来进行协调。具体的可以用下面的图来大致说明一下：  </p>\n</blockquote>\n<p><img src=\"/images/v2-1337770fcc29d10325ee4eb127496fff_1440w.jpg\"></p>\n<h3 id=\"同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入任务队列。主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。-上述过程的不断重复就是我们说的-Event-Loop-事件循环-。\"><a href=\"#同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入任务队列。主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。-上述过程的不断重复就是我们说的-Event-Loop-事件循环-。\" class=\"headerlink\" title=\"同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入任务队列。主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。 上述过程的不断重复就是我们说的 Event Loop (事件循环)。\"></a>同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入任务队列。主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。 上述过程的不断重复就是我们说的 Event Loop (事件循环)。</h3><p>在事件循环中，每进行一次循环操作称为tick，通过阅读规范可知，每一次 tick 的任务处理模型是比较复杂的，其关键的步骤可以总结如下：</p>\n<ol>\n<li>在此次 tick 中选择最先进入队列的任务( oldest task )，如果有则执行(一次)</li>\n<li>检查是否存在 Microtasks ，如果存在则不停地执行，直至清空Microtask Queue</li>\n<li>更新 render</li>\n<li>主线程重复执行上述步骤</li>\n</ol>\n<p>可以用一张图来说明下流程：</p>\n<p><img src=\"/images/v2-a38ad24f9109e1a4cb7b49cc1b90cafe_1440w.jpg\"></p>\n<p>这里相信有人会想问，什么是 microtasks ?规范中规定，task分为两大类, 分别是 Macro Task （宏任务）和 Micro Task（微任务）, 并且每个宏任务结束后, 都要清空所有的微任务,这里的 Macro Task也是我们常说的 task ，有些文章并没有对其做区分，后面文章中所提及的task皆看做宏任务( macro task)。</p>\n<p><strong>宏任务主要包含：script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)</strong></p>\n<p><strong>微任务主要包含：Promise、MutaionObserver、process.nextTick(Node.js 环境)</strong></p>\n<p>setTimeout/Promise 等API便是任务源，而进入任务队列的是由他们指定的具体执行任务。来自不同任务源的任务会进入到不同的任务队列。其中 setTimeout 与 setInterval 是同源的。</p>\n<h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3><p>掌握概念之后，我们来做一个例子强化一下：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;script start&#x27;</span>);\n\n<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;setTimeout&#x27;</span>);\n&#125;, <span class=\"hljs-number\">0</span>);\n\n<span class=\"hljs-built_in\">Promise</span>.resolve().then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;promise1&#x27;</span>);\n&#125;).then( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;promise2&#x27;</span>);\n&#125;);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;script end&#x27;</span>);</code></pre>\n\n<blockquote>\n<p>整体 script 作为第一个宏任务进入主线程，遇到 console.log，输出 script start<br>遇到 setTimeout，其回调函数被分发到宏任务 Event Queue 中<br>遇到 Promise，其 then函数被分到到微任务 Event Queue 中,记为 then1，之后又遇到了 then 函数，将其分到微任务 Event Queue 中，记为 then2<br>遇到 console.log，输出 script end  </p>\n</blockquote>\n<p><strong>至此，Event Queue 中存在三个任务：宏任务：setTimeout 微任务：then1、then2</strong></p>\n<p>执行微任务，首先执行then1，输出 promise1, 然后执行 then2，输出 promise2，这样就清空了所有微任务<br>执行 setTimeout 任务，输出 setTimeout 至此，输出的顺序是：script start, script end, promise1, promise2, setTimeout<br>再来一个题目，来做个练习：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;script start&#x27;</span>);\n\n<span class=\"hljs-built_in\">setTimeout</span>( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;timeout1&#x27;</span>);\n&#125;, <span class=\"hljs-number\">10</span>);\n\n**<span class=\"hljs-keyword\">new</span>** <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;promise1&#x27;</span>);\n    resolve();\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;timeout2&#x27;</span>), <span class=\"hljs-number\">10</span>);\n&#125;).then( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;then1&#x27;</span>)\n&#125;)\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;script end&#x27;</span>);</code></pre>\n\n<p>这个题目就稍微有点复杂了，我们再分析下：<br>首先，事件循环从宏任务 (macrotask) 队列开始，最初始，宏任务队列中，只有一个 scrip t(整体代码)任务；当遇到任务源 (task source) 时，则会先分发任务到对应的任务队列中去。所以，就和上面例子类似，首先遇到了console.log，输出 script start； 接着往下走，遇到 setTimeout 任务源，将其分发到任务队列中去，记为 timeout1； 接着遇到 promise，new promise 中的代码立即执行，输出 promise1, 然后执行 resolve ,遇到 setTimeout ,将其分发到任务队列中去，记为 timemout2, 将其 then 分发到微任务队列中去，记为 then1； 接着遇到 console.log 代码，直接输出 script end 接着检查微任务队列，发现有个 then1 微任务，执行，输出then1 再检查微任务队列，发现已经清空，则开始检查宏任务队列，执行 timeout1,输出 timeout1； 接着执行 timeout2，输出 timeout2 至此，所有的都队列都已清空，执行完毕。其输出的顺序依次是：script start, promise1, script end, then1, timeout1, timeout2</p>\n<p>用流程图看更清晰：<br><img src=\"/images/v2-a3ac02a230c49c9aa8c45af46eae2e1c_1440w.jpg\"></p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>总结<br>有个小 tip：从规范来看，microtask 优先于 task 执行，所以如果有需要优先执行的逻辑，放入microtask 队列会比 task 更早的被执行。</p>\n<p><strong>最后的最后，记住，JavaScript 是一门单线程语言，异步操作都是放到事件循环队列里面，等待主执行栈来执行的，并没有专门的异步执行线程。</strong></p>\n","prev":{"title":" 偏函数","slug":"javascript/31cb92dd1f"},"next":{"title":" 1. 页面导入样式时，使用link和@import有什么区别？","slug":"interview/d9026b0618"},"categories":[{"name":"javascript","slug":"javascript","count":21,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"}]}
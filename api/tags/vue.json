{"name":"vue","slug":"vue","count":2,"postlist":[{"title":" element-ui tabs的label slot不能及时动态更新","slug":"vue/017ad82dfe","date":"2019-06-09T00:00:00.000Z","updated":"2021-06-17T11:25:09.051Z","comments":true,"path":"api/articles/vue/017ad82dfe.json","excerpt":"","keywords":null,"cover":null,"content":"<p><a href=\"https://github.com/ElemeFE/element/issues/2934\">https://github.com/ElemeFE/element/issues/2934</a></p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">var</span> Main = &#123;\n    <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span>\n<span class=\"hljs-string\">&lt;el-tabs type=&quot;border-card&quot;&gt;</span>\n<span class=\"hljs-string\"> &lt;el-tab-pane :name=&quot;index&quot; v-for=&quot;(item, index) in tabs&quot;&gt;</span>\n<span class=\"hljs-string\">     &lt;span slot=&quot;label&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/span&gt;</span>\n<span class=\"hljs-string\">     &lt;div&gt;</span>\n<span class=\"hljs-string\">         &#123;&#123; item.name &#125;&#125;</span>\n<span class=\"hljs-string\">      &lt;input type=&quot;text&quot; v-model=&quot;item.name&quot; name=&quot;name&quot;/&gt;</span>\n<span class=\"hljs-string\">     &lt;/div&gt;</span>\n<span class=\"hljs-string\">  &lt;/el-tab-pane&gt;</span>\n<span class=\"hljs-string\">&lt;/el-tabs&gt;</span>\n<span class=\"hljs-string\">  `</span>,\n    <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n        <span class=\"hljs-keyword\">return</span> &#123;\n            <span class=\"hljs-attr\">tabs</span>: [\n                &#123;\n                    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;tab1&#x27;</span>,\n                    <span class=\"hljs-attr\">content</span>: <span class=\"hljs-string\">&#x27;Content Tab1&#x27;</span>,\n                &#125;,\n                &#123;\n                    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;tab2&#x27;</span>,\n                    <span class=\"hljs-attr\">content</span>: <span class=\"hljs-string\">&#x27;Content Tab2&#x27;</span>,\n                &#125;,\n                &#123;\n                    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;tab3&#x27;</span>,\n                    <span class=\"hljs-attr\">content</span>: <span class=\"hljs-string\">&#x27;Content Tab3&#x27;</span>,\n                &#125;,\n            ],\n        &#125;\n    &#125;,\n&#125;\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n    <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">&#x27;#app&#x27;</span>,\n    <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">h</span>) =&gt;</span> h(Main)\n&#125;)\n</code></pre>\n\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><pre><code class=\"hljs vim\"><span class=\"hljs-symbol\">&lt;el-tabs&gt;</span>, like &lt;<span class=\"hljs-keyword\">el</span>-<span class=\"hljs-keyword\">tabs</span> ref=<span class=\"hljs-string\">&quot;tabs&quot;</span>&gt;</code></pre>\n\n<pre><code class=\"hljs scss\">this.<span class=\"hljs-variable\">$refs</span><span class=\"hljs-selector-class\">.tabs</span>.<span class=\"hljs-variable\">$refs</span><span class=\"hljs-selector-class\">.nav</span>.<span class=\"hljs-variable\">$forceUpdate</span>();</code></pre>\n\n","text":"https://github.com/ElemeFE/element/issues/2934问题var Main = &#123;    template: `&lt;el-tabs type=&quot;border-card&quot;&gt; &lt;el-tab-pane","link":"","raw":null,"photos":[],"categories":[{"name":"vue","slug":"vue","count":2,"path":"api/categories/vue.json"}],"tags":[{"name":"javascript","slug":"javascript","count":25,"path":"api/tags/javascript.json"},{"name":"question","slug":"question","count":2,"path":"api/tags/question.json"},{"name":"vue","slug":"vue","count":2,"path":"api/tags/vue.json"}]},{"title":" 从 Event Loop 角度解读 Vue NextTick 源码","slug":"vue/cdb7936afb","date":"2021-06-08T09:04:03.000Z","updated":"2021-06-17T11:25:09.051Z","comments":true,"path":"api/articles/vue/cdb7936afb.json","excerpt":"","keywords":null,"cover":"/images/640.gif","content":"<h2 id=\"解读背景\"><a href=\"#解读背景\" class=\"headerlink\" title=\"解读背景\"></a>解读背景</h2><ol>\n<li>在学习 <strong>vue</strong> 源码，<strong>nextTick</strong> 方法借助了浏览器的 <strong>event loop</strong> 事件循环做到了异步更新。</li>\n<li>在公司面试的时候，笔试题最喜欢出关于 <strong>JavaScript</strong> 运行机制，<strong>Promise/A+</strong> 等关于 <strong>event loop</strong> 线程的题目。</li>\n<li>学会 <strong>nextTick</strong> 原理帮助定位 <strong>BUG</strong> , 使用 <strong>Vue</strong> 会更加灵活。</li>\n</ol>\n<h2 id=\"什么是-event-loop\"><a href=\"#什么是-event-loop\" class=\"headerlink\" title=\"什么是 event loop\"></a>什么是 event loop</h2><p><img src=\"/images/640.gif\"></p>\n<ol>\n<li>先执行同步阻塞任务，同步任务会等待上一个执行完毕以后执行下一个，当同步任务执行完毕，再执行异步任务，遇到异步任务会将异步任务的回调函数注册在异步任务队列里。注意，如果主线程上没有同步任务会直接调用异步任务的微任务。</li>\n<li>执行宏任务，遇到微任务将都添加到微任务队列里。</li>\n<li>开始执行微任务队列，当宏任务执行完后执行微任务队列，直到微任务队列全部执行完，微任务队列为空。</li>\n<li>执行宏任务，如果在执行宏任务期间有微任务，将微任务添加到微任务队列里，执行完宏任务之后执行微任务，直到微任务队列全部执行完。</li>\n<li>继续执行宏任务队列。</li>\n</ol>\n<p><strong>重复2, 3, 4，5……直到宏微任务为空。</strong></p>\n<h2 id=\"nextTick-的实现原理\"><a href=\"#nextTick-的实现原理\" class=\"headerlink\" title=\"$nextTick 的实现原理\"></a>$nextTick 的实现原理</h2><p>从字面意思理解，<strong>next</strong> 下一个，<strong>tick</strong> 滴答（钟表）来源于定时器的周期性中断（输出脉冲），一次中断表示一个 <strong>tick</strong>，也被称做一个“时钟滴答”），<strong>nextTick</strong> 顾名思义就是下一个时钟滴答。看源码，在 <strong>Vue 2.x</strong> 版本中，<strong>nextTick</strong> 在 <strong>src\\core\\util</strong> 中的一个单独的文件 <strong>next-tick.js</strong> ，可见 <strong>nextTick</strong> 的重要性，虽然短短 <strong>200</strong> 多行，尤大却单独创建一个文件去维护。<br>接下来我们来看整个文件。</p>\n<ol>\n<li>声明了三个全局变量，<strong>callbacks: [] ，pending: Boolean，timerFunc: undefined</strong>。</li>\n<li>声明了一个函数 <strong>flushCallbacks</strong>。</li>\n<li>一堆 **if，else if **判断。</li>\n<li>抛出了一个函数 <strong>nextTick</strong>。</li>\n</ol>\n<h2 id=\"nextTick-函数\"><a href=\"#nextTick-函数\" class=\"headerlink\" title=\"nextTick 函数\"></a>nextTick 函数</h2><p><img src=\"/images/640.png\"></p>\n<ol>\n<li>声明一个局部变量 <strong>_resolve</strong> 。</li>\n<li>把所有回调函数压进 <strong>callbacks</strong> 中，以栈的形式的存储所有 <strong>callback</strong>。</li>\n<li>当 <strong>pending</strong> 为 <strong>false</strong> 时，执行 <strong>timerFunc</strong> 函数。</li>\n<li>当没有 <strong>callback</strong> 的时候，返回一个 <strong>Promise</strong> 的调用方式，可以用 <strong>.then</strong> 接收。</li>\n</ol>\n<h2 id=\"timerFunc-函数\"><a href=\"#timerFunc-函数\" class=\"headerlink\" title=\"timerFunc 函数\"></a>timerFunc 函数</h2><p>我们开始说了，timerFunc 为全局变量，现在调用 timerFunc ，timerFunc 是什么时候被赋值为一个函数，并且函数里执行代码又是什么？</p>\n<p><img src=\"/images/640%202.png\"></p>\n<p>我们看到，这段判断代码总共有四个分支，四个分支里对 timerFunc 有不同的赋值，我们先来看第一个分支。</p>\n<h3 id=\"Promise-分支\"><a href=\"#Promise-分支\" class=\"headerlink\" title=\"Promise 分支\"></a>Promise 分支</h3><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Promise</span> !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class=\"hljs-built_in\">Promise</span>)) &#123;\n  <span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-built_in\">Promise</span>.resolve()\n  timerFunc = <span class=\"hljs-function\">() =&gt;</span> &#123;\n    p.then(flushCallbacks)\n    <span class=\"hljs-comment\">// In problematic UIWebViews, Promise.then doesn&#x27;t completely break, but</span>\n    <span class=\"hljs-comment\">// it can get stuck in a weird state where callbacks are pushed into the</span>\n    <span class=\"hljs-comment\">// microtask queue but the queue isn&#x27;t being flushed, until the browser</span>\n    <span class=\"hljs-comment\">// needs to do some other work, e.g. handle a timer. Therefore we can</span>\n    <span class=\"hljs-comment\">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span>\n    <span class=\"hljs-keyword\">if</span> (isIOS) <span class=\"hljs-built_in\">setTimeout</span>(noop)\n  &#125;\n  isUsingMicroTask = <span class=\"hljs-literal\">true</span>\n&#125;</code></pre>\n\n<ol>\n<li>判断环境是否支持 Promise 并且 <strong>Promise</strong> 是否为原生。</li>\n<li>使用 <strong>Promise</strong> 异步调用 <strong>flushCallbacks</strong> 函数。</li>\n<li>当执行环境是 <strong>iPhone</strong> 等，使用 <strong>setTimeout</strong> 异步调用 <strong>noop</strong> ，<strong>iOS</strong> <strong>中在一些异常的webview</strong> 中，<strong>promise</strong> 结束后任务队列并没有刷新所以强制执行 <strong>setTimeout</strong> 刷新任务队列。</li>\n</ol>\n<h3 id=\"MutationObserver-分支\"><a href=\"#MutationObserver-分支\" class=\"headerlink\" title=\"MutationObserver 分支\"></a>MutationObserver 分支</h3><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!isIE &amp;&amp; <span class=\"hljs-keyword\">typeof</span> MutationObserver !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span> &amp;&amp; (\n  isNative(MutationObserver) ||\n  <span class=\"hljs-comment\">// PhantomJS and iOS 7.x</span>\n  MutationObserver.toString() === <span class=\"hljs-string\">&#x27;[object MutationObserverConstructor]&#x27;</span>\n)) &#123;\n  <span class=\"hljs-comment\">// Use MutationObserver where native Promise is not available,</span>\n  <span class=\"hljs-comment\">// e.g. PhantomJS, iOS7, Android 4.4</span>\n  <span class=\"hljs-comment\">// (#6466 MutationObserver is unreliable in IE11)</span>\n  <span class=\"hljs-keyword\">let</span> counter = <span class=\"hljs-number\">1</span>\n  <span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> MutationObserver(flushCallbacks)\n  <span class=\"hljs-keyword\">const</span> textNode = <span class=\"hljs-built_in\">document</span>.createTextNode(<span class=\"hljs-built_in\">String</span>(counter))\n  observer.observe(textNode, &#123;\n    <span class=\"hljs-attr\">characterData</span>: <span class=\"hljs-literal\">true</span>\n  &#125;)\n  timerFunc = <span class=\"hljs-function\">() =&gt;</span> &#123;\n    counter = (counter + <span class=\"hljs-number\">1</span>) % <span class=\"hljs-number\">2</span>\n    textNode.data = <span class=\"hljs-built_in\">String</span>(counter)\n  &#125;\n  isUsingMicroTask = <span class=\"hljs-literal\">true</span>\n&#125;</code></pre>\n\n<ol>\n<li>对非IE浏览器和是否可以使用 <strong>HTML5</strong> 新特性 <strong>MutationObserver</strong> 进行判断。</li>\n<li>实例一个 <strong>MutationObserver</strong> 对象，这个对象主要是对浏览器 <strong>DOM</strong> 变化进行监听，当实例化 <strong>MutationObserver</strong> 对象并且执行对象 <strong>observe</strong>，设置 <strong>DOM</strong> 节点发生改变时自动触发回调。</li>\n<li>把 <strong>timerFunc</strong> 赋值为一个改变 <strong>DOM</strong> 节点的方法，当 <strong>DOM</strong> 节点发生改变，触发 <strong>flushCallbacks</strong> 。（这里其实就是想用利用 <strong>MutationObserver</strong> 的特性进行异步操作）</li>\n</ol>\n<h3 id=\"setImmediate-分支\"><a href=\"#setImmediate-分支\" class=\"headerlink\" title=\"setImmediate 分支\"></a>setImmediate 分支</h3><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> setImmediate !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;\n  <span class=\"hljs-comment\">// Fallback to setImmediate.</span>\n  <span class=\"hljs-comment\">// Technically it leverages the (macro) task queue,</span>\n  <span class=\"hljs-comment\">// but it is still a better choice than setTimeout.</span>\n  timerFunc = <span class=\"hljs-function\">() =&gt;</span> &#123;\n    setImmediate(flushCallbacks)\n  &#125;\n&#125;</code></pre>\n\n<ol>\n<li>判断 <strong>setImmediate</strong> 是否存在，<strong>setImmediate</strong> 是高版本 <strong>IE</strong> （IE10+） 和 <strong>edge</strong> 才支持的。</li>\n<li>如果存在，传入 <strong>flushCallbacks</strong> 执行 <strong>setImmediate</strong> 。</li>\n</ol>\n<h3 id=\"setTimeout-分支\"><a href=\"#setTimeout-分支\" class=\"headerlink\" title=\"setTimeout 分支\"></a>setTimeout 分支</h3><pre><code class=\"hljs coffeescript\"><span class=\"hljs-keyword\">else</span> &#123;\n  <span class=\"hljs-regexp\">//</span> Fallback to <span class=\"hljs-built_in\">setTimeout</span>.\n<span class=\"hljs-function\">  <span class=\"hljs-title\">timerFunc</span> = <span class=\"hljs-params\">()</span> =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">setTimeout</span>(flushCallbacks, <span class=\"hljs-number\">0</span>)\n  &#125;\n&#125;</code></pre>\n\n<ol>\n<li>当以上所有分支异步 <strong>api</strong> 都不支持的时候，使用 <strong>macro</strong> <strong>task</strong> （宏任务）的 <strong>setTimeout</strong> 执行 <strong>flushCallbacks</strong> 。</li>\n</ol>\n<h3 id=\"执行降级\"><a href=\"#执行降级\" class=\"headerlink\" title=\"执行降级\"></a>执行降级</h3><p>我们可以发现，给 timerFunc 赋值是一个降级的过程。为什么呢，因为 Vue 在执行的过程中，执行环境不同，所以要适配环境。</p>\n<p><img src=\"/images/640%203.png\"></p>\n<p>这张图便于我们更清晰的了解到降级的过程。</p>\n<h2 id=\"flushCallbacks-函数\"><a href=\"#flushCallbacks-函数\" class=\"headerlink\" title=\"flushCallbacks 函数\"></a>flushCallbacks 函数</h2><pre><code class=\"hljs nix\">function flushCallbacks () &#123;\n  <span class=\"hljs-attr\">pending</span> = <span class=\"hljs-literal\">false</span>\n  const <span class=\"hljs-attr\">copies</span> = callbacks.slice(<span class=\"hljs-number\">0</span>)\n  callbacks.<span class=\"hljs-attr\">length</span> = <span class=\"hljs-number\">0</span>\n  for (<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">i</span> = <span class=\"hljs-number\">0</span>; i &lt; copies.length; i++) &#123;\n    copies[i]()\n  &#125;\n&#125;</code></pre>\n\n<p>循环遍历，按照 <strong>队列</strong> 数据结构 <strong>“先进先出”</strong> 的原则，逐一执行所有 <strong>callback</strong> 。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>到这里就全部讲完了，<strong>nextTick</strong> 的原理就是利用 <strong>Event</strong> <strong>loop</strong> 事件线程去异步重新渲染，分支判断首要选择 <strong>Promise</strong> 的原因是当同步JS代码执行完毕，执行栈清空会首先查看 <strong>micro</strong> <strong>task</strong> （微任务）队列是否为空，不为空首先执行微任务。在我们 <strong>DOM</strong> 依赖数据发生变化的时候，会异步重新渲染 <strong>DOM</strong> ，但是比如像 <strong>echarts</strong> ，<strong>canvas</strong>……这些 <strong>Vue</strong> 无法在初始状态下收集依赖的 <strong>DOM</strong> ，我们就需要手动执行 <strong>nextTick</strong> 方法使其重新渲染。</p>\n","text":"解读背景在学习 vue 源码，nextTick 方法借助了浏览器的 event loop 事件循环做到了异步更新。在公司面试的时候，笔试题最喜欢出关于 JavaScript 运行机制，Promise/A+ 等关于 event loop 线程的题目。学会 nextTick 原理帮助","link":"","raw":null,"photos":[],"categories":[{"name":"vue","slug":"vue","count":2,"path":"api/categories/vue.json"}],"tags":[{"name":"vue","slug":"vue","count":2,"path":"api/tags/vue.json"}]}]}
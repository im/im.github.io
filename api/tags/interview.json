{"name":"interview","slug":"interview","count":9,"postlist":[{"title":" 7. HTML全局属性(global attribute)有哪些（包含H5）？","slug":"interview/09a7ebb8b8","date":"2020-07-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/interview/09a7ebb8b8.json","excerpt":"","keywords":null,"cover":null,"content":"<p><code>accesskey</code>   设置快捷键<br><code>class</code>  为元素设置类标识<br><code>contenteditable</code>  指定元素内容是否可编辑<br><code>contextmenu</code>  自定义鼠标右键弹出上下文菜单内容（仅firefox支持）<br><code>data-*</code>  为元素增加自定义属性<br>dir：设置元素文本方向（默认ltr；rtl）<br><code>draggable</code>  设置元素是否可拖拽<br><code>dropzone</code>  设置元素拖放类型（copy|move|link,H5新属性，主流均不支持）<br><code>hidden</code>  规定元素仍未或不在相关<br><code>id</code>  元素id，文档内唯一<br><code>lang</code>  元素内容的语言<br><code>spellcheck</code>  是否启动拼写和语法检查<br><code>style</code>  行内css样式<br><code>tabindex</code>  设置元素可以获得焦点，通过tab导航<br><code>title</code>  规定元素有关的额外信息</p>\n<blockquote>\n<p>相关链接：<a href=\"~https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes~\">Global attributes</a>  </p>\n</blockquote>\n","text":"accesskey   设置快捷键<br>class  为元素设置类标识<br>contenteditable  指定元素内容是否可编辑<br>contextmenu  自定义鼠标右键弹出上下文菜单内容（仅firefox支持）<br>data-*  为元素增加自定义属性<br>d","link":"","raw":null,"photos":[],"categories":[{"name":"interview","slug":"interview","count":9,"path":"api/categories/interview.json"}],"tags":[{"name":"interview","slug":"interview","count":9,"path":"api/tags/interview.json"},{"name":"everyday","slug":"everyday","count":7,"path":"api/tags/everyday.json"}]},{"title":" 4. html的元素有哪些（包含H5）？","slug":"interview/1d841137c9","date":"2020-09-14T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/interview/1d841137c9.json","excerpt":"<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>区分出行内元素、块级元素、空元素并在后面简要标注下作用</p>","keywords":null,"cover":null,"content":null,"text":"描述区分出行内元素、块级元素、空元素并在后面简要标注下作用行内元素abspanstrongiembuttoninputlabelbrtextareaselect块元素divph1-h6olullitabletbodytdtrtheaddldtddH5新增元素section  标签","link":"","raw":null,"photos":[],"categories":[{"name":"interview","slug":"interview","count":9,"path":"api/categories/interview.json"}],"tags":[{"name":"interview","slug":"interview","count":9,"path":"api/tags/interview.json"},{"name":"everyday","slug":"everyday","count":7,"path":"api/tags/everyday.json"}]},{"title":" 3. 用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值","slug":"interview/362e778681","date":"2020-12-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/interview/362e778681.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>这是一道大题目，把考点拆成了4个小项；需要侯选人用递归算法实现（限制15行代码以内实现；限制时间10分钟内完成）： </p>\n<ul>\n<li>生成一个长度为5的空数组 <code>arr</code> 。 </li>\n<li>生成一个（2－32）之间的随机整数 <code>rand</code>。</li>\n<li>把随机数 <code>rand</code> 插入到数组 <code>arr</code> 内，如果数组arr内已存在与 <code>rand</code> 相同的数字，则重新生成随机数<code>rand</code>并插入到<code>arr</code>内[需要使用递归实现，不能使用 <code>for/while</code> 等循环] </li>\n<li>最终输出一个长度为5，且内容不重复的数组 <code>arr</code> 。</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(<span class=\"hljs-number\">5</span>);\n<span class=\"hljs-keyword\">const</span> randomNum = <span class=\"hljs-function\">() =&gt;</span> (<span class=\"hljs-built_in\">Math</span>.floor(<span class=\"hljs-built_in\">Math</span>.random() * <span class=\"hljs-number\">31</span> + <span class=\"hljs-number\">2</span>))\n<span class=\"hljs-keyword\">const</span> randomArr = <span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (n === <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> arr;\n    <span class=\"hljs-keyword\">const</span> num = randomNum();\n    <span class=\"hljs-keyword\">if</span> (arr.includes(num)) <span class=\"hljs-keyword\">return</span> randomArr(n)\n    arr[n -<span class=\"hljs-number\">1</span>] = num;\n    <span class=\"hljs-keyword\">return</span> randomArr(n - <span class=\"hljs-number\">1</span>)\n&#125;;\nrandomArr(arr.length)\n</code></pre>\n\n","text":"描述这是一道大题目，把考点拆成了4个小项；需要侯选人用递归算法实现（限制15行代码以内实现；限制时间10分钟内完成）： 生成一个长度为5的空数组 arr 。 生成一个（2－32）之间的随机整数 rand。把随机数 rand 插入到数组 arr 内，如果数组arr内已存在与 ran","link":"","raw":null,"photos":[],"categories":[{"name":"interview","slug":"interview","count":9,"path":"api/categories/interview.json"}],"tags":[{"name":"interview","slug":"interview","count":9,"path":"api/tags/interview.json"},{"name":"everyday","slug":"everyday","count":7,"path":"api/tags/everyday.json"}]},{"title":" 2. 圣杯布局和双飞翼布局的理解和区别，并用代码实现","slug":"interview/82674f606e","date":"2020-11-10T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/interview/82674f606e.json","excerpt":"<h2 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h2><p>圣杯布局和双飞翼布局都是为了解决两边定宽，中间自适应且优先渲染的布局需求，那么为了自适应且优先渲染，必须要把中间的 <code>dom</code> 放在最顶端，以保证主要内容能最先被浏览器解析</p>\n<h2 id=\"圣杯布局\"><a href=\"#圣杯布局\" class=\"headerlink\" title=\"圣杯布局\"></a>圣杯布局</h2><p>为了中间 <code>div</code> 内容不被遮挡，将中间 <code>div</code> 设置了左右 <code>padding-left</code> 和 <code>padding-right</code> 后，将左右两个 <code>div</code> 用相对布局 <code>position: relative</code> 并分别配合 <code>right</code> 和 <code>left</code> 属性，以便左右两栏 <code>div</code> 移动后不遮挡中间 <code>div</code></p>\n<h3 id=\"html\"><a href=\"#html\" class=\"headerlink\" title=\"html\"></a>html</h3><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;hd&quot;</span>&gt;</span>header<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;bd&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;middle&quot;</span>&gt;</span>middle<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;left&quot;</span>&gt;</span>left<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;right&quot;</span>&gt;</span>right<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;footer&quot;</span>&gt;</span>footer<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span></code></pre>","keywords":null,"cover":null,"content":null,"text":"理解圣杯布局和双飞翼布局都是为了解决两边定宽，中间自适应且优先渲染的布局需求，那么为了自适应且优先渲染，必须要把中间的 dom 放在最顶端，以保证主要内容能最先被浏览器解析圣杯布局为了中间 div 内容不被遮挡，将中间 div 设置了左右 padding-left 和 paddi","link":"","raw":null,"photos":[],"categories":[{"name":"interview","slug":"interview","count":9,"path":"api/categories/interview.json"}],"tags":[{"name":"interview","slug":"interview","count":9,"path":"api/tags/interview.json"},{"name":"everyday","slug":"everyday","count":7,"path":"api/tags/everyday.json"}]},{"title":" 6 . 写一个方法去掉字符串中的空格","slug":"interview/8d5ea4ab3d","date":"2020-08-11T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/interview/8d5ea4ab3d.json","excerpt":"<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>写一个方法去掉字符串中的空格，要求传入不同的类型分别能去掉前、后、前后、中间的空格 </p>","keywords":null,"cover":null,"content":null,"text":"描述写一个方法去掉字符串中的空格，要求传入不同的类型分别能去掉前、后、前后、中间的空格 解答const str = &quot;  s t  r  &quot;;const POSITION = Object.freeze(&#123;    left: Symbol(),   ","link":"","raw":null,"photos":[],"categories":[{"name":"interview","slug":"interview","count":9,"path":"api/categories/interview.json"}],"tags":[{"name":"interview","slug":"interview","count":9,"path":"api/tags/interview.json"},{"name":"everyday","slug":"everyday","count":7,"path":"api/tags/everyday.json"}]},{"title":" 1. 页面导入样式时，使用link和@import有什么区别？","slug":"interview/d9026b0618","date":"2020-12-16T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/interview/d9026b0618.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>  页面导入样式时，使用link和@import有什么区别？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>link 是HTML标签，@import 是 css 提供的。</li>\n<li>link 引入的样式页面加载时同时加载，@import 引入的样式需等页面加载完成后再加载。</li>\n<li>link 没有兼容性问题，@import 不兼容 ie5 以下。</li>\n<li>link 可以通过 js 操作 DOM 动态引入样式表改变样式，而 @import 不可以。</li>\n</ol>\n","text":"描述  页面导入样式时，使用link和@import有什么区别？解答link 是HTML标签，@import 是 css 提供的。link 引入的样式页面加载时同时加载，@import 引入的样式需等页面加载完成后再加载。link 没有兼容性问题，@import 不兼容 ie5 ","link":"","raw":null,"photos":[],"categories":[{"name":"interview","slug":"interview","count":9,"path":"api/categories/interview.json"}],"tags":[{"name":"interview","slug":"interview","count":9,"path":"api/tags/interview.json"},{"name":"everyday","slug":"everyday","count":7,"path":"api/tags/everyday.json"}]},{"title":" HTML5的文件离线储存怎么使用，工作原理是什么？","slug":"interview/de0df6d619","date":"2021-06-07T02:31:02.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/interview/de0df6d619.json","excerpt":"","keywords":null,"cover":null,"content":"<p>HTML5离线存储存储功能非常强大，它的作用是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，自动更新缓存数据。</p>\n<h2 id=\"原理：\"><a href=\"#原理：\" class=\"headerlink\" title=\"原理：\"></a>原理：</h2><p>HTML5的离线存储是基于一个新建的.appcache文件的，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p>\n<h2 id=\"怎么用：\"><a href=\"#怎么用：\" class=\"headerlink\" title=\"怎么用：\"></a>怎么用：</h2><p>首先，在html页面头部加入一个manifest的属性:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">HTML</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">manifest</span> = <span class=\"hljs-string\">&quot;cache.manifest&quot;</span>&gt;</span>\n...\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span></code></pre>\n\n<p>然后书写cache.manifest文件：</p>\n<pre><code class=\"hljs avrasm\">CACHE MANIFEST\n<span class=\"hljs-meta\">#v0.11</span>\n\n<span class=\"hljs-symbol\">CACHE:</span>\njs/app.js\ncss/style.css\n\n<span class=\"hljs-symbol\">NETWORK:</span>\nresourse/logo.png\n\n<span class=\"hljs-symbol\">FALLBACK:</span>\n/ /offline.html</code></pre>\n\n<p>manifest （即 .appcache 文件）文件是简单的文本文件，可分为三个部分：</p>\n<h2 id=\"CACHE-：\"><a href=\"#CACHE-：\" class=\"headerlink\" title=\"CACHE ：\"></a>CACHE ：</h2><p>在此标题下列出的文件将在首次下载后进行缓存。（由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来）</p>\n<h2 id=\"NETWORK-：\"><a href=\"#NETWORK-：\" class=\"headerlink\" title=\"NETWORK ：\"></a>NETWORK ：</h2><p>在此标题下列出的文件需要与服务器的连接，且不会被缓存，离线时无法使用。 <br>可以使用 “*” 来指示所有其他资源/文件都需要因特网连接：</p>\n<pre><code class=\"hljs avrasm\"><span class=\"hljs-symbol\">NETWORK:</span> *</code></pre>\n\n<p>如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。</p>\n<h2 id=\"FALLBACK：\"><a href=\"#FALLBACK：\" class=\"headerlink\" title=\"FALLBACK：\"></a>FALLBACK：</h2><p>在此标题下列出的文件规定当页面无法访问时的回退页面。比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html。</p>\n<h2 id=\"浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\"><a href=\"#浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\" class=\"headerlink\" title=\"浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\"></a>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</h2><p>在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。<br>离线的情况下，浏览器就直接使用离线存储的资源。</p>\n","text":"HTML5离线存储存储功能非常强大，它的作用是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，自动更新缓存数据。原理：HTML5的离线存储是基于一个新建的.appcache文件的，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储","link":"","raw":null,"photos":[],"categories":[{"name":"interview","slug":"interview","count":9,"path":"api/categories/interview.json"}],"tags":[{"name":"interview","slug":"interview","count":9,"path":"api/tags/interview.json"},{"name":"html","slug":"html","count":2,"path":"api/tags/html.json"}]},{"title":" src 与 href 的区别","slug":"interview/f426fb17e9","date":"2021-06-07T02:13:24.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/interview/f426fb17e9.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"src\"><a href=\"#src\" class=\"headerlink\" title=\"src\"></a>src</h2><ul>\n<li>src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。</li>\n<li>src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素</li>\n</ul>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span> =<span class=\"hljs-string\">&quot;js.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n\n<p>  当浏览器解析到该元素时，<strong>会暂停其他资源的下载和处理</strong>，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。<strong>这也是为什么将js脚本放在底部而不是头部</strong> </p>\n<h2 id=\"href\"><a href=\"#href\" class=\"headerlink\" title=\"href\"></a>href</h2><ul>\n<li>href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加</li>\n</ul>\n<pre><code class=\"hljs routeros\">&lt;link <span class=\"hljs-attribute\">href</span>=<span class=\"hljs-string\">&quot;common.css&quot;</span> <span class=\"hljs-attribute\">rel</span>=<span class=\"hljs-string\">&quot;stylesheet&quot;</span>/&gt;</code></pre>\n\n<ul>\n<li> 那么浏览器会识别该文档为css文件，就会并行下载资源并且<strong>不会</strong>停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式</li>\n</ul>\n","text":"srcsrc用于替换当前元素，href用于在当前文档和引用资源之间确立联系。src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素&lt;scri","link":"","raw":null,"photos":[],"categories":[{"name":"interview","slug":"interview","count":9,"path":"api/categories/interview.json"}],"tags":[{"name":"interview","slug":"interview","count":9,"path":"api/tags/interview.json"},{"name":"html","slug":"html","count":2,"path":"api/tags/html.json"}]},{"title":" 8. 在页面上隐藏元素的方法有哪些？","slug":"interview/f4d551d5c3","date":"2019-07-03T00:00:00.000Z","updated":"2021-06-17T11:25:09.047Z","comments":true,"path":"api/articles/interview/f4d551d5c3.json","excerpt":"<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>在页面上隐藏元素的方法有哪些？ 并简述出第一种方法的应用场景和优劣势</p>","keywords":null,"cover":null,"content":null,"text":"描述在页面上隐藏元素的方法有哪些？ 并简述出第一种方法的应用场景和优劣势解答占位:visibility: hidden;  看不见但是会占据空间<br>margin-left: -100%;<br>opacity: 0; 看不见但是会占据空间<br>transform: scal","link":"","raw":null,"photos":[],"categories":[{"name":"interview","slug":"interview","count":9,"path":"api/categories/interview.json"}],"tags":[{"name":"interview","slug":"interview","count":9,"path":"api/tags/interview.json"},{"name":"everyday","slug":"everyday","count":7,"path":"api/tags/everyday.json"}]}]}